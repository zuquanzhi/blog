<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>718校内赛技术报告</title>
    <url>/2023/11/27/718%E6%A0%A1%E5%86%85%E8%B5%9B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p>此篇博客用于记录校内赛的技术细节和感悟（屎山预警！！！）</p>
<span id="more"></span>

<h1 id="1-硬件"><a href="#1-硬件" class="headerlink" title="1. 硬件"></a>1. 硬件</h1><h2 id="1-1-红外对管"><a href="#1-1-红外对管" class="headerlink" title="1.1 红外对管"></a>1.1 红外对管</h2><p>排布见下图：</p>
<p><img src="/2023/11/27/718%E6%A0%A1%E5%86%85%E8%B5%9B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/2.png" alt="红外对管排布"></p>
<p>其中4 5作为循迹灯，其余全部用于路口判断。</p>
<h3 id="1-1-1-循迹"><a href="#1-1-1-循迹" class="headerlink" title="1.1.1 循迹"></a>1.1.1 循迹</h3><p>利用左右循迹灯实现循迹，使用了PID算法，只使用了P和D，详细说明见2.1。</p>
<h3 id="1-1-2-路口判断逻辑"><a href="#1-1-2-路口判断逻辑" class="headerlink" title="1.1.2 路口判断逻辑"></a>1.1.2 路口判断逻辑</h3><p>利用1 2 3 0四个红外对管实现对路口的识别。</p>
<p>另外规定ADC的值&gt;1900为完全踩上线，ADC的值小于lowx为完全没踩上线，ADC的值大于lowx+200（需要大些）为正在踩上线。</p>
<p>我们对路口的分类如下：</p>
<p><img src="/2023/11/27/718%E6%A0%A1%E5%86%85%E8%B5%9B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/1.png" alt="公式"></p>
<h2 id="1-2-机械臂"><a href="#1-2-机械臂" class="headerlink" title="1.2 机械臂"></a>1.2 机械臂</h2><p>构成：亚克力板，三个MG90S舵机，胶带，热熔胶，夹子，螺丝，螺母。</p>
<p>自由度：3</p>
<p>设计想法：为了便于能量块的夹取和定点投放</p>
<h1 id="2-软件"><a href="#2-软件" class="headerlink" title="2. 软件"></a>2. 软件</h1><p>注：此部分主要内容及解释都在代码注释中</p>
<h2 id="2-1-宏及全局变量"><a href="#2-1-宏及全局变量" class="headerlink" title="2.1 宏及全局变量"></a>2.1 宏及全局变量</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AD.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x_it.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> kp 0.90     </span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> kd -80      </span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> high1 2100</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> low1 1800</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> high2 2400</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> low2  2000</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> delaytime 200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换通道个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOFCHANEL 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILTER_SIZE 5  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> filtered_AD0[FILTER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int16_t</span> filtered_AD1[FILTER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int16_t</span> filtered_AD2[FILTER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int16_t</span> filtered_AD3[FILTER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int16_t</span> filtered_AD4[FILTER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int16_t</span> filtered_AD5[FILTER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//用于储存ADC返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 ADC1 转换的电压值通过 DMA 方式传到 SRAM</span></span><br><span class="line"><span class="keyword">extern</span> __IO <span class="type">uint16_t</span> ADC_ConvertedValue[NOFCHANEL];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量，用于保存转换计算后的电压值</span></span><br><span class="line"><span class="type">float</span> ADC_ConvertedValueLocal[NOFCHANEL];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> et = <span class="number">0</span>;</span><br><span class="line"><span class="type">int16_t</span> det = <span class="number">0</span>;</span><br><span class="line"><span class="type">int16_t</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="type">int16_t</span> wucha =<span class="number">0</span>;</span><br><span class="line"><span class="comment">//PID中变量，用于更新误差等数据</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-主函数及初始化"><a href="#2-2-主函数及初始化" class="headerlink" title="2.2 主函数及初始化"></a>2.2 主函数及初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    USART_Config();</span><br><span class="line">    TIM1_CH4_PWM_Init();</span><br><span class="line">    PWM_Init();</span><br><span class="line">    AD_Init();</span><br><span class="line">    wucha =AD_Value[<span class="number">4</span>]-AD_Value[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;7&#x27;</span>==ucTemp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pid();</span><br><span class="line">                <span class="comment">// 在特殊路口执行特殊操作</span></span><br><span class="line">                <span class="keyword">if</span> (isTIntersection()) &#123;</span><br><span class="line">                    handleTIntersection();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftTurn()) &#123;</span><br><span class="line">                    handleLeftTurn();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRightTurn()) &#123;</span><br><span class="line">                    handleRightTurn();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRoundabout()) &#123;</span><br><span class="line">                    handleRoundabout();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isRound()) &#123;</span><br><span class="line">                    handleROUND();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&#x27;6&#x27;</span>==ucTemp	)</span><br><span class="line">                &#123;Motor_Run(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                 Motor_Run(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                 <span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;5&#x27;</span>==ucTemp)</span><br><span class="line">        &#123;<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            BlueTeeth();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;6&#x27;</span>==ucTemp	)</span><br><span class="line">            &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;8&#x27;</span>==ucTemp)</span><br><span class="line">        &#123;<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pid();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;6&#x27;</span>==ucTemp)</span><br><span class="line">            &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-PID"><a href="#2-3-PID" class="headerlink" title="2.3 PID"></a>2.3 PID</h2><p>我们的小车只使用了P和D，因为我们实现闭环的不是加速度，所以不需要用积分项去逼近目标位置。P好理解，就是正比于误差的量；但P也不能太小，否则P太小的话转弯太慢，导致S弯绕不过去。D作为斜率可以通过抑制P的趋势来实现消抖的功能。</p>
<p>理论学习如下：</p>
<ul>
<li>整体思路：ADC采样—&gt;对ADC采样数据的数学处理—&gt;对得到的数据进行PID算法运算—&gt;赋值给ccr调整pwm波输出占空比驱动电机。循环此过程则可实现速度闭环实现直角弯道除外的赛道。</li>
<li>方案：两灯and三灯。但考虑到两灯操作更简单，对硬件兼容性更高。最终采用两灯方案。 </li>
<li>理论理解：</li>
</ul>
<p>尽可能的扩大两个参数的值域：ADC数学处理获得值、小车识别黑线范围。针对第一个参数，当此值变化范围很大时，可以获得更高的精度调控；针对第二个参数，当此值变化范围很大时，可以扩大小车的“视野”，即使已经偏线也可以回归正轨。</p>
<p>归根结底，重点在于数学处理。</p>
<ul>
<li>实操理解：</li>
</ul>
<p>@针对采样：</p>
<p><strong>重要参数：</strong>单个采样范围及变化趋势，单个采样值。</p>
<p><strong>单个采样范围及变化趋势：</strong>非常有限，几乎不触及黑线采样值变化很小，但一接近黑线立即成指数增长。</p>
<p><strong>单个采样值：</strong>几百个体差异到约2300的原始值。但转化为电压值之后仅为 0~3.3，大量数据被压缩，损失了很多精度，最终决定采用原始值进行操作。</p>
<p><strong>误差来源</strong>：环境红外线影响，红外对管个体差异，红外对管彼此距离，红外对管对地距离。</p>
<p><strong>环境红外线影响</strong>：很大。非常影响红外对管采集数据。最终解决办法有两种，一是在每个红外对管四周缠上黑胶布，用以反射环境红外线并聚合红外对管发出的红外线；二是在代码中初始化过程中消除环境误差并不需要测得，但随着小车运动导致的位置改变，环境误差在变化，而我们只消除了开始的误差，我们选择使用动态消除误差。</p>
<p><strong>红外对管个体差异：</strong>不同红外对管的峰值大致相同，但最低值各有千秋。有的一两百，有的却五六百。考虑到对ADC采样数据进行处理时，个体误差的存在会影响很多计算结果造成两个灯调节作用差别很大。故必须消除。最终我们采用个体采样值域大的红外对管，以输出更加灵敏的值，并在代码中在初始化过程中，连同环境误差一起消除。</p>
<p><strong>红外对管彼此距离：</strong>主要影响两点，一是识别范围，二是数学处理时产生漏洞。对于第一点，两灯距离太小时，识别范围就太小，小车遇到稍抖一点的弯路时极易偏线，但两灯距离过大时，就相当于允许小车有一定程度的偏线，造成循迹不流畅。对于第二点，若两灯距离过小，此时可以忽略个体误差，但同时ADC数学处理获得值值域很小，调节精度或说范围很小，若两灯距离过大，两灯之间会留出一个处理值为0的空白区允许小车一定程度偏线，这是我们不希望看到的。</p>
<p><strong>红外对管对地距离</strong>：主要影响红外对管的采样值域。对地距离过低时红外对管接收不到反射光，采样值很低，对地距离过高时很受环境光干扰，接收红外线很多，采样值很高，通过打印波形图来观察何对地距离红外对管的检测距离最大，以及采样值域最大。</p>
<p>@针对数学处理：</p>
<p><strong>处理参数：</strong>识别范围，输出值。</p>
<p><strong>识别范围：</strong>即小车的“视野”，能够允许偏线程度最大的情况下依然可以回归正轨。</p>
<p><strong>输出值：</strong>作为偏差，进行PID运算后，改变ccr来改变电机占空比。</p>
<p><strong>处理方法与消除误差：</strong></p>
<p> 缺少能够作为条件的判断，所以只有让两灯采样值相减，同时让两灯在同一环境下初始化，记录两灯差值，然后代入程序中来消除个体误差和环境误差，然后调用ADC数据处理函数。</p>
<p>@针对PID：</p>
<p>本次任务中采用位置式PID，且用到P与D参与运算。</p>
<p>采用PD系统调节原因：通过P进行主导线形控制，通过D来计算未来趋势抑制系统震荡，即通过PD系统获得更快的反应速度。符合循迹需求。</p>
<p>输入值：实时计算ADC数学处理获得值与目标值0的差值</p>
<p>输出值：除了初始占空比以外的用于控制电机的pwm</p>
<p>偏差：ADC数学处理获得值与目标值0的差值，用于P计算</p>
<p>二次偏差：前后两次偏差的差值，用于D计算</p>
<p>调参注意：P过小调节作用小，P过大造成过冲系统震荡。D过小调节作用小，D过大会放大系统趋势的影响，使系统震荡。</p>
<p>调参顺序：先设D&#x3D;0，调P，从0逐渐增大，直到系统震荡。再调D使其逐渐增大，直到系统震荡。之后进行微调，直到系统稳定。</p>
<p>@针对电机控制：</p>
<p>调节方式：对两边电机附PID不同运算值，以达到使两侧不同性能电机具有相同效果的调节作用。</p>
<p>调节精度及限制：</p>
<p>考虑到可供调节的ccr范围为0~500( 有点小，占空比的相对调节精度小），但考虑到对循迹小车来讲500的调节范围够用，所以没改，但后来调车发现问题，发现有些曲率较大的弯转不过去，起初认为是P设的过小，但经过数学运算后发现问题是数值溢出，即能转过这个弯路的PID处理值没发挥出它的作用，因为溢出下限即占空比为0，溢出上限即占空比为100，所以最终采用【循迹电机反转函数】的使用，使溢出值得到充分利用。事实上增大ccr的可操作区间亦可。</p>
<p>初始值设置：一开始设置为50%占空比，因为考虑到想使PID调节具有对称性。事实效果很好，循迹很丝滑，但后来考虑到走直线速度较慢，故逐渐增大初始占空比，再具体进行调参。</p>
<p>详细解释见下方代码注释。</p>
<h3 id="2-3-1-PID代码"><a href="#2-3-1-PID代码" class="headerlink" title="2.3.1 PID代码"></a>2.3.1 PID代码</h3><h4 id="2-3-1-1-PID基本原理"><a href="#2-3-1-1-PID基本原理" class="headerlink" title="2.3.1.1 PID基本原理"></a>2.3.1.1 PID基本原理</h4><p><strong>PID详解</strong></p>
<ul>
<li><strong>比例增益（P）：</strong> 比例部分根据当前误差的大小调整输出。如果误差较大，比例增益会产生更大的输出变化，以更快地减小误差。然而，如果比例增益设置得太大，系统可能会变得不稳定。 </li>
<li><strong>积分时间（I）：</strong> 积分部分考虑了误差随时间的积累。它用于消除系统稳态误差，因为它会持续增加控制输出，直到误差为零。但如果积分时间设置得太大，可能导致系统的超调或振荡。 </li>
<li><strong>微分时间（D）：</strong> 微分部分考虑了误差变化的速度。它可以帮助系统抑制振荡，因为它对误差变化的速度进行响应，减小输出的变化速度。然而，如果微分时间设置得太大，可能会导致系统对噪声敏感。</li>
</ul>
<p><strong>PID算法基本原理</strong></p>
<p><em>PID算法的执行流程是非常简单的，即利用反馈来检测偏差信号，并通过偏差信号来控制被控量。而控制器本身就是比例、积分、微分三个环节的加和。</em></p>
<p><img src="/2023/11/27/718%E6%A0%A1%E5%86%85%E8%B5%9B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/3.png" alt="公式"></p>
<p>根据上图我们考虑在某个特定的时刻t，此时输入量为rin(t)，输出量为rout(t)，于是偏差就可计算为err(t)&#x3D;rin(t)-rout(t)。于是PID的基本控制规律就可以表示为如下公式：</p>
<p><img src="/2023/11/27/718%E6%A0%A1%E5%86%85%E8%B5%9B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/4.png" alt="公式"><br><em>其中Kp为比例带，TI为积分时间，TD为微分时间。</em></p>
<p>PID算法离散化</p>
<p>由于在计算机上应实现离散化问题，我们对比例，积分，微分特性做简单说明。</p>
<p>比例就是用来对系统的偏差进行反应，所以只要存在偏差，比例就会起作用。积分主要是用来消除静差，所谓静差就是指系统稳定后输入输出之间依然存在的差值，而积分就是通过偏差的累计来抵消系统的静差。而微分则是对偏差的变化趋势做出反应，根据偏差的变化趋势实现超前调节，提高反应速度。</p>
<p>在实现离散前，我们假设系统采样周期为T。假设我们检查第K个采样周期，很显然系统进行第K次采样。此时的偏差可以表示为err(K)&#x3D;rin(K)-rout(K)，那么积分就可以表示为：err(K)+ err(K+1)+┈┈，而微分就可以表示为：(err(K)- err(K-1))&#x2F;T。于是我们可以将第K次采样时，PID算法的离线形式表示为：</p>
<p><img src="/2023/11/27/718%E6%A0%A1%E5%86%85%E8%B5%9B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/5.png" alt="公式"><br>这就是所谓的PID算法离散描述公式。还有一个增量型PID算法，下面来推导一下。<br>上面的公式描述了第k哥采样周期的结果，那么前一时刻也就是k-1哥采样周期可表示为：</p>
<p><img src="/2023/11/27/718%E6%A0%A1%E5%86%85%E8%B5%9B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/6.png" alt="公式"><br>那么我们再来说第K个采样周期的增量，很显然就是U(k)-U(k-1)。于是我们用第k个采样周期公式减去第k-1个采样周期的公式，就得到了增量型PID算法的表示公式：</p>
<p><img src="/2023/11/27/718%E6%A0%A1%E5%86%85%E8%B5%9B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/7.png" alt="公式"></p>
<p>当然，增量型PID必须记得一点，就是在记住U(k)&#x3D;U(k-1)+∆U(k)</p>
<p><strong>PID控制器基本实现</strong></p>
<p>完成了离散化后，我们就可以来实现它了。已经用离散化的数据公式表示出来后，再进型计算机编程已经不是问题了。接下来我们就使用C语言分别针对位置型公式和增量型公式来具体实现。</p>
<p>位置型PID简单实现</p>
<p>位置型PID的实现就是以前面的位置型公式为基础。这一节我们只是完成最简单的实现，也就是将前面的离散位置型PID公式的计算机语言化。<br>首先定义PID对象的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义结构体和公用体*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> setpoint;       <span class="comment">//设定值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> proportiongain;     <span class="comment">//比例系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> integralgain;      <span class="comment">//积分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> derivativegain;    <span class="comment">//微分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> lasterror;     <span class="comment">//前一拍偏差</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> result; <span class="comment">//输出值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> integral;<span class="comment">//积分值</span></span><br><span class="line"></span><br><span class="line">&#125;PID;</span><br></pre></td></tr></table></figure>



<p>接下来<strong>实现PID控制器：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PIDRegulation</span><span class="params">(PID *vPID, <span class="type">float</span> processValue)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> thisError;</span><br><span class="line"></span><br><span class="line">  thisError=vPID-&gt;setpoint-processValue;</span><br><span class="line"></span><br><span class="line">  vPID-&gt;integral+=thisError;</span><br><span class="line"></span><br><span class="line">  vPID-&gt;result=vPID-&gt;proportiongain*thisError+vPID-&gt;integralgain*vPID-&gt;integral+vPID-&gt;derivativegain*(thisError-vPID-&gt;lasterror);</span><br><span class="line"></span><br><span class="line">  vPID-&gt;lasterror=thisError;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这就实现了一个最简单的位置型PID控制器，当然没有考虑任何干扰条件，仅仅只是对数学公式的计算机语言化。</p>
<p><strong>增量型PID简单实现</strong></p>
<p>增量型PID的实现就是以前面的增量型公式为基础。这一节我们只是完成最简单的实现，也就是将前面的离散增量型PID公式的计算机语言化。</p>
<p>首先定义PID对象的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义结构体和公用体*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> setpoint;       <span class="comment">//设定值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> proportiongain;     <span class="comment">//比例系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> integralgain;      <span class="comment">//积分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> derivativegain;    <span class="comment">//微分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> lasterror;     <span class="comment">//前一拍偏差</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> preerror;     <span class="comment">//前两拍偏差</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> deadband;     <span class="comment">//死区</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> result; <span class="comment">//输出值</span></span><br><span class="line"></span><br><span class="line">&#125;PID;</span><br></pre></td></tr></table></figure>

<p><strong>位置型PID控制器的基本特点：</strong></p>
<ul>
<li>位置型PID控制的输出与整个过去的状态有关，用到了偏差的累加值，容易产生累积偏差。</li>
<li>位置型PID适用于执行机构不带积分部件的对象。</li>
<li>位置型的输出直接对应对象的输出，对系统的影响比较大。</li>
</ul>
<p><strong>增量型PID控制器的基本特点：</strong></p>
<ul>
<li>增量型PID算法不需要做累加，控制量增量的确定仅与最近几次偏差值有关，计算偏差的影响较小。</li>
<li>增量型PID算法得出的是控制量的增量，对系统的影响相对较小。</li>
<li>采用增量型PID算法易于实现手动到自动的无扰动切换。</li>
</ul>
<h4 id="2-3-1-2-最终代码实现"><a href="#2-3-1-2-最终代码实现" class="headerlink" title="2.3.1.2 最终代码实现"></a>2.3.1.2 最终代码实现</h4><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取滤波后的值</span></span><br><span class="line">    <span class="type">int16_t</span> filtered_AD4_value = getFilteredValue(filtered_AD4);</span><br><span class="line">    <span class="type">int16_t</span> filtered_AD5_value = getFilteredValue(filtered_AD5);</span><br><span class="line"></span><br><span class="line">    et = filtered_AD4_value - filtered_AD5_value - wucha;</span><br><span class="line">    det = et - temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((kp) * et &lt; <span class="number">200</span>) &amp;&amp; ((kp) * et &gt; <span class="number">-200</span>)) &#123;</span><br><span class="line">        MotorControl(FRONT, <span class="number">1000</span> + (kp)/<span class="number">2</span> * et - kd * det);</span><br><span class="line">    &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (kp * et &lt;= <span class="number">-50</span>) &#123;  </span><br><span class="line">        MotorControl(LEFT, <span class="number">-100</span> - kp * et + kd * det);  </span><br><span class="line">        MotorControl(FRONT, <span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (kp* et &gt;= <span class="number">50</span>) &#123;</span><br><span class="line">        MotorControl(FRONT, <span class="number">1000</span>);</span><br><span class="line">        MotorControl(RIGHT, kp * et - <span class="number">100</span> - kd * det);</span><br><span class="line">    &#125;</span><br><span class="line">    temp = et;<span class="comment">//pid输出值暂存</span></span><br><span class="line"></span><br><span class="line">    updateFilter(filtered_AD4, AD_Value[<span class="number">4</span>]);</span><br><span class="line">    updateFilter(filtered_AD5, AD_Value[<span class="number">5</span>]);</span><br><span class="line">    <span class="comment">//更新滤波输入，减小误差</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-路口识别"><a href="#2-4-路口识别" class="headerlink" title="2.4 路口识别"></a>2.4 路口识别</h2><p>在本节中，详细讲讲判断环岛及真假环岛的逻辑（即连续两次左&#x2F;右T型路口，左手定则为右T型，右手定则为左T型），其余路口都较为简单，不多赘述。</p>
<p>以左手定则走右环岛为例，首先不论环岛的真假，先判断连续两个右T型路口。我们设置了标志位flag（详见2.2主函数），在每次识别到非右T型路口时将其置零；在判断到右T型路口时将其取反，然后在下面写个若flag为0就进环岛函数的if，这样就实现了判断连续两个右T型路口。（详见2.4.1，2.4.3）</p>
<p>接着就是环岛的走法及判断环岛的真假。</p>
<p>(1) 环岛走法的大致逻辑就是，首先在第二个右T型路口右拐进环岛，然后识别环岛内第一个路口为右拐（第一个while，右拐后跳出），然后识别第二个路口为右拐（第二个while，右拐后跳出），然后识别第三个路口为T字型路口（第三个while，右拐后跳出），并return0，出函数再把flag置0，防止其一直走环岛。</p>
<p>(2) 判断环岛真假的大致逻辑是，在上述依次识别三个路口过程中，只要有一个识别到的路口与我们设定的路口不一致，就立马结束整个环岛函数并return相应的值（比如第一个路口不一致了就返回1，第二个不一致就返回2，第三个不一致就返回3），然后在循迹函数里做相应的处理。这里的处理也好理解，先让小车转180度，然后用switch case语句，从case3开始往case1写，内容便是按原路返回，然后在最初始的路口右拐。</p>
<p>比较有趣的是，我们发现在左手定则的大前提下，如果在同一个路口连续使用偶数次右手定则，则完全不会破坏左手定则的逻辑，换句话说，同一路口的偶数次右手定则等价于1次左手定则。</p>
<p>当然，从假环岛出来后还得把flag置1，这样又能解决走右T型+右环岛时进不了环岛的问题。</p>
<p>其代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否为断头路</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isRound</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (AD_Value[<span class="number">7</span>] &lt; <span class="number">2000</span>	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理断头路的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleROUND</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	  performAction(BACK_ACTION, <span class="number">300</span>);</span><br><span class="line">    performAction(LEFT_ACTION, <span class="number">1300</span>);</span><br><span class="line">	 performAction(LEFT_ACTION, <span class="number">900</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为 T 字灯特殊路口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTIntersection</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (AD_Value[<span class="number">2</span>] &gt; high1 &amp;&amp; AD_Value[<span class="number">0</span>] &gt; high1 &amp;&amp; AD_Value[<span class="number">1</span>] &lt; low1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 T 字灯特殊路口的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleTIntersection</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">	  performAction(STOP_ACTION, <span class="number">500</span>);</span><br><span class="line">	  <span class="comment">//performAction(BACK_ACTION, 300);</span></span><br><span class="line">    performAction(FRONT_ACTION, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为左拐路口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLeftTurn</span><span class="params">(<span class="type">void</span>)</span> &#123; </span><br><span class="line">	<span class="keyword">return</span> (AD_Value[<span class="number">2</span>] &gt; high2 &amp;&amp; AD_Value[<span class="number">0</span>] &lt; low2 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为右拐路口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isRightTurn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (AD_Value[<span class="number">2</span>] &lt; low1 &amp;&amp; AD_Value[<span class="number">0</span>] &gt; high1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理左拐路口的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleLeftTurn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  performAction(STOP_ACTION, <span class="number">500</span>);  </span><br><span class="line">	<span class="comment">//performAction(BACK_ACTION, 300);</span></span><br><span class="line">    performAction(LEFT_ACTION, <span class="number">1400</span>);</span><br><span class="line">	 performAction(FRONT_ACTION, <span class="number">500</span>);</span><br><span class="line">    pid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理右拐路口的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleRightTurn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    performAction(STOP_ACTION, <span class="number">500</span>);</span><br><span class="line">	  <span class="comment">//performAction(BACK_ACTION, 300);</span></span><br><span class="line">    performAction(RIGHT_ACTION, <span class="number">1500</span>);</span><br><span class="line">	  performAction(FRONT_ACTION, <span class="number">500</span>);</span><br><span class="line">     pid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为环岛</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isRoundabout</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (AD_Value[<span class="number">2</span>] &gt; high1 &amp;&amp; AD_Value[<span class="number">0</span>] &gt; high1 &amp;&amp; AD_Value[<span class="number">0</span>] &gt; high1 &amp;&amp; AD_Value[<span class="number">1</span>] &gt; high1 &amp;&amp; AD_Value[<span class="number">4</span>] &gt; high1 &amp;&amp; AD_Value[<span class="number">5</span>] &gt; high1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理进入环岛的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleRoundabout</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    performAction(STOP_ACTION, <span class="number">500</span>);</span><br><span class="line">    performAction(FRONT_ACTION, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">CROSS_JUDG</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(AD_Value[<span class="number">1</span>]&gt;<span class="number">2000</span>&amp;&amp;AD_Value[<span class="number">2</span>]&gt;<span class="number">2000</span>)</span><br><span class="line">     &#123;a=<span class="number">1</span>;&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(AD_Value[<span class="number">1</span>]&gt;<span class="number">2000</span>&amp;&amp;AD_Value[<span class="number">0</span>]&gt;<span class="number">2000</span>)</span><br><span class="line">			&#123;a=<span class="number">2</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(AD_Value[<span class="number">1</span>]&gt;<span class="number">2000</span>&amp;&amp;AD_Value[<span class="number">0</span>]&gt;<span class="number">2000</span>&amp;&amp;AD_Value[<span class="number">2</span>]&gt;<span class="number">2000</span>)</span><br><span class="line">			&#123;a=<span class="number">3</span>;&#125;</span><br><span class="line">		<span class="keyword">switch</span>(a)</span><br><span class="line">			&#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				      <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				     MoveDirection(LEFT);</span><br><span class="line">			       Delay_s(<span class="number">1</span>);</span><br><span class="line">			       <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				     MoveDirection(RIGHT);</span><br><span class="line">			       Delay_s(<span class="number">1</span>);</span><br><span class="line">			       <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				     MoveDirection(RIGHT);</span><br><span class="line">			       Delay_s(<span class="number">1</span>);</span><br><span class="line">			       <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-5-蓝牙"><a href="#2-5-蓝牙" class="headerlink" title="2.5 蓝牙"></a>2.5 蓝牙</h2><p>蓝牙这块比较简单，只是一个简单的通信协议，其中给i赋的值都是ASCII码，然后在手机的按键里设置相应的字符即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BlueTeeth</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;1&#x27;</span> == ucTemp)<span class="comment">//前进</span></span><br><span class="line">    &#123;</span><br><span class="line">        MoveDirection(FRONT);</span><br><span class="line">        <span class="comment">//	ucTemp = &#x27;0&#x27;;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> == ucTemp)<span class="comment">//松开手机上的按键就让其停下</span></span><br><span class="line">            &#123;</span><br><span class="line">                MoveDirection(STOP);</span><br><span class="line">                ucTemp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;2&#x27;</span> == ucTemp)<span class="comment">//后退</span></span><br><span class="line">    &#123;</span><br><span class="line">        MoveDirection(BACK);</span><br><span class="line">        <span class="comment">//ucTemp = &#x27;0&#x27;;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> == ucTemp)<span class="comment">//松开手机上的按键就让其停下</span></span><br><span class="line">            &#123;</span><br><span class="line">                MoveDirection(STOP);</span><br><span class="line">                ucTemp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;3&#x27;</span> == ucTemp)<span class="comment">//左转</span></span><br><span class="line">    &#123;</span><br><span class="line">        MoveDirection(LEFT);</span><br><span class="line">        <span class="comment">//ucTemp = &#x27;0&#x27;;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> == ucTemp)<span class="comment">//松开手机上的按键就让其停下</span></span><br><span class="line">            &#123;</span><br><span class="line">                MoveDirection(STOP);</span><br><span class="line">                ucTemp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;4&#x27;</span> == ucTemp)<span class="comment">//右转</span></span><br><span class="line">    &#123;</span><br><span class="line">        MoveDirection(RIGHT);</span><br><span class="line">        <span class="comment">//ucTemp = &#x27;0&#x27;;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> == ucTemp)<span class="comment">//松开手机上的按键就让其停下</span></span><br><span class="line">            &#123;</span><br><span class="line">                MoveDirection(STOP);</span><br><span class="line">                ucTemp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-电机控制"><a href="#2-6-电机控制" class="headerlink" title="2.6 电机控制"></a>2.6 电机控制</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 控制电机运行</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MotorControl</span><span class="params">(Direction direction, <span class="type">int</span> speed)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">        <span class="keyword">case</span> FRONT:</span><br><span class="line">            left_up();</span><br><span class="line">            right_up();</span><br><span class="line">            Motor_Run(<span class="number">0</span>,speed);</span><br><span class="line">            Motor_Run(<span class="number">1</span>,speed);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACK:</span><br><span class="line">            left_down();</span><br><span class="line">            right_down();</span><br><span class="line">            Motor_Run(<span class="number">0</span>,speed);</span><br><span class="line">            Motor_Run(<span class="number">1</span>,speed);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEFT:</span><br><span class="line">            left_down();</span><br><span class="line">            right_up();</span><br><span class="line">            Motor_Run(<span class="number">0</span>,speed);</span><br><span class="line">            Motor_Run(<span class="number">1</span>,speed);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RIGHT:</span><br><span class="line">            left_up();</span><br><span class="line">            right_down();</span><br><span class="line">            Motor_Run(<span class="number">0</span>,speed);</span><br><span class="line">            Motor_Run(<span class="number">1</span>,speed);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STOP:</span><br><span class="line">            left_up();</span><br><span class="line">            right_up();</span><br><span class="line">            Motor_Run(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            Motor_Run(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制轮子正反转</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">performAction</span><span class="params">(ActionType action, <span class="type">int</span> duration)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> STOP_ACTION:</span><br><span class="line">            MotorControl(STOP, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FRONT_ACTION:</span><br><span class="line">            MotorControl(FRONT, <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACK_ACTION:</span><br><span class="line">            MotorControl(BACK, <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEFT_ACTION:</span><br><span class="line">            MotorControl(LEFT, <span class="number">1300</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RIGHT_ACTION:</span><br><span class="line">            MotorControl(RIGHT, <span class="number">1300</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Delay_ms(duration);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制轮子旋转90°</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MoveDirection</span><span class="params">(Direction direction)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">        <span class="keyword">case</span> FRONT:</span><br><span class="line">            MotorControl(FRONT, <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACK:</span><br><span class="line">            MotorControl(BACK, <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEFT:</span><br><span class="line">            MotorControl(LEFT, <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RIGHT:</span><br><span class="line">            MotorControl(RIGHT, <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STOP:</span><br><span class="line">            MotorControl(STOP, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">轮子的直接控制</span><br></pre></td></tr></table></figure>

<p>这一部分的代码主要是电机四个轮子的直接控制封装，由于左右两侧的轮子分别可以看作统一步调，故可以调整电机参数后统一输出PWM，达到同步效果。（底层封装略）</p>
<h2 id="2-7机械臂"><a href="#2-7机械臂" class="headerlink" title="2.7机械臂"></a>2.7机械臂</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NeoSWSerial.h&quot;</span></span></span><br><span class="line">NeoSWSerial <span class="title function_">mySerial</span><span class="params">(<span class="number">12</span>, <span class="number">13</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVOS      (4)     <span class="comment">// 机械臂需要的舵机个数</span></span></span><br><span class="line"></span><br><span class="line">Servo arm_servos[SERVOS];   <span class="comment">// 声明SERVOS个舵机</span></span><br><span class="line"><span class="type">int</span> servo_pins[SERVOS];         <span class="comment">// 舵机要接入的主板IO口</span></span><br><span class="line"><span class="type">int</span> servo_cur_angle[SERVOS];    <span class="comment">// 舵机当前的旋转角度</span></span><br><span class="line"><span class="type">int</span> servo_min_angle[SERVOS];    <span class="comment">// 允许舵机旋转到达的最小值</span></span><br><span class="line"><span class="type">int</span> servo_max_angle[SERVOS];    <span class="comment">// 允许舵机旋转到达的最大值</span></span><br><span class="line"><span class="type">int</span> servo_init_angle[SERVOS];   <span class="comment">// 刚上电时，舵机的初始角度</span></span><br><span class="line"><span class="type">int</span> joystick_value[SERVOS];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOYSTICK_MIN_THRESH     (300)   <span class="comment">// 摇杆ADC值的最小阈值，用于判断摇杆向哪边推动了</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOYSTICK_MAX_THRESH     (700)   <span class="comment">// 摇杆ADC值的最大阈值，用于判断摇杆向哪边推动了</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLAW_OPEN_ANGLE     (45)    <span class="comment">// 爪子张开时的舵机角度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLAW_CLOSE_ANGLE    (5)    <span class="comment">// 爪子闭合时的舵机角度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLAW_SERVO_INDEX    (SERVOS-1)  <span class="comment">// 爪子舵机的序号，倒数第一个</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEARN_MAX_ACTIONS   (100)   <span class="comment">// 学习模式最多可记录的动作个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> learning_mode = <span class="literal">false</span>;  <span class="comment">// 是否进入学习模式？</span></span><br><span class="line"><span class="type">bool</span> repeat_mode = <span class="literal">false</span>;  <span class="comment">// 是否重复刚才学习到的动作？(配合学习模式使用)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> learn_actions[LEARN_MAX_ACTIONS][SERVOS];   <span class="comment">// 学习模式存储记录动作</span></span><br><span class="line"><span class="type">int</span> learn_action_count = <span class="number">0</span>;                     <span class="comment">// 学习模式记录了多少动作？</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSPEED    (10)    <span class="comment">// 舵机最大旋转速度</span></span></span><br><span class="line"><span class="type">int</span> demo_speed = <span class="number">1</span>;         <span class="comment">// 1倍速、2倍速......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOYSTICK_LEFT_BUTTON    (2)     <span class="comment">// 左键用于学习模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOYSTICK_RIGHT_BUTTON   (4)     <span class="comment">// 右键用于播放预设动作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOYSTICK_LED            (3)     <span class="comment">// 摇杆模块上面的LED灯，接入主板3号脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> has_btn_been_pressed = <span class="literal">false</span>;          <span class="comment">// 记录上次的按键状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  pinMode(JOYSTICK_LEFT_BUTTON, INPUT_PULLUP);      <span class="comment">// 左键用于学习模式</span></span><br><span class="line">  pinMode(JOYSTICK_RIGHT_BUTTON, INPUT_PULLUP);     <span class="comment">// 右键用于播放预设动作</span></span><br><span class="line"></span><br><span class="line">  pinMode(JOYSTICK_LED, OUTPUT);</span><br><span class="line">  digitalWrite(JOYSTICK_LED, HIGH); <span class="comment">// 亮灯</span></span><br><span class="line"></span><br><span class="line">  Serial.println(<span class="string">&quot;System Running...&quot;</span>);</span><br><span class="line">  Serial.print(digitalRead(JOYSTICK_LEFT_BUTTON));      <span class="comment">//读取并串口打印按键状态</span></span><br><span class="line">  Serial.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">  Serial.println(digitalRead(JOYSTICK_RIGHT_BUTTON));   <span class="comment">//读取并串口打印按键状态</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bluetooth Module UART default baudrate is 9600</span></span><br><span class="line">  mySerial.begin(<span class="number">9600</span>);</span><br><span class="line">  delay(<span class="number">200</span>);</span><br><span class="line">  test_bluetooth_module();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化工作</span></span><br><span class="line">  initialization();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == digitalRead(JOYSTICK_LEFT_BUTTON))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 左键用于学习模式</span></span><br><span class="line">    learning_mode = <span class="literal">true</span>;</span><br><span class="line">    has_btn_been_pressed = <span class="literal">true</span>;  <span class="comment">// 记录有按键按下了！</span></span><br><span class="line">    learn_action_count = <span class="number">0</span>;</span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">    digitalWrite(JOYSTICK_LED, LOW);    <span class="comment">// 灭灯</span></span><br><span class="line"></span><br><span class="line">    Serial.println(<span class="string">&quot;Enter learning_mode!!&quot;</span>);    <span class="comment">// 进入学习模式</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == digitalRead(JOYSTICK_RIGHT_BUTTON))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 右键用于播放预设动作</span></span><br><span class="line">    play_demo_mode = <span class="literal">true</span>;</span><br><span class="line">    has_btn_been_pressed = <span class="literal">true</span>;  <span class="comment">// 记录有按键按下了！</span></span><br><span class="line">    Serial.println(<span class="string">&quot;Enter play_demo_mode!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始播放预设动作序列</span></span><br><span class="line">    play_demo();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 炫耀武力，爪子抓2次</span></span><br><span class="line">    cut_cut();</span><br><span class="line">    Serial.println(<span class="string">&quot;Enter Bluetooth/JoyStick Control Mode!!&quot;</span>);    <span class="comment">// 进入摇杆操控模式</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 手机APP 操控机械臂工作</span></span><br><span class="line">  move_by_bluetooth();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 摇杆模块操控机械臂工作</span></span><br><span class="line">  move_by_joystick_contrl();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 学习模式，需要和摇杆操控互相配合</span></span><br><span class="line">  learning_actions();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_bluetooth_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.print(<span class="string">&quot;\nTest Bluetooth Module: start\n&quot;</span>);</span><br><span class="line">  <span class="type">char</span> cmd[<span class="number">16</span>] = <span class="string">&quot;AT+NAME\r\n\r\n&quot;</span>;</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(cmd);</span><br><span class="line">  Serial.println(cmd);</span><br><span class="line">  Serial.println(len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len + <span class="number">1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    mySerial.write(cmd[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">200</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (mySerial.available())</span><br><span class="line">    &#123;</span><br><span class="line">      Serial.print(mySerial.read(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.print(<span class="string">&quot;\nTest Bluetooth Module: end\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialization</span><span class="params">()</span> &#123;</span><br><span class="line">  servo_pins[<span class="number">0</span>] = <span class="number">11</span>;           <span class="comment">// pin 11 -- Servo base   底座舵机</span></span><br><span class="line">  servo_min_angle[<span class="number">0</span>] = <span class="number">0</span>;       <span class="comment">// 允许舵机旋转到达的最小值</span></span><br><span class="line">  servo_max_angle[<span class="number">0</span>] = <span class="number">180</span>;     <span class="comment">// 允许舵机旋转到达的最大值</span></span><br><span class="line">  servo_init_angle[<span class="number">0</span>] = <span class="number">90</span>;     <span class="comment">// 刚上电时，舵机的初始角度</span></span><br><span class="line"></span><br><span class="line">  servo_pins[<span class="number">1</span>] = <span class="number">10</span>;           <span class="comment">// 10 : Servo left   左臂舵机</span></span><br><span class="line">  servo_min_angle[<span class="number">1</span>] = <span class="number">10</span>;      <span class="comment">// 允许舵机旋转到达的最小值</span></span><br><span class="line">  servo_max_angle[<span class="number">1</span>] = <span class="number">140</span>;     <span class="comment">// 允许舵机旋转到达的最大值</span></span><br><span class="line">  servo_init_angle[<span class="number">1</span>] = <span class="number">90</span>;     <span class="comment">// 刚上电时，舵机的初始角度</span></span><br><span class="line"></span><br><span class="line">  servo_pins[<span class="number">2</span>] = <span class="number">9</span>;            <span class="comment">//  9 : Servo right  右臂舵机</span></span><br><span class="line">  servo_min_angle[<span class="number">2</span>] = <span class="number">40</span>;      <span class="comment">// 允许舵机旋转到达的最小值</span></span><br><span class="line">  servo_max_angle[<span class="number">2</span>] = <span class="number">170</span>;     <span class="comment">// 允许舵机旋转到达的最大值</span></span><br><span class="line">  servo_init_angle[<span class="number">2</span>] = <span class="number">90</span>;     <span class="comment">// 刚上电时，舵机的初始角度</span></span><br><span class="line"></span><br><span class="line">  servo_pins[<span class="number">3</span>] = <span class="number">5</span>;                        <span class="comment">//  5 : Servo claw   爪子舵机</span></span><br><span class="line">  servo_min_angle[<span class="number">3</span>] = CLAW_CLOSE_ANGLE;    <span class="comment">// 允许舵机旋转到达的最小值</span></span><br><span class="line">  servo_max_angle[<span class="number">3</span>] = CLAW_OPEN_ANGLE;     <span class="comment">// 允许舵机旋转到达的最大值</span></span><br><span class="line">  servo_init_angle[<span class="number">3</span>] = CLAW_OPEN_ANGLE;   <span class="comment">// 刚上电时，舵机的初始角度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 学习模式清空所有动作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; LEARN_MAX_ACTIONS; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span> ; j &lt; SERVOS; j++) &#123;</span><br><span class="line">      learn_actions[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给所有舵机设置初始角度</span></span><br><span class="line">  init_servos();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_servos</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SERVOS; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    arm_servos[i].attach(servo_pins[i], <span class="number">500</span>, <span class="number">2500</span>);      <span class="comment">// 把舵机关联到对应的PWM引脚上</span></span><br><span class="line">    arm_servos[i].write(servo_init_angle[i]); <span class="comment">// 写入舵机的初始角度</span></span><br><span class="line">    joystick_value[i] = <span class="number">0</span>;                    <span class="comment">// 摇杆ADC值初始化为0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 炫耀武力，爪子抓2次</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cut_cut</span><span class="params">()</span> &#123;</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    close_claw(<span class="literal">true</span>);</span><br><span class="line">    delay(<span class="number">150</span>);</span><br><span class="line">    close_claw(<span class="literal">false</span>);</span><br><span class="line">    delay(<span class="number">150</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制爪子开闭</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">close_claw</span><span class="params">(<span class="type">bool</span> close)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (close) &#123;</span><br><span class="line">    arm_servos[CLAW_SERVO_INDEX].write(CLAW_CLOSE_ANGLE);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    arm_servos[CLAW_SERVO_INDEX].write(CLAW_OPEN_ANGLE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_by_joystick_contrl</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> joy_changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SERVOS; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 读取摇杆ADC值</span></span><br><span class="line">    <span class="comment">// A0 --&gt; joystick_value[0] --&gt; 左摇杆左右推，控制底座舵机旋转；</span></span><br><span class="line">    <span class="comment">// A1 --&gt; joystick_value[1] --&gt; 左摇杆前后推，控制左臂舵机旋转；</span></span><br><span class="line">    <span class="comment">// A2 --&gt; joystick_value[2] --&gt; 右摇杆前后推，控制右臂舵机旋转；</span></span><br><span class="line">    <span class="comment">// A3 --&gt; joystick_value[3] --&gt; 右摇杆左右推，控制爪子舵机旋转；</span></span><br><span class="line">    joystick_value[i] = analogRead(i);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="comment">// 串口打印摇杆ADC值</span></span><br><span class="line">    Serial.print(<span class="string">&quot;A[&quot;</span>);</span><br><span class="line">    Serial.print(i);</span><br><span class="line">    Serial.print(<span class="string">&quot;]=&quot;</span>);</span><br><span class="line">    Serial.print(joystick_value[i]);</span><br><span class="line">    Serial.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取舵机当前的旋转角度</span></span><br><span class="line">    servo_cur_angle[i] = arm_servos[i].read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (joystick_value[i] &gt; JOYSTICK_MAX_THRESH)    <span class="comment">// 摇杆ADC值超过最大阈值</span></span><br><span class="line">    &#123;</span><br><span class="line">      joy_changed = <span class="literal">true</span>;    <span class="comment">// 摇杆被推动过了！</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (servo_cur_angle[i] &gt; servo_min_angle[i])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果舵机当前角度，大于，允许舵机旋转到达的最小值，则舵机角度降低1度</span></span><br><span class="line">        --servo_cur_angle[i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i == CLAW_SERVO_INDEX)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果是爪子舵机，则直接闭合爪子</span></span><br><span class="line">        servo_cur_angle[i] = CLAW_OPEN_ANGLE;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (joystick_value[i] &lt; JOYSTICK_MIN_THRESH)   <span class="comment">// 摇杆ADC值小于最小阈值</span></span><br><span class="line">    &#123;</span><br><span class="line">      joy_changed = <span class="literal">true</span>;   <span class="comment">// 摇杆被推动过了！</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (servo_cur_angle[i] &lt; servo_max_angle[i])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果舵机当前角度，小于，允许舵机旋转到达的最大值，则舵机角度增加1度</span></span><br><span class="line">        ++servo_cur_angle[i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i == CLAW_SERVO_INDEX)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果是爪子舵机，则直接打开爪子</span></span><br><span class="line">        servo_cur_angle[i] = CLAW_CLOSE_ANGLE;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span> == joy_changed)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 只要摇杆被推动过了，就刷新一遍舵机角度: 将当前最新的舵机角度值，写入舵机</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; SERVOS; i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">      <span class="comment">// 串口打印舵机角度</span></span><br><span class="line">      Serial.print(<span class="string">&quot;servo[&quot;</span>);</span><br><span class="line">      Serial.print(i);</span><br><span class="line">      Serial.print(<span class="string">&quot;]=&quot;</span>);</span><br><span class="line">      Serial.print(servo_cur_angle[i]);</span><br><span class="line">      Serial.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      arm_servos[i].write(servo_cur_angle[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delay(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_by_bluetooth</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">bool</span> joy_changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mySerial.available())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> inByte = mySerial.read();</span><br><span class="line">    Serial.print(inByte);</span><br><span class="line">    <span class="keyword">if</span> ((inByte != (<span class="type">char</span>)<span class="number">0xFF</span>) &amp;&amp; (inByte != (<span class="type">char</span>)<span class="number">0x0A</span>) &amp;&amp; (inByte != (<span class="type">char</span>)<span class="number">0x0D</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      joy_changed = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">switch</span> (inByte)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (servo_cur_angle[<span class="number">0</span>] &lt; servo_max_angle[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 如果舵机当前角度，小于，允许舵机旋转到达的最大值，则舵机角度增加1度</span></span><br><span class="line">              ++servo_cur_angle[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (servo_cur_angle[<span class="number">0</span>] &gt; servo_min_angle[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 如果舵机当前角度，大于，允许舵机旋转到达的最小值，则舵机角度降低1度</span></span><br><span class="line">              --servo_cur_angle[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (servo_cur_angle[<span class="number">1</span>] &lt; servo_max_angle[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 如果舵机当前角度，小于，允许舵机旋转到达的最大值，则舵机角度增加1度</span></span><br><span class="line">              ++servo_cur_angle[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (servo_cur_angle[<span class="number">1</span>] &gt; servo_min_angle[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 如果舵机当前角度，大于，允许舵机旋转到达的最小值，则舵机角度降低1度</span></span><br><span class="line">              --servo_cur_angle[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 爪子舵机，直接闭合爪子</span></span><br><span class="line">            servo_cur_angle[<span class="number">3</span>] = CLAW_CLOSE_ANGLE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">          &#123;            </span><br><span class="line">            <span class="comment">// 爪子舵机，直接打开爪子</span></span><br><span class="line">            servo_cur_angle[<span class="number">3</span>] = CLAW_OPEN_ANGLE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (servo_cur_angle[<span class="number">2</span>] &gt; servo_min_angle[<span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 如果舵机当前角度，大于，允许舵机旋转到达的最小值，则舵机角度降低1度</span></span><br><span class="line">              --servo_cur_angle[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (servo_cur_angle[<span class="number">2</span>] &lt; servo_max_angle[<span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 如果舵机当前角度，小于，允许舵机旋转到达的最大值，则舵机角度增加1度</span></span><br><span class="line">              ++servo_cur_angle[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            joy_changed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span> == joy_changed)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 只要手机APP摇杆被推动过了，就刷新一遍舵机角度: 将当前最新的舵机角度值，写入舵机</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; SERVOS; i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">      <span class="comment">// 串口打印舵机角度</span></span><br><span class="line">      Serial.print(<span class="string">&quot;servo[&quot;</span>);</span><br><span class="line">      Serial.print(i);</span><br><span class="line">      Serial.print(<span class="string">&quot;]=&quot;</span>);</span><br><span class="line">      Serial.print(servo_cur_angle[i]);</span><br><span class="line">      Serial.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      arm_servos[i].write(servo_cur_angle[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    move_from_to:</span></span><br><span class="line"><span class="comment">    目的是，让机械臂的2个动作之间的变化、运动、转移，更加平滑，</span></span><br><span class="line"><span class="comment">    不要让舵机瞬间完成角度切换，一方面增加舵机使用寿命，一方面机械臂工作更加自然。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_from_to</span><span class="params">(<span class="type">int</span> *action_from, <span class="type">int</span> *action_to)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> max_angle = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> max_steps = <span class="number">0</span>;</span><br><span class="line">  <span class="type">float</span> step_angle[SERVOS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调整机械臂的运动、转移速度</span></span><br><span class="line">  adjust_speed();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 找到角度变化最大的那个舵机，算出角度变化绝对值max_angle；</span></span><br><span class="line"><span class="comment">    2. 角度变化值max_angle ÷ 舵机旋转速度demo_speed，就是舵机要运行的步数max_steps；</span></span><br><span class="line"><span class="comment">    3. 根据总步数max_steps，计算出每个舵机单步转动的角度step_angle；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  max_angle = max(max(<span class="built_in">abs</span>(action_to[<span class="number">0</span>] - action_from[<span class="number">0</span>]), <span class="built_in">abs</span>(action_to[<span class="number">1</span>] - action_from[<span class="number">1</span>])), <span class="built_in">abs</span>(action_to[<span class="number">2</span>] - action_from[<span class="number">2</span>]));</span><br><span class="line">  max_steps = max_angle / demo_speed;</span><br><span class="line">  max_steps = max_steps &lt; <span class="number">1</span> ? <span class="number">1</span> : max_steps;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CLAW_SERVO_INDEX; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    step_angle[i] = <span class="type">float</span>(action_to[i] - action_from[i]) / <span class="type">float</span>(max_steps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= max_steps; j++) <span class="comment">// 步数j累加</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CLAW_SERVO_INDEX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 随着j慢慢增大，new_angle 会慢慢趋近于 action_to[i]，也就实现了运动平滑的效果</span></span><br><span class="line">      <span class="type">int</span> new_angle = action_from[i] + j * step_angle[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((new_angle &lt; servo_min_angle[i]) || (new_angle &gt; servo_max_angle[i]))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 舵机角度值超出范围，忽略</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      arm_servos[i].write(new_angle);  <span class="comment">// 将最新的角度值，写入舵机</span></span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 爪子舵机的开闭动作，不需要平滑过渡，直接设置角度给舵机</span></span><br><span class="line">  arm_servos[CLAW_SERVO_INDEX].write(action_to[CLAW_SERVO_INDEX]);</span><br><span class="line">  delay(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 播放预设动作序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">play_demo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 计算总共有多少个动作？</span></span><br><span class="line">  <span class="type">int</span> counts = <span class="keyword">sizeof</span>(demo_actions) / (SERVOS * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">  Serial.print(<span class="string">&quot;demo_actions counts = &quot;</span>);</span><br><span class="line">  Serial.println(counts);</span><br><span class="line"></span><br><span class="line">  move_from_to(servo_init_angle, demo_actions[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; counts - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 摇杆左右键，任何按键按下，结束播放预设动作序列</span></span><br><span class="line">      <span class="keyword">if</span> (is_btn_pressed())</span><br><span class="line">      &#123;</span><br><span class="line">        learning_mode = <span class="literal">false</span>;</span><br><span class="line">        repeat_mode = <span class="literal">false</span>;</span><br><span class="line">        play_demo_mode = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 机械臂从当前动作，运动、转移至下一个动作</span></span><br><span class="line">      move_from_to(demo_actions[i], demo_actions[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整机械臂的运动、转移速度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">adjust_speed</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 任何一个摇杆推动任何一个方向，都可以调整速度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SERVOS; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (analogRead(i) &gt; JOYSTICK_MAX_THRESH) demo_speed++; <span class="comment">// 速度加</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (analogRead(i) &lt; JOYSTICK_MIN_THRESH) demo_speed--; <span class="comment">// 速度减</span></span><br><span class="line">  &#125;</span><br><span class="line">  demo_speed = demo_speed &lt; <span class="number">1</span> ? <span class="number">1</span> : demo_speed;</span><br><span class="line">  demo_speed = demo_speed &gt; MAXSPEED ? MAXSPEED : demo_speed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_btn_pressed</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="literal">false</span> == has_btn_been_pressed) &amp;&amp; ((<span class="number">0</span> == digitalRead(JOYSTICK_RIGHT_BUTTON)) || (<span class="number">0</span> == digitalRead(JOYSTICK_LEFT_BUTTON))))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果上次没有按键按下，而现在左键或者右键按下了，则认为现在确实有按键按下了</span></span><br><span class="line">    has_btn_been_pressed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="number">1</span> == digitalRead(JOYSTICK_RIGHT_BUTTON)) &amp;&amp; (<span class="number">1</span> == digitalRead(JOYSTICK_LEFT_BUTTON)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果左右键都没有按下，则认为确实没有按键按下</span></span><br><span class="line">    has_btn_been_pressed = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>机械臂使用的是arduino生态，主要使用了arduinoUNO这个板子，同时也加装了蓝牙模块，代码封装函数和stm32略有不同。</p>
<h2 id="2-8滤波器"><a href="#2-8滤波器" class="headerlink" title="2.8滤波器"></a>2.8滤波器</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">updateFilter</span><span class="params">(<span class="type">int16_t</span>* buffer, <span class="type">int16_t</span> newValue)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = FILTER_SIZE - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        buffer[i] = buffer[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[<span class="number">0</span>] = newValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">getFilteredValue</span><span class="params">(<span class="type">int16_t</span>* buffer)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算缓冲区内所有值的平均值</span></span><br><span class="line">    <span class="type">int32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; FILTER_SIZE; i++) &#123;</span><br><span class="line">        sum += buffer[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / FILTER_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加入滤波器相关程序的考虑如下：</strong></p>
<p><strong>1.减少控制器的灵敏度：</strong> 滤波器可以减少PID控制器对高频噪声和干扰的敏感度。这有助于防止PID控制器对系统中不必要的快速变化作出响应，从而提高系统的稳定性。</p>
<p><strong>2.滤波测量信号：</strong> 在PID控制中，测量信号可能受到噪声的影响。通过对测量信号应用滤波器，可以改善系统对实际状态的感知，提高控制性能。</p>
<p><strong>3.避免控制器振荡：</strong> 滤波器有助于减小系统中可能引起控制器振荡的高频成分。这有助于防止控制器在某些条件下产生不稳定的振荡。</p>
<p>后来经过测试证明，我们的设计是有很大效果的，极大程度上降低了红外对管物种多样性的阴间影响</p>
<h1 id="3-总结及反思"><a href="#3-总结及反思" class="headerlink" title="3. 总结及反思"></a>3. 总结及反思</h1><h2 id="3-1-软件方面"><a href="#3-1-软件方面" class="headerlink" title="3.1 软件方面"></a>3.1 软件方面</h2><ul>
<li>由于缺乏经验和想法，在最开始的直接控制上浪费了很多时间（and金钱），当代码完成后，可以发现很多封装其实是没有必要的，而且会降低循迹的反应速度和稳定性。</li>
<li>在封装控制函数的过程中出现了“各自为政的现象”，造成了大量的冗余。直到后来才发现有些参数几乎是可以复用的，完全可以通过定义少数的宏来节省大量空间，并增强代码的可读性，提高运行效率。</li>
<li>我们在最终的代码里尝试定义了一个类似于摩擦系数的宏，所有的参数可以根据这个宏计算来调节，理论上只要知道比赛场地的路况等信息就可以一键调节所有的速度、角度等参数，从而节省了大量的调参时间。但是在最终的结果中我们发现这种定义方式并不足以满足各种复杂情况，主要因素如下：</li>
</ul>
<p>1.各个电机和红外对管的性能不同，统一调控会导致系统整体的兼容性和稳定性下降。</p>
<p>2.路况复杂的情况下，盲目地追求减少调参时间是不可取的。</p>
<p>因此，虽然宏的使用是一个很好的尝试，但在实践中，我们也意识到需要更为灵活和细致的参数调整，以适应不同的实际情况。这一过程是一个不断优化和润色代码的过程，通过反复实验和调整，逐步找到最优的参数配置。这也是在机器人控制领域中常见的挑战之一，需要不断学习和改进。</p>
<h2 id="3-2-硬件方面"><a href="#3-2-硬件方面" class="headerlink" title="3.2 硬件方面"></a>3.2 硬件方面</h2><ul>
<li>由于对新生板的使用不够熟悉，我们在参赛前最后一天先后损坏了数块板子的电源等模块，为正式比赛优化代码造成了很恶劣的影响。</li>
<li>由于对比赛规则的不熟悉，在选购机械臂时出现了严重失误，机械臂的抬升高度不足以支持能量块的投放，故在正式比赛时我们放弃了给机械臂通电，避免电能的无效浪费。</li>
<li>面对IO口稀少的情况，我们使用的焊接杜邦线的骚操作，我们承认这一行为给我们减少了很多麻烦，但是电流的减弱也曾一度让我们的电机面临驱动力不足等问题，好在可以通过更改PWM占空比缓解这一问题。</li>
</ul>
<h2 id="3-3-工程经验方面"><a href="#3-3-工程经验方面" class="headerlink" title="3.3 工程经验方面"></a>3.3 工程经验方面</h2><ul>
<li>工程经验的缺少使我们分工不够明确，效率不够高效。好在大家目标一致，最终较为圆满地完成了部分任务，离不开所有队员的倾力合作和集思广益。</li>
</ul>
<h1 id="4-感悟"><a href="#4-感悟" class="headerlink" title="4.感悟"></a>4.感悟</h1><ul>
<li><p>肝了一个月，这是大上学以来第一次独立做出可使用的工程（<em>虽然垃圾得一批</em>），学到了很多以前自认为要大三甚至大四才能碰到的知识，像L298电驱，PWM波占空比的调节，PID控制算法，各种路口判断的设计，在现场实地修（乱）改参数等，碰到了各种各样逆天且玄学的问题，such as芯片的神奇短路，电源模块莫名暴毙，ADC接口的梦幻联动，（至今工位上还摆放着四块待救治的板子）。——<strong>特此衷心感谢硬件陈学长的力挽狂澜</strong></p>
</li>
<li><p>与此同时明显感觉到C语言的能力得到了大幅度提升（尤其时造轮子的能力仿佛登峰造极），还练就了一身从屎里找吃的硬能力。</p>
<p>本篇博客就当成一个里程碑吧，纪念这疯狂熬夜的一个月（以及未来将要熬的无数个月），同时感谢718的各位学长（不）厌其烦的讲解和帮助。</p>
</li>
</ul>
<p><strong>外链：<a href="https://www.yuque.com/quanzhi-ndfvt/azx1dc/udzvfrcvol51mwr4?singleDoc#">https://www.yuque.com/quanzhi-ndfvt/azx1dc/udzvfrcvol51mwr4?singleDoc#</a> 《2023校内赛技术报告》</strong></p>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>寻迹车 蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode0485</title>
    <url>/2023/11/21/LeetCode0485/</url>
    <content><![CDATA[<h1 id="最大连续-1-的个数"><a href="#最大连续-1-的个数" class="headerlink" title="最大连续 1 的个数"></a><a href="https://leetcode.cn/problems/max-consecutive-ones/">最大连续 1 的个数</a></h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二进制数组 <code>nums</code> ， 计算其中最大连续 <code>1</code> 的个数。</p>
 <span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,0,1,1,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：开头的两位和最后的三位都是连续<span class="number"> 1 </span>，所以最大连续<span class="number"> 1 </span>的个数是 3.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[1,0,1,1,0,1]</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= nums.length &lt;= 105</code></p>
</li>
<li><p><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code>.</p>
</li>
</ul>
<h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>本题中存在两个技术点：连续数和最大。</p>
<p>连续数是比较好求的，只需要条件判定再加上计数器就可以做到。</p>
<p>关键在于最大，使我引入了一个缓存变量tmp，用来实时更新“最大连击数”并不会占用1太多空间。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMaxConsecutiveOnes</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; numsSize &amp;&amp; nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            tmp++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &lt; tmp) &#123;</span><br><span class="line">            count = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode0238</title>
    <url>/2023/11/22/LeetCode0238/</url>
    <content><![CDATA[<h1 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/">除自身以外数组的乘积</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p>
<p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p>
<p>请 <strong>不要使用除法，</strong>且在 <code>O(*n*)</code> 时间复杂度内完成此题。</p>
<span id="more"></span>

<p><strong>示例 1:</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1,2,3,4</span>]</span><br><span class="line">输出: [<span class="number">24,12,8,6</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: nums = <span class="comment">[-1,1,0,-3,3]</span></span><br><span class="line">输出: <span class="comment">[0,0,9,0,0]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 105</code></li>
<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>
<li><strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内</li>
</ul>
<hr>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>刚开始我想得比较简单，认为只需要把所有元素的乘积求出，再在循环里一个个除就好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">productExceptSelf</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* answer = (<span class="type">int</span>*)<span class="built_in">malloc</span>(numsSize * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (answer == <span class="literal">NULL</span>) &#123; <span class="comment">// 检查内存分配是否成功</span></span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> product = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        product *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        answer[i] = product / nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Line 16: Char 29: runtime error: division by zero [solution.c]</code>把我拉回了现实：只要有个0，这段代码全线崩盘，而且根本没有修改的余地，故舍弃此方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">productExceptSelf</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//除自身的乘积的的值 等于 左乘积 *  右乘积</span></span><br><span class="line">    <span class="type">int</span> leftPro[numsSize];</span><br><span class="line">    <span class="type">int</span> rightPro[numsSize];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左乘积</span></span><br><span class="line">    leftPro[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        leftPro[i] =  leftPro[i<span class="number">-1</span>] *  nums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//右乘积</span></span><br><span class="line">    rightPro[numsSize<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = numsSize - <span class="number">1</span> - <span class="number">1</span>; i  &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        rightPro[i] =  rightPro[i+<span class="number">1</span>] *  nums[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="type">int</span> * returnNums = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * numsSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        returnNums[i] = leftPro[i] * rightPro[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnNums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正确的思路应该像是这样，分别求出左边和右边序列的乘积加以乘法。</p>
<p>后来我在评论区看到这样一种思路：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ra[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">productExceptSelf</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        ra[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pre = <span class="number">1</span>, suf = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        pre *= nums[i - <span class="number">1</span>];</span><br><span class="line">        suf *= nums[numsSize - i];</span><br><span class="line">        ra[i] *= pre;</span><br><span class="line">        ra[numsSize - i - <span class="number">1</span>] *= suf;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">return</span> ra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：随心</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/product-of-array-except-self/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>（话说大佬都是不写注释的嘛）</p>
<p>这种算法的思路大致如下：</p>
<ul>
<li>初始化数组<code>ra</code>的前缀和和后缀和都为1。</li>
<li>遍历数组<code>nums</code>，从第二个元素开始（下标为1）。</li>
<li>对于第<code>i</code>个元素，计算前缀和（即前面所有元素的乘积）并赋值给<code>pre</code>，计算后缀和（即后面所有元素的乘积）并赋值给<code>suf</code>。</li>
<li>将前缀和和后缀和的乘积赋值给<code>ra[i]</code>，即<code>ra[i] = pre * suf</code>。</li>
<li>将数组的长度赋值给返回值<code>*returnSize</code>，并返回动态分配的数组<code>ra</code>。</li>
</ul>
<p>这种算法好处在于：</p>
<ol>
<li><p>空间利用率高：使用了一个数组<code>ra</code>来存储每个元素与其他元素乘积的结果，避免了重复计算，提高了空间利用率。</p>
</li>
<li><p>计算效率高：通过计算前缀和和后缀和，减少了乘法操作的次数，提高了计算效率。</p>
<p>(草怎么写得这么牛逼)</p>
<p>**学到了有木有 **</p>
</li>
</ol>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake入门</title>
    <url>/2024/01/12/CMake%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><h4 id="1-1Cmake是什么"><a href="#1-1Cmake是什么" class="headerlink" title="1 .1Cmake是什么"></a>1 .1Cmake是什么</h4><p>CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。可以构建、测试、打包项目。CMake 用于使用简单的平台和编译器独立配置文件来控制程序编译过程，并生成可在您选择的编译器环境中使用的主机配置文件和项目文件。对于c++工程来说，通过cmake配置，然后通过cmake工具自动生成makefile文件，最后通过make编译出二进制文件。也就是说CMake 用于使用简单的平台和编译器独立配置文件来控制程序编译过程，并生成可在您选择的编译器环境中使用的主机配置文件和项目文件。</p>
<span id="more"></span>

<h4 id="1-2-Cmake-优缺点"><a href="#1-2-Cmake-优缺点" class="headerlink" title="1.2 Cmake 优缺点"></a>1.2 Cmake 优缺点</h4><ul>
<li><p>优点</p>
</li>
<li><ul>
<li>编程式的配置</li>
<li>支持跨平台</li>
<li>支持强依赖受控管理</li>
<li>官方提供的依赖查找方式</li>
<li>支持配置分离</li>
<li>支持多种外部调用方式</li>
<li>官方提供多种系统检测接口</li>
<li>支持工具链（Toolchain）以传递配置</li>
<li>官方提供了多种工具链实现</li>
<li>自身具有版本控制及约束功能</li>
</ul>
</li>
<li><p>缺点</p>
</li>
<li><ul>
<li>文档太差。cmake的文档差是一个公认的问题，那官方文档上连一个具体实例都没有，关键点也不会明确体现出来。</li>
<li>弱变量及未定义的变量导致非预期行为。cmake是一个弱语言，其变量没有具体的类型之分。你可以使用某个变量代表一个字符串，也可以代表一个列表。而在其他部分使用此变量作为非预期的类型会导致无穷无尽的问题。当然，这是弱语言的共通问题。而在一处使用未被定义的变量更容易发生未预期的行为。</li>
<li>调试困难。cmake官方目前不支持断点调试功能。</li>
</ul>
</li>
</ul>
<h3 id="2-Cmake环境配置"><a href="#2-Cmake环境配置" class="headerlink" title="2 Cmake环境配置"></a>2 Cmake环境配置</h3><p>先安装cmake然后进行环境变量配置即可。 验证是否成功，在命令窗口执行 cmake –verson 即可。</p>
<h3 id="3-简单的Cmake工程"><a href="#3-简单的Cmake工程" class="headerlink" title="3 简单的Cmake工程"></a>3 简单的Cmake工程</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">D:/code/vscodeProject 目录下的文件列表，文档后面都会用到这个路径，后续不在说明。</span><br><span class="line">├─.vscode</span><br><span class="line">├─build</span><br><span class="line">│  ├─.cmak</span><br><span class="line">│  ├─CMakeFiles</span><br><span class="line">│  ├─main</span><br><span class="line">│  ├─src</span><br><span class="line">│  └─Testing</span><br><span class="line">├─exe</span><br><span class="line">├─include</span><br><span class="line">├─main</span><br><span class="line">├─script</span><br><span class="line">└─src</span><br></pre></td></tr></table></figure>

<p>通过cmake搭建的一个c++编译工程 链接 github: <a href="https://github.com/Persist-Forever/cmakeProc.git">https://github.com/Persist-Forever/cmakeProc.git</a></p>
<h3 id="4-基本命令"><a href="#4-基本命令" class="headerlink" title="4 基本命令"></a>4 基本命令</h3><h4 id="4-1-描述命令"><a href="#4-1-描述命令" class="headerlink" title="4.1 描述命令"></a>4.1 描述命令</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.0</span><span class="number">.0</span>)  # 指定cmake的最小版本</span><br><span class="line"><span class="built_in">project</span>(getestProc VERSION <span class="number">0.1</span><span class="number">.0</span>)      # 指定项目名称及版本号，初始化项目相关变量</span><br><span class="line"><span class="built_in">project</span>(getestProc C CXX)                # 指定项目支持的语言 C C++</span><br></pre></td></tr></table></figure>

<h4 id="4-2-关键路径"><a href="#4-2-关键路径" class="headerlink" title="4.2 关键路径"></a>4.2 关键路径</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># PROJECT_SOURCE_DIR 项目的目录 也就是 D:/code/<span class="function">vscodeProject</span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">&quot;This is SOURCE dir &quot;</span>$&#123;PROJECT_SOURCE_DIR&#125;)</span></span></span><br><span class="line"><span class="function"># PROJECT_BINARY_DIR 项目的构建目录 D:/code/vscodeProject/build</span></span><br><span class="line"><span class="function">MESSAGE(STATUS <span class="string">&quot;This is BINARY dir &quot;</span> $&#123;</span>PROJECT_BINARY_DIR&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-3-设置关键字"><a href="#4-3-设置关键字" class="headerlink" title="4.3 设置关键字"></a>4.3 设置关键字</h4><p>SET关键字用来显示指定的变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SET</span>(SRC_LIST XXX.cpp xx2.cpp xx3.cpp ...)</span><br><span class="line"># $&lt;TARGET_OBJECTS:src-dltest-object&gt; 这个设置到一个变量中是因为add_libary可以使用</span><br><span class="line"><span class="built_in">set</span>(src-dltest</span><br><span class="line">     $&lt;TARGET_OBJECTS:src-dltest-object&gt;</span><br><span class="line">     PARENT_SCOPE)</span><br></pre></td></tr></table></figure>

<h4 id="4-4-获取目录下所有源文件"><a href="#4-4-获取目录下所有源文件" class="headerlink" title="4.4 获取目录下所有源文件"></a>4.4 获取目录下所有源文件</h4><p>该函数用的比较多，注意不会递归。构建文件中经常使用到这一句。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">aux_source_directory</span>(. SRC_LIST)</span><br></pre></td></tr></table></figure>

<h4 id="4-5-信息打印-MASSAGE关键字"><a href="#4-5-信息打印-MASSAGE关键字" class="headerlink" title="4.5 信息打印 MASSAGE关键字"></a>4.5 信息打印 MASSAGE关键字</h4><p>MESSAGE关键字主要用于向终端输出用户自定义的信息，主要包含三种信息</p>
<ul>
<li>SEND_ERROR，产生错误，生成过程被跳过</li>
<li>STATUS，输出前缀为–的信息</li>
<li>FATAL_ERROR，立即终止所有cmake过程</li>
</ul>
<h4 id="4-6-add-library"><a href="#4-6-add-library" class="headerlink" title="4.6 add_library"></a>4.6 add_library</h4><ul>
<li>第一种用法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">            [EXCLUDE_FROM_ALL]</span><br><span class="line">            [&lt;source&gt;...])</span><br><span class="line"># 生成 liboptical.<span class="function">so</span></span><br><span class="line"><span class="function"><span class="title">add_library</span><span class="params">(optical share optical.cpp $&#123;SRC_LIST&#125;)</span></span></span><br></pre></td></tr></table></figure>

<p>add_library根据源码来生成一个库供他人使用。是个逻辑名称，在项目中必须唯一。完整的库名依赖于具体构建方式（可能为lib.a or .lib）。</p>
<p>STATIC指静态库，SHARED指动态库，MODULE指在运行期通过类似于dlopen的函数动态加载。</p>
<ul>
<li>第二种用法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_library</span>(&lt;name&gt; OBJECT [&lt;source&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>(... $&lt;TARGET_OBJECTS:name&gt; ...)</span><br><span class="line"><span class="built_in">add_executable</span>(... $&lt;TARGET_OBJECTS:name&gt; ...)</span><br></pre></td></tr></table></figure>

<p>生成一个obj对象，该对象库只编译源文件，但不链接。由add_library()或add_executable()创建的目标可以使用$&lt;TARGET_OBJECTS:name&gt;这样的表达式作为源引用对象，其中，name是对象库的名称。</p>
<h4 id="4-6-add-subdirectory"><a href="#4-6-add-subdirectory" class="headerlink" title="4.6 add_subdirectory"></a>4.6 add_subdirectory</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br><span class="line"># 将 optical otn目录加入到构建系统中，另外参数一般不需要使用</span><br><span class="line"><span class="built_in">add_subdirectory</span>(optical)</span><br><span class="line"><span class="built_in">add_subdirectory</span>(otn)</span><br></pre></td></tr></table></figure>

<p>将子目录添加到构建系统中。source_dir指定一个目录，其中存放CMakeLists.txt文件和代码文件。binary_dir指定的目录存放输出文件，如果没有指定则使用source_dir。</p>
<h4 id="4-7-add-executable"><a href="#4-7-add-executable" class="headerlink" title="4.7 add_executable"></a>4.7 add_executable</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 第一种：<span class="function">Normal Executables</span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(&lt;name&gt; [WIN32] [MACOSX_BUNDLE]</span></span></span><br><span class="line"><span class="params"><span class="function">               [EXCLUDE_FROM_ALL]</span></span></span><br><span class="line"><span class="params"><span class="function">               [source1] [source2 ...])</span></span></span><br><span class="line"><span class="function"># 第二种：Imported Executables</span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(&lt;name&gt; IMPORTED [GLOBAL])</span></span></span><br><span class="line"><span class="function"># 第三种：Alias Executables</span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(&lt;name&gt; ALIAS &lt;target&gt;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#第一种是项目中经常用到的，这里就用第一种举例</span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(main main.cpp $&#123;SRC_LIST&#125;)</span></span></span><br></pre></td></tr></table></figure>

<p>该关键字使用指定的源文件来生成目标可执行文件。具体分为三类：普通、导入、别名。此处我们就以普通可执行文件进行说明，其中是可执行文件的名称，在cmake工程中必须唯一。<strong>WIN32用于在windows下创建一个以WinMain为入口的可执行文件</strong>。MACOSX_BUNDLE用于mac系统或者IOS系统下创建一个GUI可执行应用程序。</p>
<h4 id="4-8-target-link-libraries"><a href="#4-8-target-link-libraries" class="headerlink" title="4.8 target_link_libraries"></a>4.8 target_link_libraries</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>(&lt;target&gt; ... &lt;item&gt;... ...)</span><br></pre></td></tr></table></figure>

<p>指定链接给定目标和&#x2F;或其依赖项时要使用的库。命名的必须是由add_executable()或add_library()之类的命令创建的。一般与 link_directories连用（添加外部库的搜索路径 ）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 第一种方式 一般引入第三方库用这种</span><br><span class="line"><span class="built_in">add_library</span>(hello hello.cpp)        # 生成对象库文件</span><br><span class="line"><span class="built_in">add_executable</span>(Demo main.cpp)       # 生成可执行文件</span><br><span class="line"><span class="built_in">target_link_libraries</span>(Demo hello)   # 链接对象库</span><br><span class="line"></span><br><span class="line"># 第二种方式  本项目的研发代码链路</span><br><span class="line"><span class="built_in">add_library</span>(hello OBJECT hello.cpp)  # 生成对象库文件，不链接</span><br><span class="line"><span class="built_in">add_executable</span>(Demo main.cpp $&lt;TARGET_OBJECTS:hello&gt;)</span><br><span class="line"></span><br><span class="line"># 第三种 完全没必要多次一举罗</span><br><span class="line"><span class="built_in">add_library</span>(hello OBJECT hello.cpp)</span><br><span class="line"><span class="built_in">add_executable</span>(Demo main.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(Demo hello)</span><br></pre></td></tr></table></figure>

<h4 id="4-9-include"><a href="#4-9-include" class="headerlink" title="4.9 include"></a>4.9 include</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">include</span>(&lt;file|<span class="keyword">module</span>&gt; [OPTIONAL] [RESULT_VARIABLE &lt;VAR&gt;]</span><br><span class="line">                      [NO_POLICY_SCOPE])</span><br><span class="line"># 导入device_cfg.cmake文件 其他参数很少用</span><br><span class="line"><span class="built_in">include</span>(device_cfg.cmake)</span><br></pre></td></tr></table></figure>

<p>从指定的文件加载、运行CMake代码。如果指定文件，则直接处理。如果指定module，则寻找module.cmake文件，首先在${CMAKE_MODULE_PATH}中寻找，然后在CMake的module目录中查找。</p>
<h4 id="4-10-target-include-directories"><a href="#4-10-target-include-directories" class="headerlink" title="4.10 target_include_directories"></a>4.10 target_include_directories</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">target_include_directories</span>(&lt;target&gt; [SYSTEM] [AFTER|BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br><span class="line">  </span><br><span class="line"># 生成对象库文件</span><br><span class="line"><span class="built_in">add_library</span>(hello OBJECT hello.cpp) </span><br><span class="line"># 添加头文件目录</span><br><span class="line"><span class="built_in">target_include_directories</span>(hello PUBLIC $&#123;CMAKE_SOURCE_DIR&#125;/<span class="keyword">public</span>)</span><br></pre></td></tr></table></figure>

<p>在编译目标文件时指定头文件。必须是通过add_executable()或add_library()创建，且不能是ALIAS目标。&lt;INTERFACE|PUBLIC|PRIVATE&gt;修饰其紧跟参数items的作用范围。</p>
<h4 id="4-11-link-directories"><a href="#4-11-link-directories" class="headerlink" title="4.11 link_directories"></a>4.11 link_directories</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">link_directories</span>([AFTER|BEFORE] directory1 [directory2 ...])</span><br></pre></td></tr></table></figure>

<p>LINK_DIRECTORIES 命令来指定第三方库所在路径，比如，你的动态库在&#x2F;home&#x2F;myproject&#x2F;libs这个路径下，则通过命令：LINK_DIRECTORIES(&#x2F;home&#x2F;myproject&#x2F;libs)，把该路径添加到第三方库搜索路径中，这样就可以使用相对路径了，使用TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。**官方不建议使用该命令，取而代之的为find_package() find_library()**。</p>
<h4 id="4-12-find-package"><a href="#4-12-find-package" class="headerlink" title="4.12 find_package()"></a>4.12 find_package()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">## 共支持两种模式</span><br><span class="line"># mode1: Module, 此模式需访问Find&lt;PackageName&gt;.cmake文件</span><br><span class="line"><span class="built_in">find_package</span>(&lt;PackageName&gt; [version] [EXACT] [QUIET] [MODULE]</span><br><span class="line">             [REQUIRED] [[COMPONENTS] [components...]]</span><br><span class="line">             [OPTIONAL_COMPONENTS components...]</span><br><span class="line">             [NO_POLICY_SCOPE])</span><br><span class="line"><span class="built_in">find_package</span>(uts MODULE) #去找 Finduts.cmake  注意指定路径</span><br><span class="line"></span><br><span class="line"># mode2: Config, 此模式需访问&lt;lowercasePackageName&gt;-config.cmake <span class="keyword">or</span> &lt;PackageName&gt;Config.<span class="function">cmake</span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(&lt;PackageName&gt; [version] [EXACT] [QUIET]</span></span></span><br><span class="line"><span class="params"><span class="function">             [REQUIRED] [[COMPONENTS] [components...]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [OPTIONAL_COMPONENTS components...]</span></span></span><br><span class="line"><span class="params"><span class="function">             [CONFIG|NO_MODULE]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_POLICY_SCOPE]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NAMES name1 [name2 ...]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [CONFIGS config1 [config2 ...]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [HINTS path1 [path2 ... ]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [PATHS path1 [path2 ... ]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [PATH_SUFFIXES suffix1 [suffix2 ...]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_DEFAULT_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_PACKAGE_ROOT_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_ENVIRONMENT_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_SYSTEM_ENVIRONMENT_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_PACKAGE_REGISTRY]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_BUILDS_PATH] # Deprecated; does nothing.</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_SYSTEM_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY]</span></span></span><br><span class="line"><span class="params"><span class="function">             [CMAKE_FIND_ROOT_PATH_BOTH |</span></span></span><br><span class="line"><span class="params"><span class="function">              ONLY_CMAKE_FIND_ROOT_PATH |</span></span></span><br><span class="line"><span class="params"><span class="function">              NO_CMAKE_FIND_ROOT_PATH])</span></span></span><br></pre></td></tr></table></figure>

<p>find_package一般用于加载外部库到项目中，并且会加载库的细节信息。如上find_package有两种模式：Module与Config。</p>
<p>该命令描述特别复杂，参考博客： <a href="https://blog.csdn.net/fengbingchun/article/details/127473202">(41条消息) CMake中find_package的使用_fengbingchun的博客-CSDN博客</a></p>
<h4 id="4-13-find-libary"><a href="#4-13-find-libary" class="headerlink" title="4.13 find_libary()"></a>4.13 find_libary()</h4><p>该函数用于库查找</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find_library</span>(</span><br><span class="line">          &lt;VAR&gt;</span><br><span class="line">          name | NAMES name1 [name2 ...] [NAMES_PER_DIR]</span><br><span class="line">          [HINTS [path | ENV var]... ]</span><br><span class="line">          [PATHS [path | ENV var]... ]</span><br><span class="line">          [<span class="built_in">REGISTRY_VIEW</span> (<span class="number">64</span>|<span class="number">32</span>|<span class="number">64</span>_32|<span class="number">32</span>_64|HOST|TARGET|BOTH)]</span><br><span class="line">          [PATH_SUFFIXES suffix1 [suffix2 ...]]</span><br><span class="line">          [DOC <span class="string">&quot;cache documentation string&quot;</span>]</span><br><span class="line">          [NO_CACHE]</span><br><span class="line">          [REQUIRED]</span><br><span class="line">          [NO_DEFAULT_PATH]</span><br><span class="line">          [NO_PACKAGE_ROOT_PATH]</span><br><span class="line">          [NO_CMAKE_PATH]</span><br><span class="line">          [NO_CMAKE_ENVIRONMENT_PATH]</span><br><span class="line">          [NO_SYSTEM_ENVIRONMENT_PATH]</span><br><span class="line">          [NO_CMAKE_SYSTEM_PATH]</span><br><span class="line">          [NO_CMAKE_INSTALL_PREFIX]</span><br><span class="line">          [CMAKE_FIND_ROOT_PATH_BOTH |</span><br><span class="line">           ONLY_CMAKE_FIND_ROOT_PATH |</span><br><span class="line">           NO_CMAKE_FIND_ROOT_PATH]</span><br><span class="line">)</span><br><span class="line"># 在默认路径下查找/usr/lib/...  libJSON-C.<span class="function">so</span></span><br><span class="line"><span class="function"><span class="title">find_libary</span><span class="params">(json NAMES JSON-C)</span></span></span><br></pre></td></tr></table></figure>

<p>详细介绍见参考博客： <a href="https://blog.csdn.net/fengbingchun/article/details/127232175">(41条消息) CMake中find_library的使用_fengbingchun的博客-CSDN博客</a></p>
<h3 id="5-场景实战"><a href="#5-场景实战" class="headerlink" title="5 场景实战"></a>5 场景实战</h3><p>该章节的是为了更好的将cmake应用在构建工程中，分不同场景来练习和实战，将多条cmake命令组合起来完成各种场景的需求。这样才能更好的使用cmake.一些场景后续根据实际需求补上。</p>
<h4 id="5-1-一个目录一个object"><a href="#5-1-一个目录一个object" class="headerlink" title="5.1 一个目录一个object"></a>5.1 一个目录一个object</h4><p>将一个目录下的源文件通过一个makelist.txt文件编译成一个 object，这样有利于代码结构化管理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="built_in">add_library</span>(src-dltest-object OBJECT $(SRC_LIST))</span><br><span class="line"><span class="built_in">set</span>(src-dltest</span><br><span class="line">     $&lt;TARGET_OBJECTS:src-dltest-object&gt;</span><br><span class="line">     PARENT_SCOPE)</span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/lib/)</span><br><span class="line"><span class="built_in">set</span>(src</span><br><span class="line">    $&#123;src-dltest&#125;</span><br><span class="line">    PARENT_SCOPE)</span><br></pre></td></tr></table></figure>

<h4 id="5-2-编译链-toolchain"><a href="#5-2-编译链-toolchain" class="headerlink" title="5.2 编译链 toolchain"></a>5.2 编译链 toolchain</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># -Dxxx指定编译参数  cmake和makelist里面可以用变量 LLT  CPU_BIT_FLAG 等</span><br><span class="line">cmake .. -DCOMPILER=<span class="string">&quot;$&#123;platform&#125;&quot;</span> -DMODULE=<span class="string">&quot;$&#123;module&#125;&quot;</span> -DLLT=<span class="string">&quot;true&quot;</span> -DCPU_BIT_FLAG=<span class="string">&quot;FLAG_64&quot;</span> </span><br><span class="line">-DCMAKE_TOOLCHAIN_FILE=<span class="string">&quot;$&#123;root_path&#125;&quot;</span>/cmake/toolchain/<span class="string">&quot;$&#123;platform&#125;&quot;</span>_toolchain.cmake</span><br><span class="line">#  编译链cmake 主要设置编译选项等 x86_toolchain.cmake</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_FLAGS <span class="string">&quot; -Wall -Werror -Wfloat-equal -Wshadow XXX&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot; -g -m64 -std=c++17 -Wall -Werror -Wfloat-equal -Wshadow XXX&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="5-3-第三方库引入"><a href="#5-3-第三方库引入" class="headerlink" title="5.3 第三方库引入"></a>5.3 第三方库引入</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 方式一 制定绝对路径</span><br><span class="line"><span class="built_in">set</span>(xxx_path xxxx)</span><br><span class="line"><span class="built_in">set</span>(xxx_lib_path $&#123;xxx_path&#125;/lib)</span><br><span class="line"><span class="built_in">set</span>(xxx_include_path $&#123;xxx_path&#125;/include)</span><br><span class="line"></span><br><span class="line"># 方式二 <span class="function">find_package  find_path  find_library</span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(thirdParty REQUIRED)</span></span></span><br><span class="line"><span class="function"># 自动寻找 FindthirdParty.cmake, 路径会根据find_package的规则寻找</span></span><br><span class="line"><span class="function">- thirdParty</span></span><br><span class="line"><span class="function">	- party</span></span><br><span class="line"><span class="function"><span class="title">get_filename_component</span><span class="params">(THIRDPARTY_ROOT  <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/xxx/thirdParty&quot;</span> ABSOLUTE)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">find_path</span><span class="params">(THIRDPARTY_INCLUDE_PATH  party</span></span></span><br><span class="line"><span class="params"><span class="function">    HINTS         $&#123;THIRDPARTY_ROOT&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    PATH_SUFFIXES  include)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package_handle_standard_args</span><span class="params">(thirdParty REQUIRED_VARS THIRDPARTY_INCLUDE_PATH)</span></span></span><br><span class="line"><span class="function"><span class="title">find_path</span><span class="params">(THIRDPARTY_LIB_PATH  libdrv_thirdParty.so</span></span></span><br><span class="line"><span class="params"><span class="function">    HINTS         $&#123;THIRDPARTY_ROOT&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    PATH_SUFFIXES lib)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package_handle_standard_args</span><span class="params">(thirdParty REQUIRED_VARS THIRDPARTY_LIB_PATH)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p>本文通过六个章节对cmake做了一定的介绍，其中第一章节属于cmake是用来干啥的和优缺点做了说明，第二三章节简要说明了cmake环境配置和一个简单的cmake工程github上可下载。第四章节是一些常用命令的介绍和学习。第五章节是一些场景实战，目前场景比较少，后续根据实际慢慢补上。第六章节是对整篇文章做个总结。</p>
<p>总体来说，cmake是一们比较容易的语言，系统&#x2F;项目构建中用的比较多，对于程序员来说都应该对构建有一定的了解和实战经验。也许我们会觉得ide使用起来比较方便，但ide只适合实际学习语言的时候使用。真正开发的构建工程大部分使用cmake来搭建的。</p>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>Cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode0498</title>
    <url>/2023/11/23/LeetCode0498/</url>
    <content><![CDATA[<h1 id="对角线遍历"><a href="#对角线遍历" class="headerlink" title="对角线遍历"></a><a href="https://leetcode.cn/problems/diagonal-traverse/">对角线遍历</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个大小为 <code>m x n</code> 的矩阵 <code>mat</code> ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：mat = <span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[4,5,6]</span>,<span class="comment">[7,8,9]</span>]</span></span><br><span class="line">输出：<span class="comment">[1,2,4,7,5,3,6,8,9]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：mat = <span class="string">[[1,2],[3,4]]</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 104</code></li>
<li><code>1 &lt;= m * n &lt;= 104</code></li>
<li><code>-105 &lt;= mat[i][j] &lt;= 105</code></li>
</ul>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>根据题目要求，矩阵按照对角线进行遍历。设矩阵的行数为 m, 矩阵的列数为 n, 我们仔细观察对角线遍历的规律可以得到如下信息:</p>
<img src="C:\Users\祖全之\AppData\Roaming\Typora\typora-user-images\image-20231123183323953.png" alt="image-20231123183323953" style="zoom:80%;" />

<p><strong>根据以上观察得出的结论，我们直接模拟遍历所有的对角线即可。</strong></p>
<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">findDiagonalOrder</span><span class="params">(<span class="type">int</span>** mat, <span class="type">int</span> matSize, <span class="type">int</span>* matnSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = matSize;</span><br><span class="line">    <span class="type">int</span> n = matnSize[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * m * n);</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历矩阵的所有对角线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m + n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果对角线序号为奇数</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x = i &lt; n ? <span class="number">0</span> : i - n + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> y = i &lt; n ? i : n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历当前对角线并将元素存入结果数组</span></span><br><span class="line">            <span class="keyword">while</span> (x &lt; m &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                res[pos] = mat[x][y];</span><br><span class="line">                pos++;</span><br><span class="line">                x++;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 如果对角线序号为偶数</span></span><br><span class="line">            <span class="type">int</span> x = i &lt; m ? i : m - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> y = i &lt; m ? <span class="number">0</span> : i - m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历当前对角线并将元素存入结果数组</span></span><br><span class="line">            <span class="keyword">while</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                res[pos] = mat[x][y];</span><br><span class="line">                pos++;</span><br><span class="line">                x--;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置返回的数组大小</span></span><br><span class="line">    *returnSize = m * n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>一看就会一做就废系列</em></p>
<p>大体上把情况分为两种：奇数和偶数对角线——这两种对角线也代表着不同的遍历顺序（从下到上or从上到下）</p>
<p>一边遍历一边把得到元素存到res数组里，得到新数组，及完成任务。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode0724</title>
    <url>/2023/11/20/LeetCode0724/</url>
    <content><![CDATA[<h1 id="寻找数组的中心下标"><a href="#寻找数组的中心下标" class="headerlink" title="寻找数组的中心下标"></a><a href="https://leetcode.cn/problems/find-pivot-index/">寻找数组的中心下标</a></h1><hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。</p>
<p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>
<p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">中心下标是<span class="number"> 3 </span>。</span><br><span class="line">左侧数之和 sum = nums[0] + nums[1] + nums[2] =<span class="number"> 1 </span>+<span class="number"> 7 </span>+<span class="number"> 3 </span>=<span class="number"> 11 </span>，</span><br><span class="line">右侧数之和 sum = nums[4] + nums[5] =<span class="number"> 5 </span>+<span class="number"> 6 </span>=<span class="number"> 11 </span>，二者相等。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1, 2, 3]</span></span><br><span class="line"><span class="string">输出：-1</span></span><br><span class="line"><span class="string">解释：</span></span><br><span class="line"><span class="string">数组中不存在满足此条件的中心下标。</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [2, 1, -1]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">中心下标是<span class="number"> 0 </span>。</span><br><span class="line">左侧数之和 sum =<span class="number"> 0 </span>，（下标<span class="number"> 0 </span>左侧不存在元素），</span><br><span class="line">右侧数之和 sum = nums[1] + nums[2] =<span class="number"> 1 </span>+ -1 =<span class="number"> 0 </span>。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>刚开始没什么具体思路，非常脑残地一点点计算出SUM(左右)，代码如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum_left = <span class="number">0</span>, sum_right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                sum_left += nums[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> p = i + <span class="number">1</span>; p &lt; numsSize; p++)</span><br><span class="line">                sum_right += nums[p];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum_left == sum_right)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重置 sum_left 和 sum_right</span></span><br><span class="line">            sum_left = <span class="number">0</span>;</span><br><span class="line">            sum_right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中间那个重置千万别忘掉</strong></p>
<ul>
<li><p>在GPT的帮助下，我把代码重构了一下，主要是针对右侧sum的计算逻辑修改</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum_left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum_right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        sum_right = sum - sum_left - nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum_left == sum_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum_left += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个逻辑中无需先预判[0]元素是否可以直接PASS（其实前一个也不用，写麻烦了），并且用全数列的sum-左sum-当前元素，少了一丢丢运算过程，更加简洁明了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode189</title>
    <url>/2023/11/19/LeetCode189/</url>
    <content><![CDATA[<h1 id="加一"><a href="#加一" class="headerlink" title="加一"></a><a href="https://leetcode.cn/problems/plus-one/">加一</a></h1><hr>
<p><strong>题目：</strong></p>
<p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<span id="more"></span>

<p><strong>示例 1:</strong></p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">输入</span><span class="punctuation">:</span> <span class="string">nums = [1,2,3,4,5,6,7], k = 3</span></span><br><span class="line"><span class="attribute">输出</span><span class="punctuation">:</span> <span class="string">[5,6,7,1,2,3,4]</span></span><br><span class="line"><span class="attribute">解释</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">向右轮转 1 步</span><span class="punctuation">:</span> <span class="string">[7,1,2,3,4,5,6]</span></span><br><span class="line"><span class="attribute">向右轮转 2 步</span><span class="punctuation">:</span> <span class="string">[6,7,1,2,3,4,5]</span></span><br><span class="line"><span class="attribute">向右轮转 3 步</span><span class="punctuation">:</span> <span class="string">[5,6,7,1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="string">-1</span>,<span class="string">-100</span>,3,99], k = 2</span><br><span class="line">输出：[3,99,<span class="string">-1</span>,<span class="string">-100</span>]</span><br><span class="line">解释: </span><br><span class="line">向右轮转 1 步: [99,<span class="string">-1</span>,<span class="string">-100</span>,3]</span><br><span class="line">向右轮转 2 步: [3,99,<span class="string">-1</span>,<span class="string">-100</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= k &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</li>
<li>你可以使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法解决这个问题吗？</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k %= numsSize; <span class="comment">// 处理 k 大于数组大小的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = numsSize; <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="type">int</span> begin = <span class="number">0</span>; <span class="comment">// 循环开始的下标</span></span><br><span class="line">    <span class="type">int</span> tmp = nums[begin]; <span class="comment">// 循环开始的值</span></span><br><span class="line">    <span class="type">int</span> len = begin; <span class="comment">// 在循环中的当前下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环执行</span></span><br><span class="line">    <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> before = (len - k + numsSize) % numsSize; <span class="comment">// 计算下一个位置</span></span><br><span class="line"></span><br><span class="line">        nums[len] = nums[before]; <span class="comment">// 将上一个值移动到当前值</span></span><br><span class="line">        len = before;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果循环结束，将开始的值赋给结尾的值，进入下一个循环</span></span><br><span class="line">        <span class="keyword">if</span> (before == begin) &#123;</span><br><span class="line">            nums[len] = tmp;</span><br><span class="line">            begin = (begin + <span class="number">1</span>) % numsSize;</span><br><span class="line">            tmp = nums[begin];</span><br><span class="line">            len = begin;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><ol>
<li>对 <code>k</code> 取余，处理 <code>k</code> 大于数组大小的情况，避免不必要的循环。</li>
<li>使用变量 <code>begin</code> 记录当前循环的开始下标，<code>len</code> 记录在循环中的当前下标。</li>
<li>循环执行，每次计算下一个位置 <code>before</code>，将上一个值移动到当前值。</li>
<li>如果循环结束，将开始的值赋给结尾的值，进入下一个循环。</li>
</ol>
<p>这样，通过不断地将值从上一个位置移动到当前位置，实现数组的循环右移。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode0203</title>
    <url>/2023/11/30/Leetcode0203/</url>
    <content><![CDATA[<h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">移除链表元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,6,3,4,5,6]</span>, val = <span class="number">6</span></span><br><span class="line">输出：<span class="string">[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span>, val = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[7,7,7,7]</span>, val = 7</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li>
<li><code>1 &lt;= Node.val &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 50</code></li>
</ul>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>刚开始思路非常简单：检测到下一个节点是val，删除该节点。写出了下面这段蠢到家的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span>=</span>head;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next==val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>仔细一看题：发现“<strong>新的头节点</strong>”还特意加粗了，看起来如果第一个节点就是空节点程序会直接寄掉。</p>
<ol>
<li><code>cur-&gt;next = cur-&gt;next-&gt;next;</code> 表示删除当前节点的下一个节点。这会导致无法处理连续相同值的节点。正确的做法是将当前节点的 <code>next</code> 指针直接指向下下个节点，而不是跳过一个节点。</li>
<li>函数的返回值是链表的头指针 <code>head</code>，但是在删除节点的过程中，链表头部可能发生变化。因此，应该在删除节点后返回新的头指针。</li>
</ol>
<p>修改为以下程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    dummy-&gt;next = head;<span class="comment">//在头节点前创建一个空节点，用于解决其为val的情况</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> dummy;<span class="comment">//基操用cur遍历</span></span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next-&gt;val==val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> dummy-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(dummy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newHead;<span class="comment">//返回新的头节点，并释放dummy的空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode66</title>
    <url>/2023/11/19/LeetCode66/</url>
    <content><![CDATA[<h1 id="加一"><a href="#加一" class="headerlink" title="加一"></a><a href="https://leetcode.cn/problems/plus-one/">加一</a></h1><hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：digits = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：<span class="comment">[1,2,4]</span></span><br><span class="line">解释：输入数组表示数字 123。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：digits = [<span class="number">4,3,2,1</span>]</span><br><span class="line">输出：[<span class="number">4,3,2,2</span>]</span><br><span class="line">解释：输入数组表示数字 <span class="number">4321</span>。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：digits = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= digits.length &lt;= 100</code></li>
<li><code>0 &lt;= digits[i] &lt;= 9</code></li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">plusOne</span><span class="params">(<span class="type">int</span>* digits, <span class="type">int</span> digitsSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 从数组的最后一位开始向前加一</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = digitsSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits[i] &lt; <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前位加一不产生进位，直接返回数组</span></span><br><span class="line">            digits[i]++;</span><br><span class="line">            *returnSize = digitsSize;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前位加一产生进位，将当前位设为0，继续向前一位加一</span></span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 如果遍历完成后，最高位仍然产生进位，需要在数组最前面添加一个新的元素1</span></span><br><span class="line">	<span class="type">int</span>* result = (<span class="type">int</span>*)<span class="built_in">malloc</span>((digitsSize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= digitsSize; i++) &#123;</span><br><span class="line">    	result[i] = digits[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	*returnSize = digitsSize + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>s</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode0206</title>
    <url>/2023/11/30/Leetcode0206/</url>
    <content><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span></span><br><span class="line">输出：<span class="string">[5,4,3,2,1]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2]</span></span><br><span class="line">输出：<span class="comment">[2,1]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>基本想法是把列表的首尾节点调换，即每一个指针都指向前一个节点。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span><span class="literal">NULL</span>;<span class="comment">//创建一个空头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span>=</span>head;<span class="comment">//创建curr用于遍历链表</span></span><br><span class="line">    <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span>curr-&gt;next;</span><br><span class="line">        curr-&gt;next =prev;</span><br><span class="line">        prev =curr;<span class="comment">//把pre遍历到当前节点</span></span><br><span class="line">        curr=next;<span class="comment">//把当前指针遍历到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode83</title>
    <url>/2023/11/30/Leetcode83/</url>
    <content><![CDATA[<h1 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,1,2]</span></span><br><span class="line">输出：<span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,1,2,3,3]</span></span><br><span class="line">输出：<span class="comment">[1,2,3]</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li>题目数据保证链表已经按升序 <strong>排列</strong></li>
</ul>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>根据题干描述，链表已经按照升序排列，即只需要判断前后两个节点是否相等从而确定删除与否即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;<span class="comment">//即链表为空，没有重复元素可以删除。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next) &#123;<span class="comment">//条件是当前节点的下一个节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode0234</title>
    <url>/2023/11/30/Leetcode0234/</url>
    <content><![CDATA[<h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
 <span id="more"></span>

<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2,2,1]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围<code>[1, 105]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><h3 id="法一：复制到数组"><a href="#法一：复制到数组" class="headerlink" title="法一：复制到数组"></a>法一：复制到数组</h3><p>小生不才，链表使用不够熟练，先用复制链表到数组的笨方法做出来一遍。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算链表长度</span></span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配数组</span></span><br><span class="line">    <span class="type">int</span>* a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(count * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!a) &#123;</span><br><span class="line">        <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新遍历链表，将值存入数组</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        a[i] = cur-&gt;val;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为回文</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != a[count - <span class="number">1</span> - i]) &#123;</span><br><span class="line">            <span class="built_in">free</span>(a);  <span class="comment">// 释放动态分配的数组内存</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(a);  <span class="comment">// 释放动态分配的数组内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="法二：快慢指针"><a href="#法二：快慢指针" class="headerlink" title="法二：快慢指针"></a>法二：快慢指针</h3><p>这也是我想到的第二个方法。</p>
<p>整个流程可以分为以下五个步骤：</p>
<ol>
<li><p>找到前半部分链表的尾节点。</p>
</li>
<li><p>反转后半部分链表。</p>
</li>
<li><p>判断是否回文。</p>
</li>
<li><p>恢复链表。</p>
</li>
<li><p>返回结果。</p>
<p>执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。</p>
<p>我们也可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</p>
<p>若链表有奇数个节点，则中间的节点应该看作是前半部分。</p>
<p>步骤二可以使用[反转链表](<a href="http://zuweicun.top/2023/11/30/Leetcode0206/#more">Leetcode0206 | 全之の博客 (zuweicun.top)</a>)问题中的解决方法来反转链表的后半部分。</p>
<p>步骤三比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p>
<p>步骤四与步骤二使用的函数相同，再反转一次恢复链表本身。</p>
<p>其代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;<span class="comment">//创建空节点用于存放“前一个”数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span> =</span> head;<span class="comment">//基操curr遍历</span></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">nextTemp</span> =</span> curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;<span class="comment">//反转函数</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">endOfFirstHalf</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> head;<span class="comment">//块指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head;<span class="comment">//慢指针</span></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;<span class="comment">//一次走两步</span></span><br><span class="line">        slow = slow-&gt;next;<span class="comment">//一次走一步</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;<span class="comment">//由于快慢指针的数量关系，slow返回的应该是链表半节点处</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;<span class="comment">//最终的bool类型判断函数</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">firstHalfEnd</span> =</span> endOfFirstHalf(head);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">secondHalfStart</span> =</span> reverseList(firstHalfEnd-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否回文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p1</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p2</span> =</span> secondHalfStart;</span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">    firstHalfEnd-&gt;next = reverseList(secondHalfStart);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="法三：递归"><a href="#法三：递归" class="headerlink" title="法三：递归"></a>法三：递归</h3><p><em>这个递归来源于Leetcode官方题解，其风骚是我至今所遇最强。</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，用于存储前半部分链表的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">frontPointer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归检查是否回文</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">recursivelyCheck</span><span class="params">(<span class="keyword">struct</span> ListNode* currentNode)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前节点不为空时进行递归检查</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归检查下一个节点，如果返回 false，则整体返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (!recursivelyCheck(currentNode-&gt;next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查当前节点的值是否与前半部分链表的节点值相等</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode-&gt;val != frontPointer-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前半部分链表指针移动到下一个节点</span></span><br><span class="line">        frontPointer = frontPointer-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若所有节点都检查完毕，返回 true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查链表是否为回文</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化全局变量 frontPointer</span></span><br><span class="line">    frontPointer = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用递归检查函数</span></span><br><span class="line">    <span class="keyword">return</span> recursivelyCheck(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><code>isPalindrome</code> 函数设置 <code>frontPointer</code> 为链表头，并调用 <code>recursivelyCheck</code> 函数。</li>
<li><code>recursivelyCheck</code> 函数首先检查当前节点是否为 <code>NULL</code>，如果是，则返回 <code>true</code>，因为链表的末尾已经达到。</li>
<li>然后，<code>recursivelyCheck</code> 递归调用自己，传递当前节点的下一个节点。</li>
<li>在递归返回之前，检查当前节点的值是否等于 <code>frontPointer</code> 指向的节点的值。如果不等，则返回 <code>false</code>，因为链表不是回文的。</li>
<li>如果值相等，将 <code>frontPointer</code> 移动到下一个节点。</li>
<li>最终，如果整个链表都被成功检查，并且没有发现值不相等的情况，那么整个函数返回 <code>true</code>，表示链表是回文的。</li>
</ol>
<p>这种方法的核心思想是使用递归从链表的末尾开始比较节点的值，同时使用 <code>frontPointer</code> 从链表的头部开始。这两个指针相向移动，逐一比较节点的值，如果在整个过程中没有找到不相等的节点，则链表被认为是回文的。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV学习</title>
    <url>/2024/01/12/OpenCV%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>经过长达一天的重装和环境配置，正式开始OpenCV的学习。</p>
<span id="more"></span>

<h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h5><p><a href="https://blog.csdn.net/Star_ID/article/details/122656593">OpenCV入门【C++版】_opencv c++入门-CSDN博客</a></p>
<p><a href="https://oldpan.me/archives/use-vscode-cmake-tools-build-project">利用VScode和cmake编译构建C++工程代码 - Oldpan的个人博客</a></p>
<p><a href="https://blog.csdn.net/qq_41921826/article/details/129145473">OpenCV - C++实战（05） — 颜色检测_c++图像色素带识别-CSDN博客</a></p>
<h2 id="基本-（图片-视频）操作"><a href="#基本-（图片-视频）操作" class="headerlink" title="基本 （图片&amp;视频）操作"></a>基本 （图片&amp;视频）操作</h2><p>首先在opencv中创建一个文件夹mytest，用于存放后续的测试程序,并创建程序test1（后续同理）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mkdir mytest</span><br><span class="line">cd mytest</span><br><span class="line">gedit test1.cpp</span><br></pre></td></tr></table></figure>

<p>找一张图片（好友丑照）命名为1.jpg存放于这个目录中用于后续测试（蹂躏）。</p>
<h3 id="1-图片腐蚀"><a href="#1-图片腐蚀" class="headerlink" title="1 图片腐蚀"></a>1 图片腐蚀</h3><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage =<span class="built_in">imread</span>(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[原始图]&quot;</span>,srcImage);</span><br><span class="line">    Mat element =<span class="built_in">getStructuringElement</span>(MORPH_RECT,<span class="built_in">Size</span>(<span class="number">15</span>,<span class="number">15</span>));</span><br><span class="line">    Mat dstImage;</span><br><span class="line">    <span class="built_in">erode</span>(srcImage,dstImage,element);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[效果图]腐蚀操作&quot;</span>,dstImage);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能很简单，就是一个腐蚀操作。</p>
<p>在终端输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ test1.cpp -o test1 `pkg-config --cflags --libs opencv`</span><br><span class="line">./test1</span><br></pre></td></tr></table></figure>

<p>显示原图和腐蚀操作图。</p>
<p>效果展示：</p>
<p><img src="/2024/01/12/OpenCV%E5%AD%A6%E4%B9%A0/1.png" alt="1"></p>
<p>完美运行。</p>
<h3 id="2-图像模糊"><a href="#2-图像模糊" class="headerlink" title="2.图像模糊"></a>2.图像模糊</h3><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage =<span class="built_in">imread</span>(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[原始图]&quot;</span>,srcImage);</span><br><span class="line">    Mat dstImage;</span><br><span class="line">    <span class="built_in">blur</span>(srcImage,dstImage,<span class="built_in">Size</span>(<span class="number">7</span>,<span class="number">7</span>));</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[效果图]&quot;</span>,dstImage);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常好理解，载入原图之后调用一次blur函数，最后显示效果图。</p>
<p>效果如下：</p>
<p><img src="/2024/01/12/OpenCV%E5%AD%A6%E4%B9%A0/2.png" alt="2"></p>
<h3 id="3-Canny边缘检测"><a href="#3-Canny边缘检测" class="headerlink" title="3  Canny边缘检测"></a>3  Canny边缘检测</h3><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage =<span class="built_in">imread</span>(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[原始图]&quot;</span>,srcImage);</span><br><span class="line">    Mat dstImage,edge,grayImage;<span class="comment">//参数定义</span></span><br><span class="line">    dstImage.<span class="built_in">create</span>(srcImage.<span class="built_in">size</span>(),srcImage.<span class="built_in">type</span>());</span><br><span class="line">    <span class="comment">//创建与src同类型大小的矩阵（dest）</span></span><br><span class="line">    <span class="built_in">cvtColor</span>(srcImage,grayImage,COLOR_BGR2GRAY);</span><br><span class="line">    <span class="comment">//将原图像转换为灰度图像</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">blur</span>(grayImage,edge,<span class="built_in">Size</span>(<span class="number">3</span>,<span class="number">3</span>));<span class="comment">//3x3内核降噪</span></span><br><span class="line">    <span class="built_in">Canny</span>(edge,edge,<span class="number">3</span>,<span class="number">9</span>,<span class="number">3</span>);<span class="comment">//运行Canny算子</span></span><br><span class="line">    dstImage = edge; <span class="comment">//将Canny算子的结果赋值给dstImage</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[效果图]&quot;</span>,dstImage);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">destroyAllWindows</span>(); <span class="comment">//释放所有窗口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/2024/01/12/OpenCV%E5%AD%A6%E4%B9%A0/3.png" alt="3"></p>
<h3 id="4-读取视频"><a href="#4-读取视频" class="headerlink" title="4.读取视频"></a>4.读取视频</h3><h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="string">&quot;1.avi&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Mat frame;<span class="comment">//定义Mat变量储存每一帧</span></span><br><span class="line">        capture&gt;&gt;frame;<span class="comment">//读取当前帧</span></span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;读取视频&quot;</span>,frame);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">30</span>);<span class="comment">//延迟30ms</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-调取摄像头采集视频"><a href="#5-调取摄像头采集视频" class="headerlink" title="5.调取摄像头采集视频"></a>5.调取摄像头采集视频</h3><h4 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    Mat edges;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Mat frame;</span><br><span class="line">        capture&gt;&gt;frame;<span class="comment">//读取当前帧</span></span><br><span class="line">        <span class="built_in">cvtColor</span>(frame,edges,COLOR_BGR2GRAY);<span class="comment">//灰度转换</span></span><br><span class="line">        <span class="built_in">blur</span>(edges,edges,<span class="built_in">Size</span>(<span class="number">7</span>,<span class="number">7</span>));</span><br><span class="line">        <span class="built_in">Canny</span>(edges,edges,<span class="number">1</span>,<span class="number">31</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;读取视频&quot;</span>,frame);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（其实就是把Videocapture中的视频源改为参数0）</p>
<h3 id="6-灰度转化"><a href="#6-灰度转化" class="headerlink" title="6.灰度转化"></a>6.灰度转化</h3><p>图片有多种色彩模式，主要就是包括位图模式，灰度模式，RGB模式，CMYK模式和HSB模式。这里就不详细展开了。值得注意的有两个概念，就是图片的深度和通道，深度表示一个图片的一个像素有几位，通道则表示一个图像由几层颜色表示，一般由单通道（灰度），三通道（RGB）以及四通道（RGB+透明度）表示。</p>
<p>在opencv中我们一般采用cvtColor这个函数来转换图像的灰度。</p>
<p><img src="/2024/01/12/OpenCV%E5%AD%A6%E4%B9%A0/4.png" alt="4"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C++: <span class="function"><span class="type">void</span> <span class="title">cvtColor</span><span class="params">(InputArray src, OutputArray dst, <span class="type">int</span> code, <span class="type">int</span> dstCn=<span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里给出函数的定义和常用的几个转换标识</p>
<h2 id="图像裁剪和缩放"><a href="#图像裁剪和缩放" class="headerlink" title="图像裁剪和缩放"></a>图像裁剪和缩放</h2><p>可以参考</p>
<p><a href="https://blog.csdn.net/ZBC010/article/details/120584785?ops_request_misc=%7B%22request_id%22:%22170480359916800185832024%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170480359916800185832024&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120584785-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=opencv%E5%9B%BE%E5%83%8F%E8%A3%81%E5%89%AA%E5%92%8C%E7%BC%A9%E6%94%BE&spm=1018.2226.3001.4187">https://blog.csdn.net/ZBC010/article/details/120584785?ops_request_misc&#x3D;%257B%2522request%255Fid%2522%253A%2522170480359916800185832024%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id&#x3D;170480359916800185832024&amp;biz_id&#x3D;0&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduend~default-1-120584785-null-null.142^v99^pc_search_result_base6&amp;utm_term&#x3D;opencv%E5%9B%BE%E5%83%8F%E8%A3%81%E5%89%AA%E5%92%8C%E7%BC%A9%E6%94%BE&amp;spm&#x3D;1018.2226.3001.4187</a></p>
<h3 id="图像尺寸缩放："><a href="#图像尺寸缩放：" class="headerlink" title="图像尺寸缩放："></a>图像尺寸缩放：</h3><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">( InputArray src, <span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">			 OutputArray dst,<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">             Size dsize, <span class="comment">//调整成的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">double</span> fx = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">double</span> fy = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> interpolation = INTER_LINEAR </span></span></span><br><span class="line"><span class="params"><span class="function">             )</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h4><ul>
<li>src：输入的图像，Mat类</li>
<li>dst：输出的图像，当参数dsize不为0时，dst的大小由dsize决定；否则，它的大小由参数fx和fy决定</li>
<li>dsize：输出图像的大小，写成Size(宽，高)（单位：像素）</li>
<li>fx和fy：水平&#x2F;竖直方向上的缩放比例</li>
<li>interpolation：插值方法。取值如下：<br>INTER_NEAREST———最近邻插值<br>INTER_LINEAR———双线性插值（默认设置）<br>INTER_AREA———使用像素区域关系进行重采样<br>INTER_CUBIC———4x4像素邻域的双三次插值<br>INTER_LANCZOS4———8x8像素邻域的Lanczos插值</li>
<li>注意：参数dsize和参数(fx, fy)不能够同时为0</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>);</span><br><span class="line">    Mat outImg;</span><br><span class="line">    <span class="built_in">resize</span>(img, outImg, <span class="built_in">Size</span>(<span class="number">0</span>,<span class="number">0</span>), <span class="number">0.8</span>, <span class="number">0.8</span>);<span class="comment">//宽和高都变为原来的0.8倍</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;改变尺寸后&quot;</span>, outImg);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图像裁剪"><a href="#图像裁剪" class="headerlink" title="图像裁剪"></a>图像裁剪</h3><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>);</span><br><span class="line">    <span class="function">Rect <span class="title">cropArea</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    Mat outImg = <span class="built_in">img</span>(cropArea);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;裁剪后&quot;</span>, outImg);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图像绘制和文字输出"><a href="#图像绘制和文字输出" class="headerlink" title="图像绘制和文字输出"></a>图像绘制和文字输出</h2><p>参考资料：<a href="https://blog.csdn.net/k673656/article/details/129227483?ops_request_misc=%7B%22request_id%22:%22170480417316800213038610%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=170480417316800213038610&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-129227483-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=opencv%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%92%8C%E6%96%87%E5%AD%97%E7%BB%98%E5%88%B6&spm=1018.2226.3001.4187">Opencv图形绘制与文字输出_opencv mat 显示文字-CSDN博客</a></p>
<h3 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle</span><span class="params">(InputOutputArray img, Point center, <span class="type">int</span> radius, <span class="type">const</span> Scalar&amp; color, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中center表示中心位置，radius表示半径，thikness可以表示厚度，-1表示填充，与可以表示位FILLED</p>
<h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle</span><span class="params">(InputOutputArray img, Point pt1, Point pt2, <span class="type">const</span> Scalar&amp; color, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p> 值得注意的是，还可以使用RECT来绘制，函数如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle</span><span class="params">(InputOutputArray img, Rect(x,y,width,height), <span class="type">const</span> Scalar&amp; color, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="绘制直线"><a href="#绘制直线" class="headerlink" title="绘制直线"></a>绘制直线</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line</span><span class="params">(InputOutputArray img, Point pt1, Point pt2, <span class="type">const</span> Scalar&amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="输入文字"><a href="#输入文字" class="headerlink" title="输入文字"></a>输入文字</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">putText</span><span class="params">( InputOutputArray img, <span class="type">const</span> String&amp; text, Point org, <span class="type">int</span> fontFace, </span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">double</span> fontScale, Scalar color, <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">bool</span> bottomLeftOrigin = <span class="literal">false</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<p>img表示初始的文字，text表示文字内容，org表示文字的左下角坐标，fontface表示字体类型，fontscale表示字体大小，最后以为表示图像数据的原点是左下角还是左上角。</p>
<h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><p>首先，对几何变换做个简单了解。打开任意一个图像编辑器，一般可以有对图像进行放大、缩小、旋转等操作，这类操作改变了原图中各区域的空间关系。对于这类操作，通常称为图像的<strong>几何变换</strong>。</p>
<p>一般而言，完成一张图像的几何变换需要<strong>两个独立的算法</strong>：<strong>首先</strong>，需要一个算法实现空间坐标变换，用它描述每个像素如何从初始位置移动到终止位置；<strong>其次</strong>，还需要一个<strong>插值算法</strong>完成输出图像的每个像素的灰度值。</p>
<h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><h4 id="仿射矩阵"><a href="#仿射矩阵" class="headerlink" title="仿射矩阵"></a>仿射矩阵</h4><p>对于空间变换的仿射矩阵有两种计算方式，分别是<strong>方程组法</strong>和<strong>矩阵相乘法</strong>。</p>
<p><strong>(1) 方程组法</strong></p>
<p>仿射变换矩阵有六个未知数，所以需要三组对应位置坐标，构造出由六个方程组成的方程组即可解六个未知数。<br>举例：如果(0,0) 、(200,0) 、(0,200)这三个坐标通过某仿射变换矩阵A分别转换为(0,0) 、(100,0) 、(0,100)，则可利用这三组对应坐标构造出六个方程，求解出A。</p>
<p>对于C++的API函数getAffineTransform()输入参数有两种方式，第一种方式是将原位置坐标和对应的变换后的坐标分别保存在Point2f数组中，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Point2f src[] = &#123; <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">0</span>),<span class="built_in">Point2f</span>(<span class="number">200</span>,<span class="number">0</span>), <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">200</span>) &#125;;</span><br><span class="line">	Point2f dst[] = &#123; <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">0</span>),<span class="built_in">Point2f</span>(<span class="number">100</span>,<span class="number">0</span>), <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">100</span>) &#125;;</span><br><span class="line"></span><br><span class="line">	Mat A = <span class="built_in">getAffineTransform</span>(src,dst);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; A&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值A仍然是2行3列的矩阵，指的是<strong>仿射变换矩阵的前两行</strong>。需要注意的是，数据类型是CV_64F而<strong>不是</strong>CV_32F。</p>
<p>第二种方式是<strong>将原位置坐标和对应的变换后的坐标保存在</strong>Mat中，<strong>每一行代表一个坐标，数据类型必须是</strong>CV_32F，否则会报错，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Mat src = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">2</span>) &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">	Mat dst = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">2</span>) &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Mat A = <span class="built_in">getAffineTransform</span>(src, dst);</span><br><span class="line">	cout &lt;&lt; A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用矩阵相乘法计算仿射矩阵，<strong>前提是需要知道基本仿射变换步骤</strong>.</p>
<p><strong>需要注意的是</strong>，虽然先缩放再平移，但是仿射变换矩阵是<strong>平移仿射矩阵乘以缩放仿射矩阵，而不是缩放仿射矩阵乘以平移仿射矩阵</strong>，即等式右边的运算是从右向左进行的。</p>
<p>在<a href="https://so.csdn.net/so/search?q=OpenCV&spm=1001.2101.3001.7020">OpenCV</a>中是通过“*”运算符或者gemm函数来实现矩阵的乘法的，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Mat src = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//缩放矩阵</span></span><br><span class="line">	Mat dst = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>,<span class="number">1</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//平移矩阵</span></span><br><span class="line"></span><br><span class="line">	Mat A;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">gemm</span>(src,dst,<span class="number">1.0</span>,<span class="built_in">Mat</span>(),<span class="number">0</span>,A,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="透射变换"><a href="#透射变换" class="headerlink" title="透射变换"></a>透射变换</h3><p>仿射变换是在平面上的线性变换加平移，根据其性质可知变换后平行四边形依然是平行四边形，不改变直线的平行关系。透射变换即中心投影变换，利用透视中心、像点、目标点三点共线的条件,按透视旋转定律使承影面（透视面）绕迹线（透视轴）旋转某一角度，破坏原有的投影光线束，仍能保持承影面上投影几何图形不变的变换。</p>
<p> 透视变换是将二维的图片投影到一个三维视平面上，然后再转换到二维坐标下，所以也称为投影映射。</p>
<p>移动投影中心和承影面，可得到各种形状的变换。（有点像《三体》里的二向箔）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">cv::getPerspectiveTransform</span> <span class="params">(<span class="type">const</span> Point2f src[], <span class="type">const</span> Point2f dst[])</span></span></span><br></pre></td></tr></table></figure>



<p><strong>返回相应 4 个点对的 3x3 透视变换</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::warpPerspective</span> <span class="params">(InputArray src, OutputArray dst, InputArray M, Size dsize, <span class="type">int</span> flags=INTER_LINEAR, <span class="type">int</span> borderMode=BORDER_CONSTANT, <span class="type">const</span> Scalar &amp;borderValue=Scalar())</span></span></span><br></pre></td></tr></table></figure>



<p><strong>对图像应用透视变换</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> w = <span class="number">250</span>, h = <span class="number">350</span>;</span><br><span class="line">Mat matrix, imgWarp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string path = <span class="string">&quot;Resources/cards.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line">	Point2f src[<span class="number">4</span>] = &#123; &#123;<span class="number">529</span>, <span class="number">142</span>&#125;, &#123;<span class="number">771</span>, <span class="number">190</span>&#125;, &#123;<span class="number">405</span>, <span class="number">395</span>&#125;, &#123;<span class="number">674</span>, <span class="number">457</span>&#125; &#125;;</span><br><span class="line">	Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;, &#123;w, <span class="number">0.0f</span>&#125;, &#123;<span class="number">0.0f</span>, h&#125;, &#123;w, h&#125; &#125;;</span><br><span class="line"></span><br><span class="line">	matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line">	<span class="built_in">warpPerspective</span>(img, imgWarp, matrix, <span class="built_in">Point</span>(w, h));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">circle</span>(img, src[i], <span class="number">10</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), FILLED);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;ImageWarp&quot;</span>, imgWarp);</span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：文档扫描应该就是这种变换。</p>
<h2 id="颜色检测："><a href="#颜色检测：" class="headerlink" title="颜色检测："></a>颜色检测：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::inRange</span> <span class="params">(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)</span></span></span><br></pre></td></tr></table></figure>

<p>检查数组元素是否位于其他两个数组的元素之间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::namedWindow</span> <span class="params">(<span class="type">const</span> String &amp;winname, <span class="type">int</span> flags = WINDOW_AUTOSIZE)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>创建一个窗口</strong>。函数namedWindow创建一个可用作图像和轨迹栏占位符的窗口。创建的窗口由它们的名称引用。如果同名的窗口已经存在，则该函数不执行任何操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cv::createTrackbar</span> <span class="params">(<span class="type">const</span> String &amp;trackbarname, <span class="type">const</span> String &amp;winname, <span class="type">int</span> *value, <span class="type">int</span> count, TrackbarCallback onChange = <span class="number">0</span>, <span class="type">void</span> *userdata = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>创建一个</strong>trackbar<strong>并将其附加到指定窗口</strong>。函数createTrackbar创建一个具有指定名称和范围的trackbar（滑块或范围控件），分配一个变量值作为与trackbar同步的位置，并指定回调函数onChange为 在跟踪栏位置变化时被调用。创建的轨迹栏显示在指定的窗口winname中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Mat imgHSV, mask;</span><br><span class="line"><span class="type">int</span> hmin = <span class="number">0</span>, smin = <span class="number">110</span>, vmin = <span class="number">153</span>;</span><br><span class="line"><span class="type">int</span> hmax = <span class="number">19</span>, smax = <span class="number">240</span>, vmax = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string path = <span class="string">&quot;resources/lambo.png&quot;</span>;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">    <span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Trackbars&quot;</span>, (<span class="number">640</span>, <span class="number">200</span>));</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmin, <span class="number">179</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmax, <span class="number">179</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smin, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smax, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmin, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmax, <span class="number">2555</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">Scalar <span class="title">lower</span><span class="params">(hmin, smin, vmin)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">upper</span><span class="params">(hmax, smax, vmax)</span></span>;</span><br><span class="line">        <span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Image HSV&quot;</span>, imgHSV);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Image Mask&quot;</span>, mask);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="项目实操"><a href="#项目实操" class="headerlink" title="项目实操"></a>项目实操</h2><h4 id="参考资料：-1"><a href="#参考资料：-1" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://hitwhlc.yuque.com/tosania">@23沈晨阳</a></p>
<p>此处为语雀内容卡片，点击链接查看：<a href="https://hitwhlc.yuque.com/smartcar/daily/zg04pi54zig4rqbt">https://hitwhlc.yuque.com/smartcar/daily/zg04pi54zig4rqbt</a></p>
<p><a href="https://blog.csdn.net/qq_40344790/article/details/127653557?ops_request_misc=%7B%22request_id%22:%22170481303716800188516338%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=170481303716800188516338&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-127653557-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=opencv%E7%BA%A2%E7%BB%BF%E7%81%AF%E8%AF%86%E5%88%AB%E6%A3%80%E6%B5%8Bc++&spm=1018.2226.3001.4187">https://blog.csdn.net/qq_40344790&#x2F;article&#x2F;details&#x2F;127653557?ops_request_misc&#x3D;%257B%2522request%255Fid%2522%253A%2522170481303716800188516338%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id&#x3D;170481303716800188516338&amp;biz_id&#x3D;0&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>first_rank_ecpm_v1~rank_v31_ecpm-1-127653557-null-null.142^v99^pc_search_result_base6&amp;utm_term&#x3D;opencv%E7%BA%A2%E7%BB%BF%E7%81%AF%E8%AF%86%E5%88%AB%E6%A3%80%E6%B5%8Bc%2B%2B&amp;spm&#x3D;1018.2226.3001.4187</a></p>
<h4 id="任务内容："><a href="#任务内容：" class="headerlink" title="任务内容："></a>任务内容：</h4><h5 id="OpenCV红绿灯检测"><a href="#OpenCV红绿灯检测" class="headerlink" title="OpenCV红绿灯检测"></a>OpenCV红绿灯检测</h5><ul>
<li><p>使用**c++**版本的opencv对视频进行处理</p>
</li>
<li><p>读取TrafficLight.mp4</p>
</li>
<li><p>检测交通信号灯颜色，并在图像中标出红绿灯位置（中间数字无需检测）</p>
</li>
<li><p>将信号灯颜色以字符串输出到图像左上角</p>
</li>
<li><p>将处理后的视频输出为result.avi，示例为压缩包内“输出示例.avi”</p>
</li>
<li><p>可以进行创新，给大家的视频只是一个示例</p>
</li>
<li><p>在语雀中创建文档，完整记录自己的实现方式</p>
</li>
<li><p>将代码、result.avi放入同一压缩包内上传到语雀中</p>
</li>
<li><p>将result.avi直接传入语雀中，其他人可以直接查看的那种</p>
</li>
<li><p>提交截止时间：下周一例会前(2.14)</p>
</li>
</ul>
<h4 id="完成思路："><a href="#完成思路：" class="headerlink" title="完成思路："></a>完成思路：</h4><p>1.将视频的每一帧处理，（高斯模糊，边缘检测，膨胀….），增强特征点的提取。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对二值化后的图像进行高斯模糊</span></span><br><span class="line">    <span class="built_in">GaussianBlur</span>(imgDil, imgDil, <span class="built_in">Size</span>(<span class="number">7</span>, <span class="number">7</span>), <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对图像进行Canny边缘检测</span></span><br><span class="line">    <span class="built_in">Canny</span>(imgDil, imgDil, <span class="number">25</span>, <span class="number">75</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义膨胀操作的内核</span></span><br><span class="line">    Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对Canny边缘检测后的图像进行膨胀</span></span><br><span class="line">    <span class="built_in">dilate</span>(imgDil, imgDil, kernel);</span><br></pre></td></tr></table></figure>

<p>2.由于红绿灯是由许多小像素点组成的，可能会造成误判，故需要检测一下轮廓过滤出最大的画出矩形。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找图像中的轮廓</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"><span class="built_in">findContours</span>(imgDil, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储轮廓的多边形逼近和轮廓的矩形边界</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">conPoly</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"><span class="function">vector&lt;Rect&gt; <span class="title">boundRect</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储最大轮廓的相关信息</span></span><br><span class="line"><span class="type">double</span> maxx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> choose = <span class="number">0</span>, ok = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有轮廓，找到最大的符合条件的轮廓</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">contourArea</span>(contours[i]) / <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>) &gt; maxx)</span><br><span class="line">    &#123;</span><br><span class="line">        maxx = <span class="built_in">contourArea</span>(contours[i]) / <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line">        choose = i;</span><br><span class="line">        <span class="keyword">if</span> (maxx &gt; <span class="number">20</span> &amp;&amp; <span class="built_in">contourArea</span>(contours[i]) &gt; <span class="number">2000</span>)</span><br><span class="line">            ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有轮廓，绘制最大的轮廓及相关信息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (choose == i &amp;&amp; ok == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算轮廓的多边形逼近</span></span><br><span class="line">        <span class="type">double</span> peri = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">approxPolyDP</span>(contours[i], conPoly[i], <span class="number">0.02</span> * peri, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算轮廓的矩形边界</span></span><br><span class="line">        boundRect[i] = <span class="built_in">boundingRect</span>(conPoly[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制矩形边界</span></span><br><span class="line">        <span class="built_in">rectangle</span>(img, boundRect[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">225</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在矩形边界的左上角绘制文本</span></span><br><span class="line">        <span class="built_in">putText</span>(img, c, boundRect[i].<span class="built_in">tl</span>(), FONT_HERSHEY_DUPLEX, <span class="number">1.5</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">100</span>), <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>关于颜色的识别：</li>
</ul>
<p>由于inrange函数的局限性，最好将图像转换成HSV颜色空间，相比于RGB颜色空间，HSV颜色空间更适合处理颜色分割和阈值操作。在HSV中，颜色范围可以更容易地通过阈值进行调整，因为色调和明度是分开的。</p>
<p>使用HSV颜色空间是为了更容易地确定图像中红色和绿色的区域。对于交通灯的颜色检测，通常更关注颜色的种类而不是其亮度或深浅，因此使用HSV更为合适。</p>
<p>主函数代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 视频文件路径</span></span><br><span class="line">    string path = <span class="string">&quot;1.avi&quot;</span>;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">cap</span><span class="params">(path)</span></span>;</span><br><span class="line">    Mat img;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取视频帧数</span></span><br><span class="line">    <span class="type">int</span> cnt = cap.<span class="built_in">get</span>(CAP_PROP_FRAME_COUNT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取视频帧的大小</span></span><br><span class="line">    Size sizeReturn = <span class="built_in">Size</span>(cap.<span class="built_in">get</span>(CAP_PROP_FRAME_WIDTH), cap.<span class="built_in">get</span>(CAP_PROP_FRAME_HEIGHT));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建输出视频的写入对象，设置输出视频文件名、编码方式、帧率和大小</span></span><br><span class="line">    <span class="function">VideoWriter <span class="title">writer</span><span class="params">(<span class="string">&quot;out.mp4&quot;</span>, cv::VideoWriter::fourcc(<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;v&#x27;</span>), cap.get(CAP_PROP_FPS), sizeReturn)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历视频的每一帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取当前帧</span></span><br><span class="line">        cap &gt;&gt; img;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换当前帧为HSV颜色空间</span></span><br><span class="line">        Mat imgHSV;</span><br><span class="line">        <span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义绿色和红色的HSV阈值范围</span></span><br><span class="line">        <span class="function">Scalar <span class="title">g_lower</span><span class="params">(h_gmin, s_gmin, v_gmin)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">g_upper</span><span class="params">(h_gmax, s_gmax, v_gmax)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">r_lower</span><span class="params">(h_rmin, s_rmin, v_rmin)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">r_upper</span><span class="params">(h_rmax, s_rmax, v_rmax)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过HSV阈值得到绿色和红色的掩码</span></span><br><span class="line">        Mat g_mask, r_mask;</span><br><span class="line">        <span class="built_in">inRange</span>(imgHSV, g_lower, g_upper, g_mask);</span><br><span class="line">        <span class="built_in">inRange</span>(imgHSV, r_lower, r_upper, r_mask);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对绿色掩码进行目标识别和标记</span></span><br><span class="line">        <span class="built_in">workg</span>(g_mask, img, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对红色掩码进行目标识别和标记</span></span><br><span class="line">        <span class="built_in">workr</span>(r_mask, img, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将处理后的帧写入输出视频文件</span></span><br><span class="line">        writer.<span class="built_in">write</span>(img);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;img&quot;</span>, img);</span><br><span class="line">    <span class="comment">// 释放视频捕捉对象和写入对象</span></span><br><span class="line">    cap.<span class="built_in">release</span>();</span><br><span class="line">    writer.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>本来是不用学人脸识别的，感觉好玩所以写了个基于摄像头输入源的人脸识别：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/objdetect.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CascadeClassifier faceCascade;</span><br><span class="line">	faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;Load Error&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	Mat img;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cap.<span class="built_in">read</span>(img);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">		vector&lt;Rect&gt; face;</span><br><span class="line">		faceCascade.<span class="built_in">detectMultiScale</span>(img, face);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; face.<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">rectangle</span>(img, face[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">			<span class="built_in">putText</span>(img, <span class="string">&quot;a people&quot;</span>, face[i].<span class="built_in">tl</span>(), FONT_HERSHEY_DUPLEX, <span class="number">0.75</span>,<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后来感觉不够，完全可以基于主屏幕输入画面进行人脸识别，方便帮舍友识别出藏在床底下的老王（bushi）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/objdetect.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;X11/Xlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;X11/Xutil.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Display* display = <span class="built_in">XOpenDisplay</span>(<span class="literal">NULL</span>); <span class="comment">// 打开X11显示</span></span><br><span class="line">    Screen* screen = <span class="built_in">DefaultScreenOfDisplay</span>(display); <span class="comment">// 获取默认屏幕</span></span><br><span class="line">    <span class="type">int</span> width = screen-&gt;width; <span class="comment">// 获取屏幕的宽度</span></span><br><span class="line">    <span class="type">int</span> height = screen-&gt;height; <span class="comment">// 获取屏幕的高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载人脸检测分类器</span></span><br><span class="line">    CascadeClassifier faceCascade;</span><br><span class="line">    faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;Load Error&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建VideoWriter对象，用于将每一帧屏幕图像写入视频文件</span></span><br><span class="line">    <span class="function">VideoWriter <span class="title">writer</span><span class="params">(<span class="string">&quot;out.mp4&quot;</span>, cv::VideoWriter::fourcc(<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;v&#x27;</span>), <span class="number">30</span>, Size(width, height))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取屏幕的XImage对象</span></span><br><span class="line">        XImage* ximage = <span class="built_in">XGetImage</span>(display, <span class="built_in">DefaultRootWindow</span>(display), <span class="number">0</span>, <span class="number">0</span>, width, height, AllPlanes, ZPixmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为OpenCV的Mat对象</span></span><br><span class="line">        <span class="function">cv::Mat <span class="title">image</span><span class="params">(height, width, CV_8UC4, ximage-&gt;data)</span></span>; <span class="comment">// 创建Mat对象</span></span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(image, image, cv::COLOR_BGRA2BGR); <span class="comment">// 转换为BGR格式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在屏幕图像上进行人脸检测和标注</span></span><br><span class="line">        vector&lt;Rect&gt; face;</span><br><span class="line">        faceCascade.<span class="built_in">detectMultiScale</span>(image, face);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; face.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">rectangle</span>(image, face[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">putText</span>(image, <span class="string">&quot;a people&quot;</span>, face[i].<span class="built_in">tl</span>(), FONT_HERSHEY_DUPLEX, <span class="number">0.75</span>,<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示屏幕图像</span></span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;Screen&quot;</span>, image);</span><br><span class="line">        cv::<span class="built_in">waitKey</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将修改后的图像写入视频文件</span></span><br><span class="line">        writer.<span class="built_in">write</span>(image);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">XDestroyImage</span>(ximage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭X11显示</span></span><br><span class="line">    <span class="built_in">XCloseDisplay</span>(display);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放VideoCapture对象和VideoWriter对象的资源</span></span><br><span class="line">    writer.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS1初步</title>
    <url>/2024/03/11/ROS1%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<p><a name="J4y9t"></a></p>
<h1 id="Topic与Message"><a href="#Topic与Message" class="headerlink" title="Topic与Message"></a>Topic与Message</h1><span id="more"></span>
<p>基础概念：<br />1.话题Topic是节点间进行持续通讯的一种形式<br />2.话题通讯的两个节点通过话题的名称建立起话题通讯连接。<br />3.话题中通讯的数据，叫做消息Message<br />4.消息Message通常会按照一定的频率持续不断的发送，以保证消息数据的实时性。<br />5.消息的发送方叫做话题的发布者Publisher<br />6.消息的接收方叫做话题的订阅者Subsciber<br />更多有：<br />1.一个ROS节点网络中，可以同时存在多个话题<br />2.一个话题可以有多个发布者，也可以有多个订阅者<br />3.一个节点可以对多个话题进行订阅，也可以发布多个话题<br />4.不痛得传感器消息通常会拥有各自独立话题名称，每个话题只有一个发布者<br />5.机器人速度指令话题通常会有多个发布者，但是同一时间只能有一个发言人。<br><a name="v1QhS"></a></p>
<h2 id="Topic的C-实现"><a href="#Topic的C-实现" class="headerlink" title="Topic的C++实现"></a>Topic的C++实现</h2><p>发布者的具体步骤：<br />1.确定话题名称和消息类型<br />2.在代码文件中include消息类型对应的头文件<br />3.在main函数中通过NodeHandler大管家发布一个话题并得到消息发送对象<br />4.生成要发送的消息包并进行发送数据的赋值。<br />5.调用消息发送对象的publish()函数将消息包发送到话题当中。<br />为了查看有关的Topic我们可以使用以下的常用工具：<br />rostopic list<br />列出当前系统汇总所有活跃着的话题<br />rostopic echo 主体名称<br />显示指定话题中发送的消息包内容<br />rostopic hz 主体名称<br />统计指定话题中消息包的发送频率<br />而话题的订阅需要满足以下的步骤：<br />1.确定话题名称和消息类型<br />2.在代码文件中include&lt;ros.h&gt;和消息类型对应的头文件<br />3.在main函数中通过NodeHandler大管家订阅一个话题并设置消息接收回调函数<br />4.定义一个回调函数，对接收到的消息包进行处理。<br />5.main函数中需要执行ros::spinOnce()，让回调函数能够响应接受到的消息包<br><a name="JxKTI"></a></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_msgs/String.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;chao_node&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;node_chao is running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  NodeHandle nh;</span><br><span class="line">  Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;node_chao&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//这里第二个参数表示缓存空间</span></span><br><span class="line">  <span class="function">Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chao is sending\n&quot;</span>);</span><br><span class="line">    std_msgs::String msg;</span><br><span class="line">    msg.data = <span class="string">&quot;chao is sending message&quot;</span>;</span><br><span class="line">    pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_msgs/String.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chao_callback</span><span class="params">(std_msgs::String msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yao_callback</span><span class="params">(std_msgs::String msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_WARN</span>(msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;ma_node&quot;</span>);</span><br><span class="line"></span><br><span class="line">  NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  Subscriber sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;node_chao&quot;</span>, <span class="number">10</span>, chao_callback);</span><br><span class="line">	<span class="comment">//这里第三个参数类似于单片机里的中断函数</span></span><br><span class="line">  Subscriber sub_yao = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;node_yao&quot;</span>, <span class="number">10</span>, yao_callback);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">spinOnce</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="L26MD"></a></p>
<h3 id="图形化界面rqt-graph"><a href="#图形化界面rqt-graph" class="headerlink" title="图形化界面rqt_graph"></a>图形化界面rqt_graph</h3><p>运行三个节点和roscore，然后在一个新的终端中输入rqt_graph可以得到一个用来观察当前消息链路的图形化界面<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705307614453-48eb5146-7ae3-40e1-b12c-6cc0a99ed5cb.png#averageHue=%23817243&clientId=ued9d9fb6-a67b-4&from=paste&height=586&id=u8f7c53f5&originHeight=1172&originWidth=2532&originalType=binary&ratio=2&rotation=0&showTitle=false&size=466221&status=done&style=none&taskId=u54a4f49e-81fd-4e78-bf60-cd6d364613b&title=&width=1266" alt="image.png"><br><a name="DLwhc"></a></p>
<h3 id="launch文件同时启动多个节点"><a href="#launch文件同时启动多个节点" class="headerlink" title="launch文件同时启动多个节点"></a>launch文件同时启动多个节点</h3><p>launch文件是一种遵循XML语法的描述文件，这里启动多个节点只是launch文件的功能之一。 <br />对应到启动节点，我们可以使用这个流程：<br />1.使用launch文件，可以通过roslaunch指令一次启动多个节点。<br />2.在launch文件中，为节点添加output&#x3D;”screen”属性，可以容纳个节点信息输出在终端中。（ROS_WARN不受该属性控制）<br />3.在launch文件中，为节点添加launch-prefix&#x3D;”gnome-terminal -e”属性，可以让节点单独运行在一个独立终端中。<br />具体的，我们使用这个代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;yao_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;yao_node&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;chao_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;chao_node&quot;</span> <span class="attr">launch-prefix</span>=<span class="string">&quot;gnome-terminal -e&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;atr_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ma_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ma_node&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而我们使用时只需要在终端中使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">roslaunch 包名 launch文件名</span><br></pre></td></tr></table></figure>
<p>就可以运行了<br><a name="Xp45g"></a></p>
<h2 id="Topic的python实现"><a href="#Topic的python实现" class="headerlink" title="Topic的python实现"></a>Topic的python实现</h2><p>python实现基本上和c++实现差不多，无非就是c++中的NodeHandler变成了python中的rospy<br />看看代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment">#说明解释器和编码</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: <span class="comment">#主函数</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;chao_node&quot;</span>)<span class="comment">#申明节点</span></span><br><span class="line">    rospy.logwarn(<span class="string">&quot;node chao is running&quot;</span>)<span class="comment">#启动标签，打个warn让你吓一跳（</span></span><br><span class="line">    pub = rospy.Publisher(<span class="string">&quot;node_chao&quot;</span>, String, queue_size=<span class="number">10</span>)</span><br><span class="line">    rate = rospy.Rate(<span class="number">10</span>)<span class="comment">#控制频率</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        rospy.loginfo(<span class="string">&quot;node chao is sending message&quot;</span>)</span><br><span class="line">        msg = String()</span><br><span class="line">        msg.data = <span class="string">&quot;this is node chao&#x27;s message&quot;</span></span><br><span class="line">        pub.publish(msg)</span><br><span class="line">        rate.sleep()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接收端：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.loginfo(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">yao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.logwarn(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;ma_node&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;node_chao&quot;</span>, String, chao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    sub1 = rospy.Subscriber(<span class="string">&quot;node_yao&quot;</span>, String, yao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.loginfo(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">yao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.logwarn(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;ma_node&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;node_chao&quot;</span>, String, chao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    sub1 = rospy.Subscriber(<span class="string">&quot;node_yao&quot;</span>, String, yao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure>
<p>和c++的程序实现十分相似<br />值得说明的是，在launch中c++直接是一个可执行文件，而python则是要加入后缀py</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_py_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;yao_node.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;yao_node&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_py_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;chao_node.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;chao_node&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;atr_py_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ma_node.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ma_node&quot;</span> <span class="attr">launch-prefix</span>=<span class="string">&quot;gnome-terminal -e&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a name="Wz45W"></a></p>
<h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>service是ros中另一种通讯方式，类似于服务器和终端之间请求式的关系。<br />主要操作步骤分为：<br />1.服务端Server注册<br />2.客户端Client注册<br />3.节点管理器进行话题匹配<br />4.服务端请求服务<br />5.服务端提供服务<br><a name="OQdRg"></a></p>
<h2 id="终端指令的实现"><a href="#终端指令的实现" class="headerlink" title="终端指令的实现"></a>终端指令的实现</h2><p>我们使用ros自带的小乌龟来手动模拟一下一个service实现的过程<br />首先启动ros核心并召唤出小乌龟<br />然后使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rosrun rqt_service_caller rqt_service_caller</span><br></pre></td></tr></table></figure>
<p>召唤出图形化的service界面<br />按照<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705388668505-d518fb03-f941-4f5c-b0f6-7f08d92ac516.png#averageHue=%23ede7e5&clientId=u36e31b96-9ee5-4&from=paste&height=435&id=uc21508a1&originHeight=956&originWidth=940&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=271004&status=done&style=none&taskId=uda7225e4-f750-48cd-b154-967e9ec5ca3&title=&width=427.27271801184054" alt="image.png"><br />来配置<br />就能看到图上出现了一只新的小乌龟<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705388704513-fa622c00-39a1-498e-85e3-d908b340bc3e.png#averageHue=%234556fe&clientId=u36e31b96-9ee5-4&from=paste&height=255&id=u07d8973e&originHeight=562&originWidth=504&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=20276&status=done&style=none&taskId=u4f0b890d-9656-4f8d-9ad6-8a5d36bee53&title=&width=229.09090412549747" alt="image.png"></p>
<p><a name="zoD2G"></a></p>
<h2 id="c-实现"><a href="#c-实现" class="headerlink" title="c++实现"></a>c++实现</h2><p><a name="T27RX"></a></p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;service_test/service_test.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">service_client</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">service_client</span>();</span><br><span class="line">  ~<span class="built_in">service_client</span>();</span><br><span class="line">  ros::ServiceClient client;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">service_client::<span class="built_in">service_client</span>()</span><br><span class="line">&#123;</span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">  b = <span class="number">0</span>;</span><br><span class="line">  client = nh.<span class="built_in">serviceClient</span>&lt;service_test::service_test::Request&gt;(<span class="string">&quot;a_b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">service_client::request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;request&quot;</span> &lt;&lt; endl;</span><br><span class="line">  service_test::service_test req;</span><br><span class="line">  req.request.numb1 = a;</span><br><span class="line">  req.request.numb2 = b;</span><br><span class="line">  <span class="keyword">if</span> (client.<span class="built_in">call</span>(req))</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; req.response.sum &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;request falied&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  a++;</span><br><span class="line">  b += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">service_client::~<span class="built_in">service_client</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;service_client&quot;</span>);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;service_client is started&quot;</span>);</span><br><span class="line">  service_client service_client;</span><br><span class="line">  <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    service_client.<span class="built_in">request</span>();</span><br><span class="line">    rate.<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里用一个类写了一下这个东西，实现了一个a+b的不断请求<br />注意一下里面的核心语句：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">serviceClient&lt;service_test::service_test::Request&gt;(&quot;a+b&quot;);</span><br></pre></td></tr></table></figure>
<p>这里定义了最重要的服务名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">req.request.numb1 = a;</span><br><span class="line">  req.request.numb2 = b;</span><br><span class="line">  if (client.call(req))</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot;+&quot; &lt;&lt; b &lt;&lt; &quot;=&quot; &lt;&lt; req.response.sum &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里以req为媒介去询问并获得数据<br><a name="rS9TQ"></a></p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;service_test/service_test.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">service_server</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">service_server</span>(<span class="comment">/* args */</span>);</span><br><span class="line">  ~<span class="built_in">service_server</span>();</span><br><span class="line">  ros::ServiceServer server;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">requestCallback</span><span class="params">(service_test::service_test::Request &amp;request, service_test::service_test::Response &amp;response)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">service_server::<span class="built_in">service_server</span>(<span class="comment">/* args */</span>)</span><br><span class="line">&#123;</span><br><span class="line">  server = nh.<span class="built_in">advertiseService</span>(<span class="string">&quot;a_b&quot;</span>, &amp;service_server::requestCallback, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">service_server::requestCallback</span><span class="params">(service_test::service_test::Request &amp;request, service_test::service_test::Response &amp;response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a request is handled&quot;</span> &lt;&lt; endl;</span><br><span class="line">  response.sum = request.numb1 + request.numb2;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service_server::~<span class="built_in">service_server</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;service_server&quot;</span>);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;service_server is started&quot;</span>);</span><br><span class="line">  service_server server;</span><br><span class="line">  <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里核心为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">advertiseService</span>(<span class="string">&quot;a_b&quot;</span>, &amp;service_server::requestCallback, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>这里前面是名字，后面有返回参数，不过这个this我看了半天也没明白是什么，我看如果没有写类的话这里好像只有两个参数，所以我大胆猜测这个是用来指向类的一个东西？<br><a name="RRsNw"></a></p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>再cmakelists中加入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(service_client src/service_client.cpp)  </span><br><span class="line"><span class="built_in">target_link_libraries</span>(service_client</span><br><span class="line">    $&#123;catkin_LIBRARIES&#125;) </span><br><span class="line"><span class="built_in">add_dependencies</span>(service_client $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(service_server src/service_server.cpp)  </span><br><span class="line"><span class="built_in">target_link_libraries</span>(service_server</span><br><span class="line">    $&#123;catkin_LIBRARIES&#125;) </span><br><span class="line"><span class="built_in">add_dependencies</span>(service_server $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br></pre></td></tr></table></figure>
<p>然后编译运行<br />效果：<img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705392274716-e9b41739-0415-4df2-964b-0a2a2bb01b27.png#averageHue=%231e1a1a&clientId=ue763d424-91f3-4&from=paste&height=440&id=u37dec1cb&originHeight=968&originWidth=1456&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=257893&status=done&style=none&taskId=uf53eabec-6008-468b-a83f-f7a4cd72232&title=&width=661.8181674736594" alt="image.png"><br><a name="OpNbK"></a></p>
<h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><p><a name="sOxSw"></a></p>
<h3 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> service_test.srv <span class="keyword">import</span> service_test, service_testResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addCallback</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="built_in">sum</span> = req.numb1 + req.numb2</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;a request is being handled&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> service_testResponse(<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;add_server&quot;</span>)</span><br><span class="line">    <span class="comment"># 创建一个名为add_server的server，注册回调函数addCallback,返回类型为service_test</span></span><br><span class="line">    server = rospy.Service(<span class="string">&quot;add_server&quot;</span>, service_test, addCallback)</span><br><span class="line"></span><br><span class="line">    rospy.loginfo(<span class="string">&quot;server is Ready.&quot;</span>)</span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实具体思路和c++很相似，就有个坑，第五行那两个，我本来以为只要自定义两个当作输入输出就行了，后来发现好像不大行，必须严格按照他这个格式。<br><a name="Mphok"></a></p>
<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> service_test.srv <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_two_ints_client</span>(<span class="params">x, y</span>):</span><br><span class="line">    rospy.wait_for_service(<span class="string">&quot;add_server&quot;</span>)</span><br><span class="line">    add_two_ints = rospy.ServiceProxy(<span class="string">&quot;add_server&quot;</span>, service_test)</span><br><span class="line">    resp = add_two_ints(x, y)</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;sum:%lf&quot;</span>, resp.<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;add_client&quot;</span>)</span><br><span class="line">    x = <span class="number">0.1585</span></span><br><span class="line">    y = <span class="number">15.21</span></span><br><span class="line">    add_two_ints_client(x, y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这位更是十分简洁，没啥问题。记得和srv里文件一定就行了。<br />说起来为啥C语言要搞成.h而python只要srv呢（<br><a name="DPKCw"></a></p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果<img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705478826907-6a743179-d0cd-490d-be0c-760eb509f9b5.png#averageHue=%231e1b1a&clientId=ubbf6ae85-b225-4&from=paste&height=492&id=u874c5b1f&originHeight=984&originWidth=1476&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=191244&status=done&style=none&taskId=ufb54405b-e108-494f-a287-1060d7db19b&title=&width=738" alt="image.png"></h3><p><a name="gMt1l"></a></p>
<h1 id="param"><a href="#param" class="headerlink" title="param"></a>param</h1><p><a name="QUW9p"></a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>举个栗子，我现在手里有一组数据，现在很多个节点都在想要得到我这个数据，如果使用前面的两种通讯方式，我开个topic在里面公麦喊数据显然不太合理，或者再开一个服务器呢？看起来好像不错，但是我们要维持这个端口一方面得一直开着这个节点，另一方面要不断的对外输出数据还得自己手写，而且各种数据类型还都不好处理。这个时候就需要我们的参数服务器登场了。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705485702889-26424fa6-e2ba-4130-ae19-545ad789e272.png#averageHue=%23f5f5f5&clientId=u670af268-3edf-4&from=paste&height=280&id=u95f2ebc6&originHeight=559&originWidth=1024&originalType=binary&ratio=2&rotation=0&showTitle=false&size=43576&status=done&style=none&taskId=ufb874013-3788-41b9-8c63-bc7cf6c85c4&title=&width=512" alt="image.png"><br />在这里总计有三个角色，但是实际操作起来的时候，我们并不需要向之前一样像master注册身份，而是只要连接到master之后就可以进行全部的操作。<br />当然了为了书写的方便我们在实现中依旧将get和set分开写。值得注意的是，参数服务器不随着set的关闭而关闭，而是随着roscore的启动一直存在。<br><a name="aKczn"></a></p>
<h2 id="c-的实现"><a href="#c-的实现" class="headerlink" title="c++的实现"></a>c++的实现</h2><p><a name="UUER6"></a></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;param_set&quot;</span>);</span><br><span class="line">  NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    string name = <span class="string">&quot;vbot&quot;</span>;</span><br><span class="line">    string geometry = <span class="string">&quot;rectangle&quot;</span>;</span><br><span class="line">    <span class="type">double</span> wheel_radius = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">int</span> wheel_num = <span class="number">4</span>;</span><br><span class="line">    <span class="type">bool</span> vision = <span class="literal">true</span>;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; base_size = &#123;<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.3</span>&#125;;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; sensor_id = &#123;&#123;<span class="string">&quot;camera&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;laser&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&#x27;vbot&#x27;</span>);               <span class="comment">// 字符串, 机器人的名字，char*</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;geometry&quot;</span>, geometry);         <span class="comment">// 字符串, 形状，string</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;wheel_radius&quot;</span>, wheel_radius); <span class="comment">// 车轮半径double</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;wheel_num&quot;</span>, wheel_num);        <span class="comment">// 车轮数量int</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;vision&quot;</span>, vision);              <span class="comment">// 是否具有视觉bool</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;base_size&quot;</span>, base_size);        <span class="comment">// 三维体积vector</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;sensor_id&quot;</span>, sensor_id);        <span class="comment">// 传感器的id，map</span></span><br><span class="line">    <span class="comment">// 验证是否设置成功</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get name&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get geometry&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get wheel_radius&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get wheel_num&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get vision&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get base_size&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get sensor_id&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们描述了一个机器人，将这个机器人的各个参数传入了参数服务器<br />值得说明的是，这里用了两种写法来写入数据，一种是用NodeHandle，一种直接调用了param里的函数<br />另外system这里不知道为什么会给个warning，无视就行了<br><a name="OjksJ"></a></p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;param_get&quot;</span>);</span><br><span class="line">  NodeHandle nh;</span><br><span class="line">  <span class="comment">// 修改参数</span></span><br><span class="line">  nh.<span class="built_in">setParam</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;mybot&quot;</span>); <span class="comment">// 字符串, char*</span></span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="type">double</span>&gt; base_size = &#123;<span class="number">0.2</span>, <span class="number">0.04</span>&#125;;</span><br><span class="line">  nh.<span class="built_in">setParam</span>(<span class="string">&quot;base_size&quot;</span>, base_size); <span class="comment">// vector</span></span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt; sensor_id = &#123;&#123;<span class="string">&quot;camera&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;laser&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">  sensor_id.<span class="built_in">insert</span>(&#123;<span class="string">&quot;ultrasonic&quot;</span>, <span class="number">5</span>&#125;);</span><br><span class="line">  param::<span class="built_in">set</span>(<span class="string">&quot;sensor_id&quot;</span>, sensor_id); <span class="comment">// map</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line"></span><br><span class="line">  string name;</span><br><span class="line">  string geometry;</span><br><span class="line">  <span class="type">double</span> wheel_radius;</span><br><span class="line">  <span class="type">int</span> wheel_num;</span><br><span class="line">  <span class="type">bool</span> vision;</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;geometry&quot;</span>, geometry);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;wheel_radius&quot;</span>, wheel_radius);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;wheel_num&quot;</span>, wheel_num);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;vision&quot;</span>, vision);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;base_size&quot;</span>, base_size);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;sensor_id&quot;</span>, sensor_id);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;ros::NodeHandle getParam, name: %s, geometry: %s, wheel_radius: %lf, wheel: %d, vision: %s, base_size: (%lf, %lf)&quot;</span>,</span><br><span class="line">           name.<span class="built_in">c_str</span>(), geometry.<span class="built_in">c_str</span>(), wheel_radius, wheel_num, vision ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>,</span><br><span class="line">           base_size[<span class="number">0</span>], base_size[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> sensor : sensor_id)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;ros::NodeHandle getParam, %s_id: %d&quot;</span>, sensor.first.<span class="built_in">c_str</span>(), sensor.second);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除参数</span></span><br><span class="line"></span><br><span class="line">  nh.<span class="built_in">deleteParam</span>(<span class="string">&quot;vision&quot;</span>);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;rosparam get vision&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里好像也没有什么要说明的了，大家看看就行了<br><a name="PVfKq"></a></p>
<h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(param_set src/param_set.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(param_get src/param_get.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(param_set</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(param_get</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><a name="X1725"></a></p>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>param函数直接返回值，不存在则返回default_val，getparamcached函数好象是getparam的进阶版，加了个记搜？getparamnames返回所有值，以vector形式给出。<br><a name="EWhdA"></a></p>
<h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705486990088-41376b0a-9140-4996-8f12-a6679c204d01.png#averageHue=%231f1b1b&clientId=u670af268-3edf-4&from=paste&height=506&id=uf0ed96e3&originHeight=1012&originWidth=1508&originalType=binary&ratio=2&rotation=0&showTitle=false&size=247069&status=done&style=none&taskId=u607c6b38-a903-4ac5-ab4b-8f6db920f4c&title=&width=754" alt="image.png"><br><a name="dsWxB"></a></p>
<h2 id="python实现-1"><a href="#python实现-1" class="headerlink" title="python实现"></a>python实现</h2><p><a name="mnReF"></a></p>
<h3 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;param_hello_world_set&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置参数</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;vbot&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;geometry&quot;</span>, <span class="string">&quot;rectangle&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_radius&quot;</span>, <span class="number">0.1</span>)  <span class="comment"># double</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_num&quot;</span>, <span class="number">4</span>)  <span class="comment"># int</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;vision&quot;</span>, <span class="literal">True</span>)  <span class="comment"># bool</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;base_size&quot;</span>, [<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.3</span>])  <span class="comment"># list</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;sensor_id&quot;</span>, &#123;<span class="string">&quot;camera&quot;</span>: <span class="number">0</span>, <span class="string">&quot;laser&quot;</span>: <span class="number">2</span>&#125;)  <span class="comment"># dictionary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证是否设置成功</span></span><br><span class="line">    os.system(<span class="string">&quot;rosparam get name&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get geometry&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_radius&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_num&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get vision&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get base_size&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get sensor_id&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><a name="pLckx"></a></p>
<h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;param_hello_world_set&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置参数</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;vbot&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;geometry&quot;</span>, <span class="string">&quot;rectangle&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_radius&quot;</span>, <span class="number">0.1</span>)  <span class="comment"># double</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_num&quot;</span>, <span class="number">4</span>)  <span class="comment"># int</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;vision&quot;</span>, <span class="literal">True</span>)  <span class="comment"># bool</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;base_size&quot;</span>, [<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.3</span>])  <span class="comment"># list</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;sensor_id&quot;</span>, &#123;<span class="string">&quot;camera&quot;</span>: <span class="number">0</span>, <span class="string">&quot;laser&quot;</span>: <span class="number">2</span>&#125;)  <span class="comment"># dictionary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证是否设置成功</span></span><br><span class="line">    os.system(<span class="string">&quot;rosparam get name&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get geometry&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_radius&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_num&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get vision&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get base_size&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get sensor_id&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这个实在是没啥好讲的，看代码就行了（<br><a name="OTwIA"></a></p>
<h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h1><p><a name="JC3y8"></a></p>
<h2 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h2><p>在实际中，有的时候通讯的时间是非常长的，而在通讯过程中，我们需要掌握中间值，比如我们要下载一个东西，我们可能时不时就要看一看下载进度，这个时候进度就是所需要的反馈feedback值<br />Action在结构上几乎和服务service相似，所以我暂时将其理解为service with feedback(?)<br><a name="yurY8"></a></p>
<h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><p>说实话这个实现有点阴间，我也只是把教程里的那个东西实现了一下，要自己纯手搓感觉不好实现（<br><a name="fAysR"></a></p>
<h3 id="文件分层："><a href="#文件分层：" class="headerlink" title="文件分层："></a>文件分层：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705559399543-95ef64ac-bbf9-47a2-a75d-de38c50c3d9c.png#averageHue=%23060504&clientId=ucf2197ff-0c36-4&from=paste&height=74&id=ub74f1fe7&originHeight=370&originWidth=468&originalType=binary&ratio=2&rotation=0&showTitle=false&size=41409&status=done&style=none&taskId=u7efe1ed1-fea5-401f-9729-b13df614435&title=&width=93.6" alt="image.png"><br><a name="CiRbu"></a></p>
<h3 id="laundry-action"><a href="#laundry-action" class="headerlink" title="laundry.action"></a>laundry.action</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># goal，洗衣类型 1:开始快洗;2:开始高温洗;3:开始浸泡洗</span></span><br><span class="line"><span class="string">uint8</span> <span class="string">wash_type</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># result，洗涤结果</span></span><br><span class="line"><span class="string">string</span> <span class="string">wash_result</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># feedback，洗涤的进度</span></span><br><span class="line"><span class="string">uint8</span> <span class="string">wash_percent</span></span><br></pre></td></tr></table></figure>
<p><a name="YMVMz"></a></p>
<h3 id="cmake-1"><a href="#cmake-1" class="headerlink" title="cmake"></a>cmake</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(action_test)</span><br><span class="line"><span class="comment"># catkin构建时依赖的组件包</span></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  actionlib</span><br><span class="line">  actionlib_msgs</span><br><span class="line">)</span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line"><span class="comment"># include</span></span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 配置action源文件，FILES将引用当前功能包目录的action目录中的*.action文件，自动生成一个头文件（*.h）</span></span><br><span class="line">add_action_files(</span><br><span class="line">  FILES</span><br><span class="line">  Laundry.action</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成消息时依赖于std_msgs、actionlib_msgs</span></span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">  actionlib_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行时依赖，描述了库、catkin构建依赖项和系统依赖的功能包</span></span><br><span class="line">catkin_package(</span><br><span class="line"><span class="comment">#  INCLUDE_DIRS include</span></span><br><span class="line"><span class="comment">#  LIBRARIES action_test</span></span><br><span class="line"> CATKIN_DEPENDS roscpp rospy std_msgs actionlib actionlib_msgs </span><br><span class="line"><span class="comment">#  DEPENDS system_lib</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点构建选项，配置可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(action_client src/action_client.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(action_server src/action_server.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建库和可执行文件之前，预先生成依赖消息</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(action_client <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(action_server <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点构建选项，配置目标链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(action_client</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(action_server</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><a name="mf7uX"></a></p>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;actionlib/client/simple_action_client.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;action_test/LaundryAction.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> actionlib::SimpleActionClient&lt;action_test::LaundryAction&gt; ActionClient;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doneCb</span><span class="params">(<span class="type">const</span> actionlib::SimpleClientGoalState &amp;state, <span class="type">const</span> action_test::LaundryResultConstPtr &amp;result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state.state_ == state.SUCCEEDED)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;反馈结果:%s&quot;</span>, result-&gt;wash_result.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;任务失败！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">activeCb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;动作已经被激活....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">feedbackCb</span><span class="params">(<span class="type">const</span> action_test::LaundryFeedbackConstPtr &amp;feedback)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;洗涤进度为:%d%s&quot;</span>, feedback-&gt;wash_percent, <span class="string">&quot;%&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 设置编码</span></span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.初始化ROS节点</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;action_client&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.实例化ROS句柄</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.实例化action客户端对象</span></span><br><span class="line">  <span class="comment">// 参数2为动作的名称，参数3默认为true，无需再调用ros::spin()，设置为false时需手动调用</span></span><br><span class="line">  <span class="function">ActionClient <span class="title">client</span><span class="params">(nh, <span class="string">&quot;laundry&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 等待服务端启动</span></span><br><span class="line">  client.<span class="built_in">waitForServer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.定义动作目标数据</span></span><br><span class="line">  action_test::LaundryGoal goal;</span><br><span class="line">  goal.wash_type = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.发送目标，同时注册回调，处理反馈以及最终结果</span></span><br><span class="line">  <span class="comment">// 参数1是转换为Done时处理的回调函数，参数2为转换为Active时处理的回调函数，参数3为每当收到此目标的反馈时就调用的回调函数</span></span><br><span class="line">  client.<span class="built_in">sendGoal</span>(goal, &amp;doneCb, &amp;activeCb, &amp;feedbackCb);</span><br><span class="line"></span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="s4uDJ"></a></p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;actionlib/server/simple_action_server.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;action_test/LaundryAction.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> actionlib::SimpleActionServer&lt;action_test::LaundryAction&gt; ActionServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.收到action的goal后调用的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeCb</span><span class="params">(<span class="type">const</span> action_test::LaundryGoalConstPtr &amp;goal, ActionServer *server)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 获取目标值</span></span><br><span class="line">  <span class="type">uint8_t</span> wash_type = goal-&gt;wash_type;</span><br><span class="line">  std::string wash_mode;</span><br><span class="line">  <span class="keyword">switch</span> (wash_type)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    wash_mode = <span class="string">&quot;快洗&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    wash_mode = <span class="string">&quot;高温洗&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    wash_mode = <span class="string">&quot;浸泡洗&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;目标值为%d，开始%s！&quot;</span>, wash_type, wash_mode.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应连续反馈</span></span><br><span class="line">  action_test::LaundryFeedback feedback;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    feedback.wash_percent = i;</span><br><span class="line">    server-&gt;<span class="built_in">publishFeedback</span>(feedback);</span><br><span class="line">    ros::<span class="built_in">Duration</span>(<span class="number">0.5</span>).<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反馈结果</span></span><br><span class="line">  action_test::LaundryResult result;</span><br><span class="line">  result.wash_result = wash_mode + <span class="string">&quot;完成！&quot;</span>;</span><br><span class="line">  server-&gt;<span class="built_in">setSucceeded</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 设置编码</span></span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="comment">// 1.初始化ROS节点</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;action_server&quot;</span>);</span><br><span class="line">  <span class="comment">// 2.实例化ROS句柄</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  <span class="comment">// 3.实例化action服务端对象</span></span><br><span class="line">  <span class="comment">// 参数2为动作服务器名称，参数3为当一个新目标被接收时在一个单独的线程中被调用，参数4为告诉ActionServer是否在它出现时立即开始发布</span></span><br><span class="line">  <span class="function">ActionServer <span class="title">server</span><span class="params">(nh, <span class="string">&quot;laundry&quot;</span>, boost::bind(&amp;executeCb, _1, &amp;server), <span class="literal">false</span>)</span></span>;</span><br><span class="line">  server.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="Vpuri"></a></p>
<h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705559548910-bc235096-7d99-4292-b382-b91268dfc171.png#averageHue=%231f1b1b&clientId=ucf2197ff-0c36-4&from=paste&height=506&id=ub6200bb0&originHeight=1012&originWidth=1508&originalType=binary&ratio=2&rotation=0&showTitle=false&size=286203&status=done&style=none&taskId=u5d1e22a4-1937-479d-8cce-5e1ec8d2b05&title=&width=754" alt="image.png"></p>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS2初步</title>
    <url>/2024/03/11/ROS2%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<p><a name="w3PS4"></a></p>
<h1 id="安装ROS2"><a href="#安装ROS2" class="headerlink" title="安装ROS2"></a>安装ROS2</h1><p>鱼香yyds</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; bash fishros</span><br></pre></td></tr></table></figure>
<p>卸载ROS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt remove ros-foxy-* &amp;&amp; sudo apt autoremove</span><br></pre></td></tr></table></figure>
<p><a name="hoy3W"></a></p>
<span id="more"></span>
<h1 id="基础概念："><a href="#基础概念：" class="headerlink" title="基础概念："></a>基础概念：</h1><p>与ROS1类似，ROS中同样具有节点，工作空间，功能包等概念<br><a name="ALm4g"></a></p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p><a name="RgFga"></a></p>
<h3 id="每一个节点都负责一个单独的模块。"><a href="#每一个节点都负责一个单独的模块。" class="headerlink" title="每一个节点都负责一个单独的模块。"></a>每一个节点都负责一个单独的模块。</h3><p>举个不太恰当的例子：外卖员小哥外卖给主播小姐姐吃，送累了就刷小姐姐直播跳舞，这里外卖小哥和小姐姐都是一个节点，大家共同构成了一个整体，营造出lianghao社会（bushi）<br />ROS2中的节点也是如此，每一个节点也是只负责一个单独的模块化的功能（比如一个节点负责控制车轮转动，一个节点负责从激光雷达获取数据、一个节点负责处理激光雷达的数据、一个节点负责定位等等）</p>
<blockquote>
<p><a name="sQg5i"></a></p>
</blockquote>
<h3 id="节点通信（详见）"><a href="#节点通信（详见）" class="headerlink" title="节点通信（详见）"></a>节点通信（详见）</h3><p>ROS2中主要有以下四种通信方式：</p>
<ul>
<li>话题-topics</li>
<li>服务-services</li>
<li>动作-Action</li>
<li>参数-parameters</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/gif/39221021/1709952196063-33689e90-6391-444f-b3f8-054f02b98e34.gif#averageHue=%23faf7fb&clientId=uc1f625e0-63bc-4&from=drop&id=u42629f68&originHeight=480&originWidth=854&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=2993370&status=done&style=none&taskId=u5f22b082-1278-4c51-a0b8-8d390e71c3e&title=" alt="Nodes-TopicandService.gif"></p>
<p><a name="SasOs"></a></p>
<h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><p>需要使用指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run &lt;package_name&gt; &lt;executable_name&gt;</span><br></pre></td></tr></table></figure>
<p><a name="qUDBx"></a></p>
<h3 id="命令行查看节点信息"><a href="#命令行查看节点信息" class="headerlink" title="命令行查看节点信息"></a>命令行查看节点信息</h3><p>这里涉及以下两个概念：</p>
<ul>
<li>GUI（Graphical User Interface）就是平常我们说的图形用户界面，大家用的Windows是就是可视化的，我们可以通过鼠标点击按钮等图形化交互完成任务。</li>
<li>CLI（Command-Line Interface）就是命令行界面了，我们所用的终端，黑框框就是命令行界面，没有图形化。<br><a name="JdGKJ"></a></li>
</ul>
<h3 id="节点相关CLI："><a href="#节点相关CLI：" class="headerlink" title="节点相关CLI："></a>节点相关CLI：</h3><p>列举几个常用的：<br />运行节点(</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run &lt;package_name&gt; &lt;executable_name&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p>查看节点列表(常用)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 node listCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p>查看节点信息(常用)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 node listCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p>重映射节点名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle</span><br></pre></td></tr></table></figure>
<p><a name="qg3CI"></a></p>
<h2 id="工作空间-功能包："><a href="#工作空间-功能包：" class="headerlink" title="工作空间&amp;&amp;功能包："></a>工作空间&amp;&amp;功能包：</h2><p>想要找到一个可执行文件（节点）必须依赖于一个功能包，这些包可以统一放在某个工作空间里。<br />创建工作空间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p turtle_ws/src</span><br><span class="line"><span class="built_in">cd</span> turtle_ws/src</span><br></pre></td></tr></table></figure>
<p>功能包：<br />可以理解为存放节点的容器。<br />ROS2中功能包根据编译方式的不同分为三种类型。</p>
<ul>
<li>ament_python，适用于python程序</li>
<li>cmake，适用于C++</li>
<li>ament_cmake，适用于C++程序,是cmake的增强版<br><a name="YUrMN"></a></li>
</ul>
<h3 id="功能包获取"><a href="#功能包获取" class="headerlink" title="功能包获取"></a>功能包获取</h3><ul>
<li><p>安装一般使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ros-&lt;version&gt;-package_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动编译：有点麻烦，一般都是需要对包进行修改的时候shiytong<br><a name="mddWh"></a></p>
</li>
</ul>
<h3 id="相关指令——ros2pkg"><a href="#相关指令——ros2pkg" class="headerlink" title="相关指令——ros2pkg"></a>相关指令——ros2pkg</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create       Create a new ROS2 package</span><br><span class="line">executables  Output a list of package specific executables</span><br><span class="line">list         Output a list of available packages</span><br><span class="line">prefix       Output the prefix path of a package</span><br><span class="line">xml          Output the XML of the package manifest or a specific tag</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   <strong>1.创建功能包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg create &lt;package-name&gt;  --build-type  &#123;cmake,ament_cmake,ament_python&#125;  --dependencies &lt;依赖名字&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p><strong>2.列出可执行文件</strong><br />列出所有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg executablesCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p>列出某个功能包的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg executables turtlesimCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709952853767-34253709-40e1-445a-9df0-99407cbf16e4.png#averageHue=%23262321&clientId=uc1f625e0-63bc-4&from=paste&id=u29043447&originHeight=82&originWidth=430&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u5ab1ac60-bfbc-4ace-97a5-3a014d2af0f&title="><br /><strong>3.列出所有的包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg listCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p><strong>4.输出某个包所在路径的前缀</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg prefix  &lt;package-name&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p>比如小乌龟</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg prefix turtlesimCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p><strong>5.列出包的清单描述文件</strong><br /><strong>每一个功能包都有一个标配的manifest.xml文件，用于记录这个包的名字，构建工具，编译信息，拥有者，干啥用的等信息。</strong><br /><strong>通过这个信息，就可以自动为该功能包安装依赖，构建时确定编译顺序等</strong><br />查看小乌龟模拟器功能包的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg xml turtlesim</span><br></pre></td></tr></table></figure>
<p><a name="WrcLt"></a></p>
<h2 id="colcon"><a href="#colcon" class="headerlink" title="colcon:"></a>colcon:</h2><p>colcon其是就是个功能包的构建工具，说白了就是编译器。<br />ros2默认死没有colcon的，所以需要安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python3-colcon-common-extensions</span><br></pre></td></tr></table></figure>
<p><a name="BzyYh"></a></p>
<h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><p><a name="moZ8W"></a></p>
<h3 id="5-1-只编译一个包"><a href="#5-1-只编译一个包" class="headerlink" title="5.1 只编译一个包"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_51-%e5%8f%aa%e7%bc%96%e8%af%91%e4%b8%80%e4%b8%aa%e5%8c%85">5.1 只编译一个包</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select YOUR_PKG_NAME Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p><a name="Mb0AY"></a></p>
<h3 id="5-2-不编译测试单元"><a href="#5-2-不编译测试单元" class="headerlink" title="5.2 不编译测试单元"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_52-%e4%b8%8d%e7%bc%96%e8%af%91%e6%b5%8b%e8%af%95%e5%8d%95%e5%85%83">5.2 不编译测试单元</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select YOUR_PKG_NAME  --cmake-args -DBUILD_TESTING=0Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p><a name="Dt5J5"></a></p>
<h3 id="5-3-运行编译的包的测试"><a href="#5-3-运行编译的包的测试" class="headerlink" title="5.3 运行编译的包的测试"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_53-%e8%bf%90%e8%a1%8c%e7%bc%96%e8%af%91%e7%9a%84%e5%8c%85%e7%9a%84%e6%b5%8b%e8%af%95">5.3 运行编译的包的测试</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon testCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p><a name="Gacar"></a></p>
<h3 id="5-4-允许通过更改src下的部分文件来改变install（重要）"><a href="#5-4-允许通过更改src下的部分文件来改变install（重要）" class="headerlink" title="5.4 允许通过更改src下的部分文件来改变install（重要）"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_54-%e5%85%81%e8%ae%b8%e9%80%9a%e8%bf%87%e6%9b%b4%e6%94%b9src%e4%b8%8b%e7%9a%84%e9%83%a8%e5%88%86%e6%96%87%e4%bb%b6%e6%9d%a5%e6%94%b9%e5%8f%98install%ef%bc%88%e9%87%8d%e8%a6%81%ef%bc%89">5.4 允许通过更改src下的部分文件来改变install（重要）</a></h3><p>（每次调整 python 脚本时都不必重新build了）</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">colcon build <span class="comment">--symlink-install</span></span><br></pre></td></tr></table></figure>
<p><a name="DEwTp"></a></p>
<h2 id="手撸节点test（c-）"><a href="#手撸节点test（c-）" class="headerlink" title="手撸节点test（c++）"></a>手撸节点test（c++）</h2><p>由于python的运行效率实在是一言难尽，我们只学习C++_的版本<br><a name="b6gfN"></a></p>
<h3 id="创建工作空间-功能包"><a href="#创建工作空间-功能包" class="headerlink" title="创建工作空间&amp;&amp; 功能包"></a>创建工作空间&amp;&amp; 功能包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p town_ws/src</span><br><span class="line"><span class="built_in">cd</span> town_ws/src</span><br><span class="line">ros2 pkg create village_wang --build-type ament_cmake --dependencies rclcpp</span><br></pre></td></tr></table></figure>
<p>创建完成的目录结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709953867147-9f288dcf-5e47-4151-9465-e4418685f654.png#averageHue=%23300a24&clientId=u7f35f781-53fd-4&from=drop&id=ua3e86124&originHeight=118&originWidth=212&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=7896&status=done&style=none&taskId=u4fdf03cc-db2e-4232-9a0f-487eae2ca95&title=" alt="image-20210727193256467.png"><br><a name="XZHy1"></a></p>
<h3 id="POP方式编写节点"><a href="#POP方式编写节点" class="headerlink" title="POP方式编写节点"></a>POP方式编写节点</h3><p>在village_wang&#x2F;src中创建wang2.cpp</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;rclcpp/rclcpp.hpp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    /*初始化rclcpp</span><br><span class="line">    rclcpp::init(argc, argv);</span><br><span class="line">    /*产生一个Wang2的节点*/</span><br><span class="line">    auto node = std::make_shared&lt;rclcpp::Node&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    // 打印一句自我介绍</span><br><span class="line">    RCLCPP_INFO(node-&gt;get_logger(), <span class="string">&quot;大家好，我是单身狗wang2.&quot;</span>);</span><br><span class="line">    /* 运行节点，并检测退出信号*/</span><br><span class="line">    rclcpp::spin(node);</span><br><span class="line">    rclcpp::shutdown();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主函数中首先初始化rclcpp，然后新建了一个Node节点的对象，命名为wang2，接着使用rclcpp让这个节点暴露在外面，并检测退出信号（Ctrl+C），检测到退出信号后，就会执行rcl.shutdown()关闭节点。<br><a name="FGd6F"></a></p>
<h4 id="添加到cmakelists"><a href="#添加到cmakelists" class="headerlink" title="添加到cmakelists"></a>添加到cmakelists</h4><p>在CmakeLists.txt最后一行加入下面两行代码。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">add<span class="constructor">_executable(<span class="params">wang2_node</span> <span class="params">src</span><span class="operator">/</span><span class="params">wang2</span>.<span class="params">cpp</span>)</span></span><br><span class="line">ament<span class="constructor">_target_dependencies(<span class="params">wang2_node</span> <span class="params">rclcpp</span>)</span></span><br></pre></td></tr></table></figure>
<p>添加这两行代码的目的是让编译器编译wang2.cpp这个文件，不然不会主动编译。接着在上面两行代码下面添加下面的代码。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  wang2_node</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个是C++比Python要麻烦的地方，需要手动将编译好的文件安装到install&#x2F;village_wang&#x2F;lib&#x2F;village_wang下.<br><a name="WfmFe"></a></p>
<h4 id="编译运行："><a href="#编译运行：" class="headerlink" title="编译运行："></a>编译运行：</h4><p>打开vscode终端，进入town_ws<br><a name="Z1Ujk"></a></p>
<h3 id="编译节点"><a href="#编译节点" class="headerlink" title="编译节点"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.6.2POP%E6%96%B9%E6%B3%95%E7%BC%96%E5%86%99C++%E8%8A%82%E7%82%B9%E5%B9%B6%E6%B5%8B%E8%AF%95?id=%e7%bc%96%e8%af%91%e8%8a%82%e7%82%b9">编译节点</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build</span><br></pre></td></tr></table></figure>
<p><a name="FFV99"></a></p>
<h3 id="source环境"><a href="#source环境" class="headerlink" title="source环境"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.6.2POP%E6%96%B9%E6%B3%95%E7%BC%96%E5%86%99C++%E8%8A%82%E7%82%B9%E5%B9%B6%E6%B5%8B%E8%AF%95?id=source%e7%8e%af%e5%a2%83">source环境</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> install/setup.bash</span><br></pre></td></tr></table></figure>
<p><a name="xqzlR"></a></p>
<h3 id="运行节点"><a href="#运行节点" class="headerlink" title="运行节点"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.6.2POP%E6%96%B9%E6%B3%95%E7%BC%96%E5%86%99C++%E8%8A%82%E7%82%B9%E5%B9%B6%E6%B5%8B%E8%AF%95?id=%e8%bf%90%e8%a1%8c%e8%8a%82%e7%82%b9">运行节点</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run village_wang wang2_node</span><br></pre></td></tr></table></figure>
<p>不出意外，你可以看到王二的自我介绍。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709954465823-94f63561-dbe0-4ac6-90a6-3e3720ef2823.png#averageHue=%231f1d1c&clientId=u7f35f781-53fd-4&from=drop&id=ucbef2116&originHeight=317&originWidth=644&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=105682&status=done&style=none&taskId=u3d85a105-b651-4405-8a1d-378ebd2cea7&title=" alt="a85481a9b56ae5cf6bee46a440140235.png"><br />当节点运行起来后，使用ros2 node list 指令来查看现有的节点。<img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709954606260-0bd6726b-4a2b-4717-bf95-eba0cac67750.png#averageHue=%23363534&clientId=u7f35f781-53fd-4&from=drop&id=u21cafeca&originHeight=68&originWidth=437&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=14564&status=done&style=none&taskId=ubda76a82-e9ab-43e9-943a-dd83f8acea4&title=" alt="972b7669eb967a31c2a0d959b7301ad9.png"><br><a name="MJsrM"></a></p>
<h2 id="OPP方式编写节点"><a href="#OPP方式编写节点" class="headerlink" title="OPP方式编写节点"></a>OPP方式编写节点</h2><p>还是在wang2.cpp输入代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个类节点，名字叫做SingleDogNode,继承自Node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleDogNode</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数,有一个参数为节点名称</span></span><br><span class="line"><span class="built_in">SingleDogNode</span>(std::string name) : <span class="built_in">Node</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印一句自我介绍</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好，我是单身狗%s.&quot;</span>,name.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">/*产生一个Wang2的节点*/</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;SingleDogNode&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    <span class="comment">/* 运行节点，并检测退出信号*/</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="mRwWY"></a></p>
<h3 id="修改cmakelists-运行"><a href="#修改cmakelists-运行" class="headerlink" title="修改cmakelists&amp;&amp;运行"></a>修改cmakelists&amp;&amp;运行</h3><p>同上，不多赘述<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709965221810-a121ef27-b3a9-42f7-a674-f23eee0c3e3b.png#averageHue=%231d1d1c&clientId=u488a9513-274b-4&from=drop&id=u35b36f1c&originHeight=1344&originWidth=1108&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=230404&status=done&style=none&taskId=u6451a532-fc8b-4701-8e02-2a8ab5680a6&title=" alt="8014891cb75b9e90255db630b7115fad.png"><br />运行成功。<br><a name="zvknJ"></a></p>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>鱼香教程里的举例实在是难以忘却，这里我cv过来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这里的王二和李四两个节点，通过话题来互相通信（传递数据）。</span><br><span class="line"></span><br><span class="line">李四节点会创建一个发布者（Publisher）来发布一个话题（艳娘传奇,小鱼取个英文名叫sexy_girl）。单身汉王二节点，他创建了一个订阅者（Subscriber）来订阅李四发布的话题sexy_girl。</span><br><span class="line"></span><br><span class="line">那艳娘传奇的内容是什么呢？我们暂且规定为由文字组成的字符串（连插图都没的那种）。</span><br><span class="line"></span><br><span class="line">[object Promise]</span><br><span class="line">李四王二通信模型是一个一对一（一个发布者，一个订阅者）的模型，除此之外ROS2中话题通信其实还可以是1对n,n对1,n对n的。</span><br></pre></td></tr></table></figure>
<p><a name="HgXzG"></a></p>
<h3 id="话题通讯"><a href="#话题通讯" class="headerlink" title="话题通讯"></a>话题通讯</h3><p><a name="jWcs8"></a></p>
<h4 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h4><ul>
<li>话题名字是关键,发布订阅接口类型要相同，发布的是字符串，接受也要用字符串来接收;</li>
<li>同一个人(节点)可以订阅多个话题，同时也可以发布多个话题，就像一本书的作者也可以是另外一本书的读者;</li>
<li>同一个小说不能有多个作者（版权问题），但跟小说不一样，同一个话题可以有多个发布者。<br><a name="YaREO"></a></li>
</ul>
<h4 id="相关工具："><a href="#相关工具：" class="headerlink" title="相关工具："></a>相关工具：</h4><p><a name="FnJns"></a></p>
<h5 id="rqt-graph"><a href="#rqt-graph" class="headerlink" title="rqt_graph:"></a>rqt_graph:</h5><p>ROS2作为一个强大的工具，在运行过程中，我们是可以通过命令来看到节点和节点之间的数据关系的。<img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709972464260-688eb5ba-8779-4843-ad42-7a00609803f8.png#averageHue=%23e9e9e8&clientId=ud645a189-b8aa-4&from=drop&id=ud5918dcf&originHeight=591&originWidth=761&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=53857&status=done&style=none&taskId=u304193b0-36aa-4ccc-9cbe-cdec436b6b7&title=" alt="image-20210803113450234.png"></p>
<p><a name="Cm70r"></a></p>
<h5 id="命令行界面——CLI"><a href="#命令行界面——CLI" class="headerlink" title="命令行界面——CLI"></a>命令行界面——CLI</h5><p>返回系统活动所有主题列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic list</span><br></pre></td></tr></table></figure>
<p>增加消息类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic list -t</span><br></pre></td></tr></table></figure>
<p>打印实时话题内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic <span class="built_in">echo</span> /chatter</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看主题信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic info  /chatter</span><br></pre></td></tr></table></figure>
<p>查看消息类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 interface show std_msgs/msg/String</span><br></pre></td></tr></table></figure>
<p>手动发布命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic pub /chatter std_msgs/msg/String <span class="string">&#x27;data: &quot;123&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><a name="B7agU"></a></p>
<h3 id="c-实现"><a href="#c-实现" class="headerlink" title="c++实现"></a>c++实现</h3><p>创建话题订阅者的一般流程：</p>
<ol>
<li>导入订阅的话题接口类型</li>
<li>创建订阅回调函数</li>
<li>声明并创建订阅者</li>
<li>编写订阅回调处理逻辑<br><a name="vIZWC"></a></li>
</ol>
<h3 id="王三"><a href="#王三" class="headerlink" title="王三"></a>王三</h3><ul>
<li><p>将wang2.cpp代码修改如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;rclcpp/rclcpp.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;std_msgs/msg/string.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;std_msgs/msg/u_int32.hpp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using std::placeholders::_1;</span><br><span class="line">using std::placeholders::_2;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    创建一个类节点，名字叫做SingleDogNode,继承自Node.</span><br><span class="line">*/</span><br><span class="line">class SingleDogNode : public rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 构造函数,有一个参数为节点名称</span><br><span class="line">    SingleDogNode(std::string name) : Node(name)</span><br><span class="line">    &#123;</span><br><span class="line">        // 打印一句自我介绍</span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;大家好，我是单身狗%s.&quot;</span>, name.c_str());</span><br><span class="line">         // 创建一个订阅者来订阅李四写的小说，通过名字sexy_girl</span><br><span class="line">        sub_novel = this-&gt;create_subscription&lt;std_msgs::msg::String&gt;(<span class="string">&quot;sexy_girl&quot;</span>, 10, std::<span class="built_in">bind</span>(&amp;SingleDogNode::topic_callback, this, _1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // 声明一个订阅者（成员变量）,用于订阅小说</span><br><span class="line">    rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr sub_novel;</span><br><span class="line"></span><br><span class="line">    // 收到话题数据的回调函数</span><br><span class="line">    void topic_callback(const std_msgs::msg::String::SharedPtr msg)</span><br><span class="line">    &#123;</span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;朕已阅：&#x27;%s&#x27;&quot;</span>, msg-&gt;data.c_str());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    rclcpp::init(argc, argv);</span><br><span class="line">    /*产生一个Wang2的节点*/</span><br><span class="line">    auto node = std::make_shared&lt;SingleDogNode&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    /* 运行节点，并检测退出信号*/</span><br><span class="line">    rclcpp::spin(node);</span><br><span class="line">    rclcpp::shutdown();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用C++订阅话题，需要添加对应的消息类型头文件：</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &quot;<span class="string">std_msgs</span>/<span class="string">msg</span>/<span class="string">string.hpp</span>&quot;</span></span><br><span class="line"><span class="meta">#include &quot;<span class="string">std_msgs</span>/<span class="string">msg</span>/<span class="string">u_int</span>32.<span class="string">hpp</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>创建订阅者和发布者时依然使用this-&gt;create_subscription和this-&gt;create_publisher方法。<br />C++中创建一个订阅者，需要传入话题类型、话题名称、所要绑定的回调函数，以及通信Qos.<br /><strong>std::bind()</strong><br /><strong>C++的类成员函数不能像普通函数那样用于回调，因为每个成员函数都需要有一个对象实例去调用它。 通常情况下，要实现成员函数作为回调函数：一种过去常用的方法就是把该成员函数设计为静态成员函数（因为类的成员函数需要隐含的this指针 而回调函数没有办法提供），但这样做有一个缺点，就是会破坏类的结构性，因为静态成员函数只能访问该类的静态成员变量和静态成员函数，不能访问非静态的，要解决这个问题，可以把对象实例的指针或引用做为参数传给它。 后面就可以靠这个对象实例的指针或引用访问非静态成员函数。另一种办法就是使用std::bind和std::function结合实现回调技术。(目前还看不太懂)</strong></p>
</li>
<li><p>编译运行</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">colcon <span class="keyword">build</span> --packages-<span class="keyword">select</span> village_wang</span><br></pre></td></tr></table></figure>
</li>
<li><p>source运行<br><a name="KES9k"></a></p>
</li>
</ul>
<h3 id="李四"><a href="#李四" class="headerlink" title="李四"></a>李四</h3><p>突然发现李四的源码在教程里没有，自己搓了个试试。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个小说内容的数组</span></span><br><span class="line">std::string novel[] = &#123;</span><br><span class="line"><span class="string">&quot;第一回：潋滟湖 1 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第二回：潋滟湖 2 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第三回：潋滟湖 3 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第四回：潋滟湖 4 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第五回：潋滟湖 5 次偶遇胡艳娘&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个小说内容的索引</span></span><br><span class="line"><span class="type">int</span> nb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个类节点，名字叫做WriterNode,继承自Node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriterNode</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数,有一个参数为节点名称</span></span><br><span class="line"><span class="built_in">WriterNode</span>(std::string name) : <span class="built_in">Node</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印一句自我介绍</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好，我是%s,我是一名作家！&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 创建一个发布者来发布小说内容，通过名字sexy_girl</span></span><br><span class="line">    pub_novel = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;std_msgs::msg::String&gt;(<span class="string">&quot;sexy_girl&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 创建一个定时器，每隔五秒发布一章小说内容</span></span><br><span class="line">    timer = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>), std::<span class="built_in">bind</span>(&amp;WriterNode::timer_callback, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 声明一个发布者（成员变量）,用于发布小说内容</span></span><br><span class="line">rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr pub_novel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个定时器（成员变量）,用于定时发布小说内容</span></span><br><span class="line">rclcpp::TimerBase::SharedPtr timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器触发的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 新建一个小说内容的消息</span></span><br><span class="line">    std_msgs::msg::String novel_msg;</span><br><span class="line">    <span class="comment">// 判断小说内容的索引是否超出数组范围</span></span><br><span class="line">    <span class="keyword">if</span> (nb &lt; <span class="built_in">sizeof</span>(novel) / <span class="built_in">sizeof</span>(novel[<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取小说内容</span></span><br><span class="line">        novel_msg.data = novel[nb];</span><br><span class="line">        <span class="comment">// 发布小说内容</span></span><br><span class="line">        pub_novel-&gt;<span class="built_in">publish</span>(novel_msg);</span><br><span class="line">        <span class="comment">// 打印发布的小说内容</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;发布小说内容：%s&quot;</span>, novel_msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 小说内容的索引加一</span></span><br><span class="line">        nb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 小说内容已经发布完毕，取消定时器</span></span><br><span class="line">        timer-&gt;<span class="built_in">cancel</span>();</span><br><span class="line">        <span class="comment">// 打印结束语</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;小说已经完结，感谢大家的支持！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv); <span class="comment">// 初始化rclcpp</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;WriterNode&gt;(<span class="string">&quot;li4&quot;</span>); <span class="comment">// 新建一个节点</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node); <span class="comment">// 保持节点运行，检测是否收到退出指令（Ctrl+C）</span></span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>(); <span class="comment">// 关闭rclcpp</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用Ctrl+Shift+5切分一个终端出来，输入下面命令：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">source install/setup.bash </span><br><span class="line">ros2 run  village_li  li4_node</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709973381445-1adfa01f-8fab-4b2e-862b-37be052c45b0.png#averageHue=%232e2e2e&clientId=ud645a189-b8aa-4&from=drop&id=u0011d78d&originHeight=243&originWidth=1362&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=120502&status=done&style=none&taskId=u430b4fc9-7dae-41d0-813a-b956f4cda2a&title=" alt="image-20210804074600329.png"><br><a name="ffgNa"></a></p>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>C++中创建一个发布者也比较简单，使用this-&gt;create_publisher即可创建一个发布者。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">pub_</span> = this-&gt;create_publisher&lt;std_msgs::msg::UInt32&gt;(<span class="string">&quot;sexy_girl_money&quot;</span>,<span class="number">10</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这里提供了三个参数，分别是该发布者要发布的话题名称（sexy_girl_money）、发布者要发布的话题类型（std_msgs::msg::UInt32）、Qos（10）<br><a name="hnt3J"></a></p>
<h3 id="服务和接口"><a href="#服务和接口" class="headerlink" title="服务和接口"></a>服务和接口</h3><p><a name="RpsO0"></a></p>
<h3 id="接口：接口其实是一种规范"><a href="#接口：接口其实是一种规范" class="headerlink" title="接口：接口其实是一种规范"></a>接口：接口其实是一种规范</h3><p>当接口类型统一的时候，适配显然就不是问题了，大家的服务和响应都是一致的规范格式<br><a name="MYwEG"></a></p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><a name="eTGJG"></a></p>
<h5 id="查看接口列表（当前环境下）"><a href="#查看接口列表（当前环境下）" class="headerlink" title="查看接口列表（当前环境下）"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_41%e6%9f%a5%e7%9c%8b%e6%8e%a5%e5%8f%a3%e5%88%97%e8%a1%a8%ef%bc%88%e5%bd%93%e5%89%8d%e7%8e%af%e5%a2%83%e4%b8%8b%ef%bc%89">查看接口列表（当前环境下）</a></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 interface list</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811318-9c2e1b9d-119d-4c2d-80ee-8b9effa311de.png#averageHue=%23282828&clientId=ud3f5d7d5-6e8f-4&from=paste&id=u6b0684ac&originHeight=366&originWidth=700&originalType=url&ratio=1.5625&rotation=0&showTitle=false&status=done&style=none&taskId=ueea0a066-269f-4a44-908b-66eff688a8a&title="><br><a name="gfepk"></a></p>
<h5 id="查看所有接口包"><a href="#查看所有接口包" class="headerlink" title="查看所有接口包"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_42%e6%9f%a5%e7%9c%8b%e6%89%80%e6%9c%89%e6%8e%a5%e5%8f%a3%e5%8c%85">查看所有接口包</a></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 interface packages</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811026-b7326182-2b56-499b-bf97-5580abcd8c68.png#averageHue=%23252525&clientId=ud3f5d7d5-6e8f-4&from=paste&id=uc9cacca0&originHeight=500&originWidth=444&originalType=url&ratio=1.5625&rotation=0&showTitle=false&status=done&style=none&taskId=uba98428e-3d16-4193-926e-7b18b031853&title="><br><a name="EDlMf"></a></p>
<h5 id="查看某一个包下的所有接口"><a href="#查看某一个包下的所有接口" class="headerlink" title="查看某一个包下的所有接口"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_43%e6%9f%a5%e7%9c%8b%e6%9f%90%e4%b8%80%e4%b8%aa%e5%8c%85%e4%b8%8b%e7%9a%84%e6%89%80%e6%9c%89%e6%8e%a5%e5%8f%a3">查看某一个包下的所有接口</a></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 interface package std_msgs</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811203-ae44eadd-e3cf-41ce-8f6e-17452d028e89.png#averageHue=%23262626&clientId=ud3f5d7d5-6e8f-4&from=paste&id=u11110c34&originHeight=246&originWidth=669&originalType=url&ratio=1.5625&rotation=0&showTitle=false&status=done&style=none&taskId=ue6b53307-54e5-482e-9233-ae6dfa80bfa&title="><br><a name="kgaGi"></a></p>
<h5 id="查看某一个接口详细的内容"><a href="#查看某一个接口详细的内容" class="headerlink" title="查看某一个接口详细的内容"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_44%e6%9f%a5%e7%9c%8b%e6%9f%90%e4%b8%80%e4%b8%aa%e6%8e%a5%e5%8f%a3%e8%af%a6%e7%bb%86%e7%9a%84%e5%86%85%e5%ae%b9">查看某一个接口详细的内容</a></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 interface show std_msgs/msg/String</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811860-73d814e9-0ad4-4f3c-8b03-cc84d50b8e00.png#averageHue=%23292929&clientId=ud3f5d7d5-6e8f-4&from=paste&id=uff812660&originHeight=114&originWidth=764&originalType=url&ratio=1.5625&rotation=0&showTitle=false&status=done&style=none&taskId=ufbd1877f-055c-45bb-b469-d1c4c124258&title="><br><a name="YVXNq"></a></p>
<h5 id="输出某一个接口所有属性"><a href="#输出某一个接口所有属性" class="headerlink" title="输出某一个接口所有属性"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_45-%e8%be%93%e5%87%ba%e6%9f%90%e4%b8%80%e4%b8%aa%e6%8e%a5%e5%8f%a3%e6%89%80%e6%9c%89%e5%b1%9e%e6%80%a7">输出某一个接口所有属性</a></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 interface proto sensor_msgs/msg/Image</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811870-5f07a163-7673-4f56-a3c5-337c13939d9a.png#averageHue=%23212121&clientId=ud3f5d7d5-6e8f-4&from=paste&id=u9b08528d&originHeight=208&originWidth=611&originalType=url&ratio=1.5625&rotation=0&showTitle=false&status=done&style=none&taskId=uf0315698-41a2-4e5e-b260-a5dff7aa66e&title="></p>
<p><a name="PJTRk"></a></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>显然，服务和话题的区别在于话题是没有返回的，只是单向的数据传递。而服务是双向的客户端发送，服务端响应。<br><a name="JJ4MV"></a></p>
<h3 id="自定义话题接口"><a href="#自定义话题接口" class="headerlink" title="自定义话题接口"></a>自定义话题接口</h3><ul>
<li>新建工作空间</li>
</ul>
<p>在town_ws的src文件夹下，运行下面的指令，即可完成village_interfaces功能包的创建。    <br /> 	<strong>注意，这里包的编译类型我们使用ament_cmake方式。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 pkg create village_interfaces --build-type ament_cmake </span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710037304935-3b720491-175f-421f-b8b8-cd410932ca33.png#averageHue=%23212121&clientId=ud3f5d7d5-6e8f-4&from=drop&id=u0e50a9c7&originHeight=179&originWidth=503&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=15650&status=done&style=none&taskId=u951c0305-6102-4c35-885a-e55d3f3c93b&title=" alt="image-20210809151545012.png"></p>
<ul>
<li>新建msg文件和Novel.msg（小说消息）</li>
</ul>
<p><strong>注意:msg文件开头首字母一定要大写，ROS2强制要求，盲猜应该是为了和类名保持一致</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cd village_interfaces</span><br><span class="line">mkdir msg</span><br><span class="line">touch Novel.msg </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>编写Novel.msg内容</li>
</ul>
<p>我们的目的是给李四的小说每一章增加一张图片，原来李四写小说是对外发布一个std_msgs&#x2F;msg&#x2F;String字符串类型的数据。<br />而发布图片的格式，我们需要采用ros自带的传感器消息接口中的图片sensor_msgs&#x2F;msg&#x2F;Image数据类型，所以我们新的消息文件的内容就是将两者合并，在ROS2中可以写做这样：<br /><strong>在msg文件中可以使用#号添加注释。</strong></p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="type">#</span> 标准消息接口<span class="type">std_msgs</span>下的<span class="built_in">String</span>类型</span><br><span class="line"><span class="type">std_msgs</span><span class="operator">/</span><span class="built_in">String</span> <span class="variable">content</span></span><br><span class="line"><span class="type">#</span> 图像消息，调用<span class="type">sensor_msgs</span>下的<span class="built_in">Image</span>类型</span><br><span class="line"><span class="type">sensor_msgs</span><span class="operator">/</span><span class="built_in">Image</span> <span class="variable">image</span></span><br></pre></td></tr></table></figure>
<p>这种组合结构图如下：<br />[object Promise]<br />这个图一共三层，第一层是消息定义层，第二层是ROS2已有的std_msgs,sensor_msgs，其组成关系是由下一层组合成上一层。<br />最下面一层string、uint8、uint32是ROS2中的原始数据类型，原始数据类型有下面几种，ROS2中所有的接口都是由这些原始数据类型组成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="type">byte</span></span><br><span class="line">char</span><br><span class="line"><span class="type">float32</span>,<span class="type">float64</span></span><br><span class="line"><span class="type">int8</span>,<span class="type">uint8</span></span><br><span class="line"><span class="type">int16</span>,<span class="type">uint16</span></span><br><span class="line"><span class="type">int32</span>,<span class="type">uint32</span></span><br><span class="line"><span class="type">int64</span>,<span class="type">uint64</span></span><br><span class="line"><span class="type">string</span></span><br></pre></td></tr></table></figure>


<ul>
<li>Another way</li>
</ul>
<p>我们不使用std_msgs&#x2F;String 而是直接使用最下面一层的string。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接使用ROS2原始的数据类型</span></span><br><span class="line"><span class="built_in">string</span> content</span><br><span class="line"><span class="comment"># 图像消息，调用sensor_msgs下的Image类型</span></span><br><span class="line">sensor_msgs/Image image</span><br></pre></td></tr></table></figure>

<ul>
<li>说明</li>
</ul>
<p>如何知道，std_msgs&#x2F;String是由基础数据类型string组成的，其实可以通过下面的指令来查看</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ros2 <span class="keyword">interface</span> <span class="symbol">show</span> <span class="symbol">std_msgs</span>/<span class="symbol">msg</span>/<span class="symbol">String</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">string</span> <span class="class"><span class="keyword">data</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>原来std_msgs的String就是包含一个叫变量名为data的string类型变量，这也是在4.2和4.3章节中代码要用.data才能拿到真正的数据的原因：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> <span class="built_in">String</span></span><br><span class="line">msg = <span class="built_in">String</span>()</span><br><span class="line">msg.data = <span class="string">&#x27;第%d回：潋滟湖 %d 次偶遇胡艳娘&#x27;</span> % (self.i,self.i)</span><br><span class="line"><span class="comment"># msg 是 std_msgs.msg.String() 的对象</span></span><br><span class="line"><span class="comment"># msg.data data是string类型的对象，其定义是string data</span></span><br></pre></td></tr></table></figure>
<p>最终Novel.msg</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接使用ROS2原始的数据类型</span></span><br><span class="line"><span class="built_in">string</span> content</span><br><span class="line"><span class="comment"># 图像消息，调用sensor_msgs下的Image类型</span></span><br><span class="line">sensor_msgs/Image image</span><br></pre></td></tr></table></figure>

<ul>
<li>修改Cmakelists.txt</li>
</ul>
<p>完成了代码的编写还不够，我们还需要在CMakeLists.txt中告诉编译器，你要给我把Novel.msg转换成Python库和C++的头文件。<br />直接添加下面的代码到CMakeLists.txt即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#添加对sensor_msgs的</span><br><span class="line"><span class="built_in">find_package</span>(sensor_msgs REQUIRED)</span><br><span class="line"><span class="built_in">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line">#添加消息文件和依赖</span><br><span class="line"><span class="built_in">rosidl_generate_interfaces</span>($&#123;PROJECT_NAME&#125;</span><br><span class="line"><span class="string">&quot;msg/Novel.msg&quot;</span></span><br><span class="line">    DEPENDENCIES sensor_msgs</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>find_package用于查找rosidl_default_generators位置，下面rosidl_generate_interfaces就是声明msg文件所属的工程名字、文件位置以及依赖DEPENDENCIES。<br /><strong>踩坑报告：</strong></p>
<ul>
<li><strong>重点强调一下依赖部分DEPENDENCIES，我们消息中用到的依赖这里必须写上，即使不写编译器也不会报错，直到运行的时候才会出错。</strong></li>
<li><strong>而且rosidl_generate_interfaces()</strong> 函数必须在 <strong>ament_package()</strong> 函数之前调用。</li>
</ul>
<p>代码大概是这样的<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710038380883-6becece5-b4cd-4c3d-bc11-cdcffa9dcf1d.png#averageHue=%23201f1f&clientId=ud3f5d7d5-6e8f-4&from=drop&id=ua4ec7301&originHeight=843&originWidth=1469&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=471267&status=done&style=none&taskId=u795fc122-a6a1-4427-9f9d-d20f8507983&title=" alt="e3877412c40448c0995ba2884a1ae7c1.png"></p>
<ul>
<li>修改package.xml</li>
</ul>
<p>修改village_interfaces目录下的package.xml，添加下面三行代码，为工程添加一下所需的依赖。<br /><strong>这里其实不添加也可以</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>sensor_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rosidl_default_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码位置：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710037769727-982ef5d8-77a3-446a-9035-8861ead0bf4e.png#averageHue=%23201f1f&clientId=ud3f5d7d5-6e8f-4&from=drop&id=u06f1f241&originHeight=492&originWidth=1099&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=105921&status=done&style=none&taskId=u1930cd93-9480-4455-b99b-a9971abac6c&title=" alt="image-20210816145202732.png"></p>
<ul>
<li>编译</li>
</ul>
<p>回到town_ws</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">colcon <span class="keyword">build</span> --packages-<span class="keyword">select</span> village_interfaces</span><br></pre></td></tr></table></figure>

<ul>
<li>验证</li>
</ul>
<p>过上节课说过的ros2 interface常用的命令来测试。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">source install/setup.bash </span><br><span class="line">ros2 <span class="keyword">interface</span> <span class="symbol">package</span> <span class="symbol">village_interfaces</span>  #查看包下所有接口</span><br><span class="line"><span class="symbol">ros2</span> <span class="symbol">interface</span> <span class="symbol">show</span> <span class="symbol">village_interfaces</span>/<span class="symbol">msg</span>/<span class="symbol">Novel</span> #查看内容</span><br><span class="line"><span class="symbol">ros2</span> <span class="symbol">interface</span> <span class="symbol">proto</span> <span class="symbol">village_interfaces</span>/<span class="symbol">msg</span>/<span class="symbol">Novel</span> #显示属性</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="zucuy"></a></p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710037813556-ec2ce503-73b2-4496-ad09-0d176cf48bdb.png#averageHue=%23242424&clientId=ud3f5d7d5-6e8f-4&from=drop&id=u580048f1&originHeight=367&originWidth=751&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=58470&status=done&style=none&taskId=u39622192-29e6-41b5-9414-a9b8c7ed920&title=" alt="image-20210816145503946.png"></h3><p>我们可以在运行结果中看到，Novel的消息内容是由content数据和传感器数据image共同组成的了。</p>
<p><a name="vtOSp"></a></p>
<h3 id="服务："><a href="#服务：" class="headerlink" title="服务："></a>服务：</h3><ul>
<li>服务：客户端发送请求给服务端，服务端可以根据客户端的请求做一些处理，然后返回结果给客户端。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/gif/39221021/1710035790713-136e7676-715a-48d2-92ad-41e569c869f1.gif#averageHue=%23fcf9fd&clientId=ud3f5d7d5-6e8f-4&from=drop&id=PMpbD&originHeight=480&originWidth=854&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=380270&status=done&style=none&taskId=u365753d7-dbb5-4e03-9548-c451b5f740a&title=" alt="Service-SingleServiceClient.gif"><br /><img src="https://cdn.nlark.com/yuque/0/2024/gif/39221021/1710035797325-0dfe07bb-99eb-4afc-9625-737c1827a667.gif#averageHue=%2394a2cc&clientId=ud3f5d7d5-6e8f-4&from=drop&id=mTDBy&originHeight=480&originWidth=854&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=898464&status=done&style=none&taskId=u4ef526f9-0e06-43be-ab48-beff9eb1ad0&title=" alt="Service-MultipleServiceClient.gif"></p>
<p>下面操作一下ros2自带的样例服务：<br><a name="ZLIvy"></a></p>
<h4 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h4><p>运行一个服务节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 run examples_rclpy_minimal_service service</span><br><span class="line"><span class="comment">//服务的功能是将两个数字相加，给定a，b两个数，返回sum也就是ab之和</span></span><br></pre></td></tr></table></figure>
<p><a name="OhYmw"></a></p>
<h5 id="查看服务列表"><a href="#查看服务列表" class="headerlink" title="查看服务列表"></a>查看服务列表</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 service list</span><br></pre></td></tr></table></figure>
<p><a name="ZNyUa"></a></p>
<h5 id="手动调用服务（一定要注意a：-b-的空格）"><a href="#手动调用服务（一定要注意a：-b-的空格）" class="headerlink" title="手动调用服务（一定要注意a：  b: 的空格）"></a>手动调用服务（一定要注意a：  b: 的空格）</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts <span class="string">&quot;&#123;a: 5,b: 10&#125;&quot;</span></span><br><span class="line"><span class="comment">//需要再启动一个终端</span></span><br></pre></td></tr></table></figure>
<p><a name="RHF6C"></a></p>
<h5 id="查看服务接口类型"><a href="#查看服务接口类型" class="headerlink" title="查看服务接口类型"></a>查看服务接口类型</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 service type /add_two_ints</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="AIADv"></a></p>
<h5 id="查找使用某一接口的服务"><a href="#查找使用某一接口的服务" class="headerlink" title="查找使用某一接口的服务"></a>查找使用某一接口的服务</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 service find example_interfaces/srv/AddTwoInts</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="X9wyU"></a></p>
<h4 id="自定义服务接口"><a href="#自定义服务接口" class="headerlink" title="自定义服务接口"></a>自定义服务接口</h4><p>我们来看一下服务的消息接口长什么样子？<br />服务接口格式：xxx.srv</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">int64 a</span><br><span class="line"><span class="section">int64 b</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure>
<p>与话题不同的是，srv文件比msg文件中间多出了三个—这三个杠杠就是分界线，上方的是客户端发送请求的数据结构定义，下方的是服务端响应结果的数据结构定义。<br />参考下面的步骤：</p>
<ul>
<li>新建srv文件夹，并在文件夹下新建xxx.srv</li>
<li>在xxx.srv下编写服务接口内容并保存</li>
<li>在CmakeLists.txt添加依赖和srv文件目录</li>
<li>在package.xml中添加xxx.srv所需的依赖</li>
<li>编译功能包即可生成python与c++头文件</li>
</ul>
<p>当然在做上面的步骤之前，我们还需要做一件很重要的事情。就是根据业务需求，确定好请求的数据结构和返回的数据结构。我们依然是在village_interfaces下创建服务接口。<br />开始之前，我们先根据李四的需求来确定数据结构。<br />上一节中李四对借钱的要求如下：</p>
<ol>
<li>借钱一定要打欠条，收到欠条才能给钱</li>
<li>每次借钱不能超过自己全部资金的10%且一定是整数，也就是说李四假如现在有100块钱，那么最多借出去100x10%&#x3D;10块钱</li>
</ol>
<p>总结一下就是，李三发送借钱请求的时候一定要有欠条，我们想一下，欠条中应该至少包含两条信息</p>
<ul>
<li>借钱者名字，字符串类型、可以用string表示</li>
<li>金额，整形，可以用uint32表示</li>
</ul>
<p>那请求的数据结构我们就可以确定下来了，接着确定返回的数据的格式。<br />既然是借钱，那李四就有可能拒绝，会有借钱失败的情况，所以返回数据应该有这两条信息：</p>
<ul>
<li>是否出借：只有成功和失败两种情况，布尔类型（bool）可表示</li>
<li>出借金额：无符号整形，可以用uint32表示，借钱失败时为0。<br><a name="SOi0x"></a></li>
</ul>
<h5 id="创建srv文件夹及BorrowMoney-srv消息文件"><a href="#创建srv文件夹及BorrowMoney-srv消息文件" class="headerlink" title="创建srv文件夹及BorrowMoney.srv消息文件"></a>创建srv文件夹及BorrowMoney.srv消息文件</h5><p>在village_interfaces下新建srv文件夹<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710038764606-c8035912-d3b5-4a18-8758-978165a7a504.png#averageHue=%23222222&clientId=ud3f5d7d5-6e8f-4&from=drop&id=u87e80afd&originHeight=160&originWidth=471&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=14984&status=done&style=none&taskId=u6fcc9d9a-d569-433f-86c9-0a6ed8b969f&title=" alt="image-20210811162010736.png"><br><a name="yxyCD"></a></p>
<h5 id="编写文件内容"><a href="#编写文件内容" class="headerlink" title="编写文件内容"></a>编写文件内容</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string name</span><br><span class="line">uint32 money</span><br><span class="line">---</span><br><span class="line"><span class="type">bool</span> success</span><br><span class="line">uint32 money</span><br></pre></td></tr></table></figure>
<p><a name="efh5K"></a></p>
<h5 id="修改Cmakelists-txt"><a href="#修改Cmakelists-txt" class="headerlink" title="修改Cmakelists.txt"></a>修改Cmakelists.txt</h5><p>我们已经添加过依赖DEPENDENCIES和msg文件了，所以这里我们直接添加一个srv即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line"><span class="built_in">rosidl_generate_interfaces</span>($&#123;PROJECT_NAME&#125;</span><br><span class="line">  #---msg---</span><br><span class="line">  <span class="string">&quot;msg/Novel.msg&quot;</span></span><br><span class="line">  #---srv---</span><br><span class="line">  <span class="string">&quot;srv/BorrowMoney.srv&quot;</span></span><br><span class="line">  DEPENDENCIES sensor_msgs</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
<p>需要关注的是这一行”srv&#x2F;BorrowMoney.srv”,添加了对应的文件位置。</p>
<ul>
<li>踩坑：在rosidl_generate_interfaces()函数中传递了一个依赖项sensor_msgs，但是在使用find_package()函数之前没有找到它。需要在CMakeLists.txt 文件中添加find_package(sensor_msgs REQUIRED)，以确保 <strong>sensor_msgs</strong> 包被正确地找到和链接。<br><a name="io4wO"></a></li>
</ul>
<h5 id="修改package-xml"><a href="#修改package-xml" class="headerlink" title="修改package.xml"></a>修改package.xml</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;build_depend&gt;sensor_msgs&lt;/build_depend&gt;</span><br><span class="line">&lt;build_depend&gt;rosidl_default_generators&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt;</span><br><span class="line">&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="Ink82"></a></p>
<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select village_interfaces</span><br></pre></td></tr></table></figure>
<p><a name="lVN2C"></a></p>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>这次测试我们依然使用ros2 interface指令进行测试。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">source install/setup.bash </span><br><span class="line">ros2 interface package village_interfaces</span><br><span class="line">ros2 interface show village_interfaces/srv/BorrowMoney</span><br><span class="line">ros2 interface proto village_interfaces/srv/BorrowMoney </span><br></pre></td></tr></table></figure>
<p><a name="uONPm"></a></p>
<h4 id="服务的c-实现"><a href="#服务的c-实现" class="headerlink" title="服务的c++实现"></a>服务的c++实现</h4><p><strong>一句话：张三拿多少钱钱给王二，王二凑够多少个章节的艳娘传奇给他，可参考以下步骤</strong></p>
<ol>
<li>导入服务接口</li>
<li>创建服务端回调函数</li>
<li>声明并创建服务端</li>
<li>编写回调函数逻辑处理请求<br><a name="c7FPU"></a></li>
</ol>
<h5 id="添加接口-依赖"><a href="#添加接口-依赖" class="headerlink" title="添加接口&amp;&amp;依赖"></a>添加接口&amp;&amp;依赖</h5><p>因为village_wang的包类型是ament_cmake，故需要进行以下两步操作：<br /><strong>第一步修改package.xml</strong><br />加入下面的代码（告诉colcon，编译之前要确保有village_interfaces存在）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;depend&gt;village_interfaces&lt;/depend&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710039585985-a81f2aa8-b41e-461b-bc89-2642cab063a3.png#averageHue=%23222120&clientId=ud3f5d7d5-6e8f-4&from=drop&id=ud2b27244&originHeight=109&originWidth=542&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=18085&status=done&style=none&taskId=u0cad5214-f47f-4485-a806-092b7a4e5d0&title=" alt="image-20210816153438400.png"><br /><strong>第二步修改和CMakeLists.txt</strong><br />在CMakeLists.txt中加入下面一行代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(village_interfaces REQUIRED)</span><br></pre></td></tr></table></figure>
<p><strong>find_package是cmake的语法，用于查找库。找到后，还需要将其和可执行文件链接起来</strong><br />所以还需要修改ament_target_dependencies，在其中添加village_interfaces。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ament_target_dependencies</span>(wang2_node </span><br><span class="line">  rclcpp </span><br><span class="line">  village_interfaces</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>对于C++来说，添加服务接口只需在程序中引入对应的头文件即可。<br /><strong>这个头文件就是我们SellNovel.srv生成的头文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;village_interfaces/srv/sell_novel.hpp&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><a name="Fhg7q"></a></p>
<h5 id="声明回调函数"><a href="#声明回调函数" class="headerlink" title="声明回调函数"></a>声明回调函数</h5><p>添加完服务接口接着就可以声明一个<strong>卖书请求回调函数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sell_book_callback</span><span class="params">(<span class="type">const</span> village_interfaces::srv::SellNovel::Request::SharedPtr request,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> village_interfaces::srv::SellNovel::Response::SharedPtr response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建一个队列，用于存放自己看过的二手书，创建队列需要用到queue容器，所以我们先用#include <queue>在程序开头引入该容器，再在代码中添加下面这句话。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个小说章节队列</span></span><br><span class="line">std::queue&lt;std::string&gt;  novels_queue;</span><br></pre></td></tr></table></figure>
<p><a name="LaIsk"></a></p>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>当张三请求王二买二手书的时候，假如王二手里书的数量不足，王二就等攒够了对应数量的书再返回给张三。<br />等待攒够章节的操作需要在卖书服务函数中阻塞当前线程，阻塞后王二就收不到李四写的小说了，这样一来就会造成一个很尴尬的情景：<br /><strong>在卖书服务回调函数中等着书库（队列）里小说章节数量满足张三需求，接收小说的程序等着这边的卖书回调函数结束，好把书放进书库（队列）里。</strong><br />这种互相等待的情况，我们称之为死锁<br />ROS2默认是单线程的，同时只有一个线程在跑，大家都是顺序执行，你干完我干，一条线下去。<br />所以为了解决这个问题，我们可以使用多线程，即每次收到服务请求后，单独开一个线程来处理，不影响其他部分。<br><a name="aZhlq"></a></p>
<h5 id="回调函数组"><a href="#回调函数组" class="headerlink" title="回调函数组"></a>回调函数组</h5><p>ROS2中要使用多线程执行器和回调组来实现多线程，我们先在SingleDogNode中声明一个回调组成员变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个服务回调组</span></span><br><span class="line">rclcpp::CallbackGroup::SharedPtr callback_group_service_;</span><br></pre></td></tr></table></figure>
<p>最终结果</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">class SingleDogNode : <span class="keyword">public</span> rclcpp<span class="type">::Node</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    SingleDogNode(std<span class="type">::string</span> name) : Node(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 声明一个服务回调组</span></span><br><span class="line">    rclcpp<span class="type">::CallbackGroup</span><span class="type">::SharedPtr</span> callback_group_service_;</span><br><span class="line">    <span class="comment">//创建一个小说章节队列</span></span><br><span class="line">    std<span class="type">::queue</span>&lt;std<span class="type">::string</span>&gt;  novels_queue;</span><br><span class="line">    <span class="comment">// 声明一个服务端</span></span><br><span class="line">    rclcpp<span class="type">::Service</span>&lt;village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span>&gt;<span class="type">::SharedPtr</span> server_;</span><br><span class="line">    <span class="comment">// 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据</span></span><br><span class="line">    <span class="literal">void</span> sell_book_callback(const village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span><span class="type">::Request</span><span class="type">::SharedPtr</span> request,</span><br><span class="line">        const village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span><span class="type">::Response</span><span class="type">::SharedPtr</span> response)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对请求数据进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a name="rAhK4"></a></p>
<h5 id="实例化服务端-编写回调函数处理请求"><a href="#实例化服务端-编写回调函数处理请求" class="headerlink" title="实例化服务端&amp;&amp;编写回调函数处理请求"></a>实例化服务端&amp;&amp;编写回调函数处理请求</h5><p>在ROS2中，回调函数组也是一个对象，通过实例化create_callback_group类即可创建一个callback_group_service的对象。<br />在SingleDogNode的构造函数中添加下面这行代码，即可完成实例化 </p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">callback_group_service_</span> = this-&gt;create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><br />我们使用成员函数作为回调函数，这里要根据回调函数中参数个数，设置占位符，即告诉编译器，这个函数需要传入的参数个数。<br /><strong>在之前订阅话题的回调函数中，我们已经用到过一次了，因为话题回调只有一个参数，所以只需要一个占位符，这里服务的回调是两个参数，所以要设置两个</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_2;</span><br></pre></td></tr></table></figure>
<p>在private:下<strong>声明服务端</strong></p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个服务端</span></span><br><span class="line">rclcpp<span class="type">::Service</span>&lt;village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span>&gt;<span class="type">::SharedPtr</span> server_;</span><br></pre></td></tr></table></figure>
<p>在构造函数中<strong>实例化服务端</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化卖二手书的服务</span></span><br><span class="line">server_ = this<span class="punctuation">-&gt;</span>create_service&lt;village_interfaces::srv::SellNovel&gt;(<span class="string">&quot;sell_novel&quot;</span>,</span><br><span class="line">                            std::<span class="title function_ invoke__">bind</span>(&amp;SingleDogNode::sell_book_callback,this,_1,_2),</span><br><span class="line">                            rmw_qos_profile_services_default,</span><br><span class="line">                            callback_group_service_);</span><br></pre></td></tr></table></figure>
<p>实例化服务端可以直接使用create_service函数，该函数是一个模版函数，需要输入要创建的服务类型，这里我们使用的是&lt;village_interfaces::srv::SellNovel&gt;，这个函数有四个参数需要输入,小鱼接下来进行一一介绍</p>
<ul>
<li>“sell_novel”服务名称，没啥好说的，要唯一哦，因为服务只能有一个</li>
<li>std::bind(&amp;SingleDogNode::sell_book_callback,this,_1,_2)回调函数，这里指向了我们2.3.1中我们声明的sell_book_callback</li>
<li>rmw_qos_profile_services_default 通信质量，这里使用服务默认的通信质量</li>
<li>callback_group_service_，回调组，我们前面创建回调组就是在这里使用的，告诉ROS2，当你要调用回调函数处理请求时，请把它放到单独线程的回调组中<br><a name="q5mnn"></a></li>
</ul>
<h5 id="编写回调函数"><a href="#编写回调函数" class="headerlink" title="编写回调函数"></a>编写回调函数</h5><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据</span></span><br><span class="line">    void sell_book_callback(<span class="keyword">const</span> village_interfaces::srv::SellNovel::Request::SharedPtr request,</span><br><span class="line">        <span class="keyword">const</span> village_interfaces::srv::SellNovel::Response::SharedPtr response)</span><br><span class="line">    &#123;</span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;收到一个买书请求，一共给了%d钱&quot;</span>,request-&gt;money);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> novelsNum = request-&gt;money*<span class="number">1</span>;  <span class="comment">//应给小说数量，一块钱一章</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前书库里书的数量是否满足张三要买的数量，不够则进入等待函数</span></span><br><span class="line">        <span class="keyword">if</span>(novels_queue.size()&lt;novelsNum)</span><br><span class="line">        &#123;</span><br><span class="line">            RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;当前艳娘传奇章节存量为%d：不能满足需求,开始等待&quot;</span>,novels_queue.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置rate周期为1s，代表1s检查一次</span></span><br><span class="line">            rclcpp::Rate loop_rate(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当书库里小说数量小于请求数量时一直循环</span></span><br><span class="line">            <span class="keyword">while</span> (novels_queue.size()&lt;novelsNum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判断系统是否还在运行</span></span><br><span class="line">                <span class="keyword">if</span>(!rclcpp::ok())</span><br><span class="line">                &#123;</span><br><span class="line">                    RCLCPP_ERROR(this-&gt;get_logger(), <span class="string">&quot;程序被终止了&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//打印一下当前的章节数量和缺少的数量</span></span><br><span class="line">                RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;等待中，目前已有%d章，还差%d章&quot;</span>,novels_queue.size(),novelsNum-novels_queue.size());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//rate.sleep()让整个循环1s运行一次</span></span><br><span class="line">                loop_rate.sleep();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 章节数量满足需求了</span></span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;当前艳娘传奇章节存量为%d：已经满足需求&quot;</span>,novels_queue.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一本本把书取出来，放进请求响应对象response中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;novelsNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            response-&gt;novels.push_back(novels_queue.front());</span><br><span class="line">            novels_queue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><br />当收到请求时，先计算一下应该给张三多少书novelsNum，然后判断书库里书的数量够不够，不够则进入攒书程序。如果够或者攒够了就把书放到服务响应对象里，返回给张三。这里我们还需要修改一下话题回调函数，增加了一行代码，将小说放到书库里novels_queue.push(msg-&gt;data);</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 收到话题数据的回调函数</span></span><br><span class="line"> void <span class="title function_ invoke__">topic_callback</span>(<span class="keyword">const</span> std_msgs::msg::<span class="type">String</span>::SharedPtr msg)&#123;</span><br><span class="line">     <span class="comment">// 新建一张人民币</span></span><br><span class="line">     std_msgs::msg::UInt32 money;</span><br><span class="line">     money.data = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送人民币给李四</span></span><br><span class="line">    pub_<span class="punctuation">-&gt;</span><span class="title function_ invoke__">publish</span>(money);</span><br><span class="line">    <span class="title function_ invoke__">RCLCPP_INFO</span>(this<span class="punctuation">-&gt;</span><span class="title function_ invoke__">get_logger</span>(), <span class="string">&quot;王二：我收到了：&#x27;%s&#x27; ，并给了李四：%d 元的稿费&quot;</span>, msg<span class="punctuation">-&gt;</span>data.<span class="title function_ invoke__">c_str</span>(),money.data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将小说放入novels_queue中</span></span><br><span class="line">    novels_queue.<span class="title function_ invoke__">push</span>(msg<span class="punctuation">-&gt;</span>data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a name="S7CCg"></a></p>
<h5 id="修改main函数"><a href="#修改main函数" class="headerlink" title="修改main函数"></a>修改main函数</h5><p>因为我们要让整个程序变成多线程的，所以我们要把节点的执行器变成多线程执行器。<br />修改一下main函数，新建一个多线程执行器，添加王二节点并spin,完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">/*产生一个Wang2的节点*/</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;SingleDogNode&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    <span class="comment">/* 运行节点，并检测退出信号*/</span></span><br><span class="line">    rclcpp::executors::MultiThreadedExecutor exector;</span><br><span class="line">    exector.<span class="built_in">add_node</span>(node);</span><br><span class="line">    exector.<span class="built_in">spin</span>();</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <a href="https://raw.githubusercontent.com/fishros/ros2_town/af8b29f7b23153d35348ebfcd3b1bc5760c6c5a6/village_wang/src/wang2.cpp">wang2.cpp</a><br><a name="NmoFR"></a></p>
<h5 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h5><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">colcon <span class="keyword">build</span> --packages-<span class="keyword">select</span> village_wang</span><br></pre></td></tr></table></figure>
<p><a name="YjbW2"></a></p>
<h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source install/setup.bash</span><br><span class="line">ros2 run village_wang wang2_node</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2@ubuntu:~/code/town_ws$ ros2 service list -t</span><br><span class="line">/sell_book [village_interfaces/srv/SellNovel]</span><br><span class="line">ros2 service call /sell_book  village_interfaces/srv/SellNovel &quot;&#123;money: 5&#125;&quot;</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2 run village_li li4_node</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710040232046-33fa90eb-16d0-4459-8907-ec1d53912d34.png#averageHue=%232f2f2f&clientId=ud3f5d7d5-6e8f-4&from=drop&id=bKVka&originHeight=251&originWidth=1424&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=135885&status=done&style=none&taskId=ud6755017-b9b4-40d3-a3d5-08f505ffa75&title=" alt="image-20210831124712850.png"></p>
<p><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.10%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0(C++)?id=_3%e5%ae%a2%e6%88%b7%e7%ab%af%ef%bc%88%e5%bc%a0%e4%b8%89%ef%bc%89%e5%ae%9e%e7%8e%b0">客户端实现</a><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710040911063-ab181be4-89fa-4a05-8da4-a2b5d58c0444.png#averageHue=%23eeebe9&clientId=ud3f5d7d5-6e8f-4&from=drop&id=u4725bfe1&originHeight=430&originWidth=380&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=62757&status=done&style=none&taskId=u2b8126d0-3aa8-4cae-b16e-308b2b4d88f&title=" alt="28bff3501425d8b0e5a018fb3f7cfb1b.png"></p>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>Self-balancing-bycycle</title>
    <url>/2023/10/09/Self-balancing-bycycle/</url>
    <content><![CDATA[<p><em>项目简介：由于这是我负责的项目，仅以此篇博客用于记录项目的研究方向，思路，进度等。</em><br>未完待续。。。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>平衡车</tag>
      </tags>
  </entry>
  <entry>
    <title>PID算法初探</title>
    <url>/2023/11/03/PID%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="PID算法初探"><a href="#PID算法初探" class="headerlink" title="PID算法初探"></a>PID算法初探</h1><p>PID（比例-积分-微分）控制算法是一种用于调节控制系统的反馈控制算法。它是一种常见的控制系统设计方法，用于确保系统的输出与期望值（或参考信号）尽可能接近。PID控制算法基于三个主要参数，分别是比例增益（P）、积分时间（I）和微分时间（D）。</p>
<span id="more"></span>


<h3 id="PID详解"><a href="#PID详解" class="headerlink" title="PID详解"></a>PID详解</h3><ul>
<li><p><strong>比例增益（P）：</strong> 比例部分根据当前误差的大小调整输出。如果误差较大，比例增益会产生更大的输出变化，以更快地减小误差。然而，如果比例增益设置得太大，系统可能会变得不稳定。</p>
</li>
<li><p><strong>积分时间（I）：</strong> 积分部分考虑了误差随时间的积累。它用于消除系统稳态误差，因为它会持续增加控制输出，直到误差为零。但如果积分时间设置得太大，可能导致系统的超调或振荡。        </p>
</li>
<li><p><strong>微分时间（D）：</strong> 微分部分考虑了误差变化的速度。它可以帮助系统抑制振荡，因为它对误差变化的速度进行响应，减小输出的变化速度。然而，如果微分时间设置得太大，可能会导致系统对噪声敏感。</p>
</li>
</ul>
<h3 id="PID算法基本原理"><a href="#PID算法基本原理" class="headerlink" title="PID算法基本原理"></a>PID算法基本原理</h3><p><em>PID算法的执行流程是非常简单的，即利用反馈来检测偏差信号，并通过偏差信号来控制被控量。而控制器本身就是比例、积分、微分三个环节的加和。</em></p>
<p><img src="/2023/11/03/PID%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/1.jpg" alt="图片"></p>
<p>根据上图我们考虑在某个特定的时刻t，此时输入量为rin(t)，输出量为rout(t)，于是偏差就可计算为err(t)&#x3D;rin(t)-rout(t)。于是PID的基本控制规律就可以表示为如下公式：</p>
<p><img src="/2023/11/03/PID%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/2.png" alt="公式"><br><em>其中Kp为比例带，TI为积分时间，TD为微分时间。</em></p>
<h3 id="PID算法离散化"><a href="#PID算法离散化" class="headerlink" title="PID算法离散化"></a>PID算法离散化</h3><p>由于在计算机上应实现离散化问题，我们对比例，积分，微分特性做简单说明。    </p>
<p>比例就是用来对系统的偏差进行反应，所以只要存在偏差，比例就会起作用。积分主要是用来消除静差，所谓静差就是指系统稳定后输入输出之间依然存在的差值，而积分就是通过偏差的累计来抵消系统的静差。而微分则是对偏差的变化趋势做出反应，根据偏差的变化趋势实现超前调节，提高反应速度。     </p>
<p>在实现离散前，我们假设系统采样周期为T。假设我们检查第K个采样周期，很显然系统进行第K次采样。此时的偏差可以表示为err(K)&#x3D;rin(K)-rout(K)，那么积分就可以表示为：err(K)+ err(K+1)+┈┈，而微分就可以表示为：(err(K)- err(K-1))&#x2F;T。于是我们可以将第K次采样时，PID算法的离线形式表示为：<br><img src="/2023/11/03/PID%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/3.png" alt="公式"><br>即为<br><img src="/2023/11/03/PID%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/4.png" alt="公式"><br>这就是所谓的PID算法离散描述公式。还有一个增量型PID算法，下面来推导一下。<br>上面的公式描述了第k哥采样周期的结果，那么前一时刻也就是k-1哥采样周期可表示为：<br><img src="/2023/11/03/PID%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/5.png" alt="公式"><br>那么我们再来说第K个采样周期的增量，很显然就是U(k)-U(k-1)。于是我们用第k个采样周期公式减去第k-1个采样周期的公式，就得到了增量型PID算法的表示公式：<br><img src="/2023/11/03/PID%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/6.png" alt="公式"><br>当然，增量型PID必须记得一点，就是在记住U(k)&#x3D;U(k-1)+∆U(k)</p>
<h3 id="PID控制器基本实现"><a href="#PID控制器基本实现" class="headerlink" title="PID控制器基本实现"></a>PID控制器基本实现</h3><p>完成了离散化后，我们就可以来实现它了。已经用离散化的数据公式表示出来后，再进型计算机编程已经不是问题了。接下来我们就使用C语言分别针对位置型公式和增量型公式来具体实现。</p>
<h4 id="位置型PID简单实现"><a href="#位置型PID简单实现" class="headerlink" title="位置型PID简单实现"></a>位置型PID简单实现</h4><p>位置型PID的实现就是以前面的位置型公式为基础。这一节我们只是完成最简单的实现，也就是将前面的离散位置型PID公式的计算机语言化。<br>首先定义PID对象的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义结构体和公用体*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> setpoint;       <span class="comment">//设定值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> proportiongain;     <span class="comment">//比例系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> integralgain;      <span class="comment">//积分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> derivativegain;    <span class="comment">//微分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> lasterror;     <span class="comment">//前一拍偏差</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> result; <span class="comment">//输出值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> integral;<span class="comment">//积分值</span></span><br><span class="line"></span><br><span class="line">&#125;PID;</span><br></pre></td></tr></table></figure>


<p>接下来实现PID控制器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PIDRegulation</span><span class="params">(PID *vPID, <span class="type">float</span> processValue)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> thisError;</span><br><span class="line"></span><br><span class="line">  thisError=vPID-&gt;setpoint-processValue;</span><br><span class="line"></span><br><span class="line">  vPID-&gt;integral+=thisError;</span><br><span class="line"></span><br><span class="line">  vPID-&gt;result=vPID-&gt;proportiongain*thisError+vPID-&gt;integralgain*vPID-&gt;integral+vPID-&gt;derivativegain*(thisError-vPID-&gt;lasterror);</span><br><span class="line"></span><br><span class="line">  vPID-&gt;lasterror=thisError;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>这就实现了一个最简单的位置型PID控制器，当然没有考虑任何干扰条件，仅仅只是对数学公式的计算机语言化。</p>
<h4 id="增量型PID简单实现"><a href="#增量型PID简单实现" class="headerlink" title="增量型PID简单实现"></a>增量型PID简单实现</h4><p>增量型PID的实现就是以前面的增量型公式为基础。这一节我们只是完成最简单的实现，也就是将前面的离散增量型PID公式的计算机语言化。</p>
<p>首先定义PID对象的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义结构体和公用体*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> setpoint;       <span class="comment">//设定值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> proportiongain;     <span class="comment">//比例系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> integralgain;      <span class="comment">//积分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> derivativegain;    <span class="comment">//微分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> lasterror;     <span class="comment">//前一拍偏差</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> preerror;     <span class="comment">//前两拍偏差</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> deadband;     <span class="comment">//死区</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> result; <span class="comment">//输出值</span></span><br><span class="line"></span><br><span class="line">&#125;PID;</span><br></pre></td></tr></table></figure>


<p>接下来实现PID控制器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PIDRegulation</span><span class="params">(PID *vPID, <span class="type">float</span> processValue)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> thisError;</span><br><span class="line">  <span class="type">float</span> increment;</span><br><span class="line">  <span class="type">float</span> pError, dError, iError;</span><br><span class="line"></span><br><span class="line">  thisError = vPID-&gt;setpoint - processValue; <span class="comment">// 得到偏差值</span></span><br><span class="line">  pError = thisError; <span class="comment">// 比例部分</span></span><br><span class="line">  iError = vPID-&gt;integralgain * thisError; <span class="comment">// 积分部分</span></span><br><span class="line">  dError = thisError - vPID-&gt;lasterror; <span class="comment">// 微分部分</span></span><br><span class="line">  increment = vPID-&gt;proportiongain * pError + iError + vPID-&gt;derivativegain * dError; <span class="comment">// 增量计算</span></span><br><span class="line"></span><br><span class="line">  vPID-&gt;lasterror = thisError;</span><br><span class="line">  vPID-&gt;result += increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h4><p>前面讲述并且实现了PID控制器，包括位置型PID控制器和增量型PID控制器。界限来我们对这两种类型的控制器的特点作一个简单的描述。</p>
<p><strong>位置型PID控制器的基本特点：</strong></p>
<ul>
<li>位置型PID控制的输出与整个过去的状态有关，用到了偏差的累加值，容易产生累积偏差。</li>
<li>位置型PID适用于执行机构不带积分部件的对象。</li>
<li>位置型的输出直接对应对象的输出，对系统的影响比较大。</li>
</ul>
<p><strong>增量型PID控制器的基本特点：</strong></p>
<ul>
<li>增量型PID算法不需要做累加，控制量增量的确定仅与最近几次偏差值有关，计算偏差的影响较小。</li>
<li>增量型PID算法得出的是控制量的增量，对系统的影响相对较小。</li>
<li>采用增量型PID算法易于实现手动到自动的无扰动切换。</li>
</ul>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>PID</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言中正则匹配的几种思路</title>
    <url>/2023/10/12/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="关于正则匹配的几种思路"><a href="#关于正则匹配的几种思路" class="headerlink" title="关于正则匹配的几种思路"></a>关于正则匹配的几种思路</h1><p>注意：所谓正则表达指一整个字符串，而部分字符串<br>下面来看这样一个实例：<br><strong>写出一个程序，当输入“yuanshen”的时候，输出为“yes”；输入“no”的时候，输出为“no”</strong></p>
<span id="more"></span>


<h2 id="输入示例：输出示例："><a href="#输入示例：输出示例：" class="headerlink" title="输入示例：输出示例："></a>输入示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yuanshen</span><br></pre></td></tr></table></figure><br>输出示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">yes</span></span><br></pre></td></tr></table></figure></h2><h2 id="输入示例：输出示例：-1"><a href="#输入示例：输出示例：-1" class="headerlink" title="输入示例：输出示例："></a>输入示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qidong</span><br></pre></td></tr></table></figure><br>输出示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">no</span><br></pre></td></tr></table></figure></h2><p>输入示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">balaba</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error</span><br></pre></td></tr></table></figure>


<h2 id="思路一：无脑匹配"><a href="#思路一：无脑匹配" class="headerlink" title="思路一：无脑匹配"></a>思路一：无脑匹配</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    char ans[10];</span><br><span class="line">    int i = 0;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; 9) &#123;</span><br><span class="line">        char c;</span><br><span class="line">        scanf(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        ans[i] = c;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= 2 &amp;&amp; ans[0] == <span class="string">&#x27;y&#x27;</span> &amp;&amp; </span><br><span class="line">    ans[1] == <span class="string">&#x27;u&#x27;</span>&amp;&amp;ans[2] == <span class="string">&#x27;a&#x27;</span>&amp;&amp;ans[3] == <span class="string">&#x27;n&#x27;</span>&amp;&amp;ans[4] == <span class="string">&#x27;s&#x27;</span>&amp;&amp;</span><br><span class="line">    ans[5] == <span class="string">&#x27;h&#x27;</span>&amp;&amp;ans[6] == <span class="string">&#x27;e&#x27;</span>&amp;&amp;ans[7] == <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">elif</span> (i &gt;= 2 &amp;&amp; ans[0] == <span class="string">&#x27;q&#x27;</span> &amp;&amp; </span><br><span class="line">    ans[1] == <span class="string">&#x27;i&#x27;</span>&amp;&amp;ans[2] == <span class="string">&#x27;d&#x27;</span>&amp;&amp;ans[3] == <span class="string">&#x27;o&#x27;</span>&amp;&amp;ans[4] == <span class="string">&#x27;n&#x27;</span>&amp;&amp;</span><br><span class="line">    ans[5] == <span class="string">&#x27;g&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种思路看来有点麻烦（蠢），但是笔者作为初学者第一反应就是这样的。<br>首先创建了一个char类型数组，用while持续输入，if换行符作为结束条件，最后再加上“\0”结束输入。<br>匹配阶段则是用if挨个元素匹配。</p>
<h4 id="总而言之，低效、麻烦而直观"><a href="#总而言之，低效、麻烦而直观" class="headerlink" title="总而言之，低效、麻烦而直观"></a><strong>总而言之，低效、麻烦而直观</strong></h4><h2 id="思路二：使用strcmp函数"><a href="#思路二：使用strcmp函数" class="headerlink" title="思路二：使用strcmp函数"></a>思路二：使用strcmp函数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    char ans[10];</span><br><span class="line">    int i = 0;</span><br><span class="line">    // Read characters into the array <span class="keyword">until</span> newline or reaching array size - 1</span><br><span class="line">    <span class="keyword">while</span> (i &lt; 9 &amp;&amp; scanf(<span class="string">&quot;%c&quot;</span>, &amp;ans[i]) == 1 &amp;&amp; ans[i] != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Null-terminate the string</span><br><span class="line">    ans[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strncmp(ans, <span class="string">&quot;yuanshen&quot;</span>, 2) == 0) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (strncmp(ans, <span class="string">&quot;qidong&quot;</span>, 2) == 0) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路二的输入方式与思路一大同小异，关键区别在于判断匹配的方式  </p>
<h3 id="简单介绍一下使用到的strcmp函数："><a href="#简单介绍一下使用到的strcmp函数：" class="headerlink" title="简单介绍一下使用到的strcmp函数："></a>简单介绍一下使用到的strcmp函数：</h3><p>strcmp 函数用于比较两个字符串是否相等。它返回一个整数，用于表示比较结果。这个整数的含义如下：<br>-返回值小于 0：表示第一个字符串小于第二个字符串。<br>-返回值等于 0：表示两个字符串相等。<br>-返回值大于 0：表示第一个字符串大于第二个字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int strcmp(const char *str1, const char *str2) &#123;</span><br><span class="line">    <span class="keyword">while</span> (*str1 &amp;&amp; (*str1 == *str2)) &#123;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> *(unsigned char *)str1 - *(unsigned char *)str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上为strcmp函数的声明代码，采用指针达到字符串的匹配检测。</p>
<h2 id="思路三："><a href="#思路三：" class="headerlink" title="思路三："></a>思路三：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    char ans[10];</span><br><span class="line">    // Read a line of input into ans</span><br><span class="line">    fgets(ans, sizeof(ans), stdin);</span><br><span class="line"></span><br><span class="line">    // Remove newline character <span class="keyword">if</span> present</span><br><span class="line">    size_t len = strlen(ans);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; 0 &amp;&amp; ans[len - 1] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        ans[len - 1] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check <span class="keyword">if</span> ans starts with <span class="string">&quot;yuanshen&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (strncmp(ans, <span class="string">&quot;yuanshen&quot;</span>, 2) == 0) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(strncmp(ans, <span class="string">&quot;qidong&quot;</span>, 2) == 0)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的基本思路是：<br>使用 fgets 函数读取用户输入的字符串，将其存储在名为 ans 的字符数组中，限制最大输入字符数为9。</p>
<p>检查读取到的字符串的长度，如果大于0且最后一个字符是换行符（’\n’），则将该换行符替换为字符串终止符（’\0’），以确保字符串正确终止。</p>
<p>使用 strncmp 函数比较 ans 字符串的前两个字符与预期字符串是否相等。如果相等，输出 “Yes”&#x2F;“No”，<br>否则输出 “Error”。</p>
<p>（萌新勿骂）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>正则匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>yolo初步</title>
    <url>/2024/04/10/yolo%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<p>参考文献：<br /><a href="https://towardsdatascience.com/chess-rolls-or-basketball-lets-create-a-custom-object-detection-model-ef53028eac7d">A simple way of creating a custom object detection model</a>（这个就是卓晴教程的原版）<br /><a href="https://blog.csdn.net/sinat_28371057/article/details/120598220?ops_request_misc=&request_id=&biz_id=102&utm_term=yolo5&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-120598220.142%5Ev99%5Econtrol&spm=1018.2226.3001.4187">YOLOv5的详细使用教程，以及使用yolov5训练自己的数据集_yolo5训练集-CSDN博客</a></p>
<p><a name="Ub0k6"></a></p>
<span id="more"></span>

<h1 id="使用预训练模型"><a href="#使用预训练模型" class="headerlink" title="使用预训练模型"></a>使用预训练模型</h1><p><a name="Ir8Je"></a></p>
<h2 id="安装环境依赖"><a href="#安装环境依赖" class="headerlink" title="安装环境依赖"></a>安装环境依赖</h2><p><a name="ucNeD"></a></p>
<h2 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/ultralytics/y</span>olov5 <span class="comment"># clone repo</span></span><br></pre></td></tr></table></figure>

<p>镜像</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com.cnpmjs.org<span class="regexp">/ultralytics/y</span>olov5 <span class="comment"># clone repo</span></span><br></pre></td></tr></table></figure>

<p><a name="LHIoW"></a></p>
<h2 id="必要环境"><a href="#必要环境" class="headerlink" title="必要环境"></a>必要环境</h2><p>官方给出的要求是：python&gt;&#x3D;3.7、PyTorch&gt;&#x3D;1.5</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> yolov5</span><br><span class="line">pip install -U -r requirements.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pip install -U -r requirements.txt</span></span><br><span class="line"><span class="attribute">Cython</span></span><br><span class="line"><span class="attribute">numpy</span>==<span class="number">1</span>.<span class="number">17</span></span><br><span class="line"><span class="attribute">opencv</span>-python</span><br><span class="line"><span class="attribute">torch</span>&gt;=<span class="number">1</span>.<span class="number">5</span></span><br><span class="line"><span class="attribute">matplotlib</span></span><br><span class="line"><span class="attribute">pillow</span></span><br><span class="line"><span class="attribute">tensorboard</span></span><br><span class="line"><span class="attribute">PyYAML</span>&gt;=<span class="number">5</span>.<span class="number">3</span></span><br><span class="line"><span class="attribute">torchvision</span></span><br><span class="line"><span class="attribute">scipy</span></span><br><span class="line"><span class="attribute">tqdm</span></span><br><span class="line"><span class="attribute">git</span>+https://github.com/cocodataset/cocoapi.git#subdirectory=PythonAPI</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Nvidia Apex (optional) for mixed precision training --------------------------</span></span><br><span class="line"><span class="comment"># git clone https://github.com/NVIDIA/apex &amp;&amp; cd apex &amp;&amp; pip install -v --no-cache-dir --global-option=&quot;--cpp_ext&quot; --global-option=&quot;--cuda_ext&quot; . --user &amp;&amp; cd .. &amp;&amp; rm -rf apex</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Conda commands (in place of pip) ---------------------------------------------</span></span><br><span class="line"><span class="comment"># conda update -yn base -c defaults conda</span></span><br><span class="line"><span class="comment"># conda install -yc anaconda numpy opencv matplotlib tqdm pillow ipython</span></span><br><span class="line"><span class="comment"># conda install -yc conda-forge scikit-image pycocotools tensorboard</span></span><br><span class="line"><span class="comment"># conda install -yc spyder-ide spyder-line-profiler</span></span><br><span class="line"><span class="comment"># conda install -yc pytorch pytorch torchvision</span></span><br><span class="line"><span class="comment"># conda install -yc conda-forge protobuf numpy &amp;&amp; pip install onnx  # https://github.com/onnx/onnx#linux-and-macos</span></span><br></pre></td></tr></table></figure>

<p><a name="Lpb3W"></a></p>
<h2 id="下载预训练模型和标注数据集"><a href="#下载预训练模型和标注数据集" class="headerlink" title="下载预训练模型和标注数据集"></a>下载预训练模型和标注数据集</h2><p><a name="VMqUW"></a></p>
<h3 id="执行脚本下载模型"><a href="#执行脚本下载模型" class="headerlink" title="执行脚本下载模型"></a>执行脚本下载模型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Download common models</span></span><br><span class="line"> </span><br><span class="line">python3 -c <span class="string">&quot;from utils.google_utils import *;</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5s.pt&#x27;);</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5m.pt&#x27;);</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5l.pt&#x27;);</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5x.pt&#x27;)&quot;</span></span><br></pre></td></tr></table></figure>

<p>（attempt_download函数在&#x2F;yolov5&#x2F;utils&#x2F;google_utils.py脚本中定义）<br><a name="rFxrZ"></a></p>
<h3 id="下载标注数据集"><a href="#下载标注数据集" class="headerlink" title="下载标注数据集"></a>下载标注数据集</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">python3</span> -c <span class="string">&quot;from yolov5.utils.google_utils import gdrive_download; gdrive_download(&#x27;1n_oKgR81BJtqk75b00eAjdv03qVCQn2f&#x27;,&#x27;coco128.zip&#x27;)&quot;</span> <span class="comment"># download dataset</span></span><br></pre></td></tr></table></figure>

<p>执行上面的代码，会下载：coco128.zip数据集，该数据是COCO train2017数据的一部分，只取了coco数据集中的128张标注的图片，coco128.zip下载完后解压到&#x2F;yolov5目录下即可，解压后的coco128文件结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">coco128</span><br><span class="line"><span class="operator">|</span><span class="comment">-- LICENSE</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-- README.txt  # 相关说明</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-- annotations  # 空目录</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-- images   # 128张jpg图片</span></span><br><span class="line">`<span class="comment">-- labels  # 128张标注的txt文件</span></span><br></pre></td></tr></table></figure>

<p>&#x2F;yolov5&#x2F;utils&#x2F;google_utils.py脚本是下载预训练模型和标注的训练数据集，该脚本代码内容如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># This file <span class="keyword">contains</span> google utils: https:<span class="operator">/</span><span class="operator">/</span>cloud.google.com<span class="operator">/</span>storage<span class="operator">/</span>docs<span class="operator">/</span>reference<span class="operator">/</span>libraries</span><br><span class="line"># pip install <span class="comment">--upgrade google-cloud-storage</span></span><br><span class="line"># <span class="keyword">from</span> google.cloud import storage</span><br><span class="line"> </span><br><span class="line">import os</span><br><span class="line">import <span class="type">time</span></span><br><span class="line"><span class="keyword">from</span> pathlib import Path</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def attempt_download(weights):</span><br><span class="line">    # Attempt <span class="keyword">to</span> download pretrained weights if <span class="keyword">not</span> found locally</span><br><span class="line">    weights <span class="operator">=</span> weights.strip()</span><br><span class="line">    msg <span class="operator">=</span> weights <span class="operator">+</span> <span class="string">&#x27; missing, try downloading from https://drive.google.com/drive/folders/1Drs_Aiu7xx6S-ix95f9kNsA6ueKRpN2J&#x27;</span></span><br><span class="line"> </span><br><span class="line">    r <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    if len(weights) <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> os.path.isfile(weights):</span><br><span class="line">        d <span class="operator">=</span> &#123;<span class="string">&#x27;yolov3-spp.pt&#x27;</span>: <span class="string">&#x27;1mM67oNw4fZoIOL1c8M3hHmj66d8e-ni_&#x27;</span>,  # yolov3<span class="operator">-</span>spp.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5s.pt&#x27;</span>: <span class="string">&#x27;1R5T6rIyy3lLwgFXNms8whc-387H0tMQO&#x27;</span>,  # yolov5s.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5m.pt&#x27;</span>: <span class="string">&#x27;1vobuEExpWQVpXExsJ2w-Mbf3HJjWkQJr&#x27;</span>,  # yolov5m.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5l.pt&#x27;</span>: <span class="string">&#x27;1hrlqD1Wdei7UT4OgT785BEk1JwnSvNEV&#x27;</span>,  # yolov5l.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5x.pt&#x27;</span>: <span class="string">&#x27;1mM8aZJlWTxOg7BZJvNUMrTnA2AbeCVzS&#x27;</span>,  # yolov5x.yaml</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">        file <span class="operator">=</span> Path(weights).name</span><br><span class="line">        if file <span class="keyword">in</span> d:</span><br><span class="line">            r <span class="operator">=</span> gdrive_download(id<span class="operator">=</span>d[file], name<span class="operator">=</span>weights)</span><br><span class="line"> </span><br><span class="line">        if <span class="keyword">not</span> (r <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="keyword">and</span> os.path.exists(weights) <span class="keyword">and</span> os.path.getsize(weights) <span class="operator">&gt;</span> <span class="number">1E6</span>):  # weights exist <span class="keyword">and</span> <span class="operator">&gt;</span> <span class="number">1</span>MB</span><br><span class="line">            os.remove(weights) if os.path.exists(weights) <span class="keyword">else</span> <span class="keyword">None</span>  # remove partial downloads</span><br><span class="line">            s <span class="operator">=</span> &quot;curl -L -o %s &#x27;https://storage.googleapis.com/ultralytics/yolov5/ckpt/%s&#x27;&quot; <span class="operator">%</span> (weights, file)</span><br><span class="line">            r <span class="operator">=</span> os.system(s)  # <span class="keyword">execute</span>, capture <span class="keyword">return</span> <span class="keyword">values</span></span><br><span class="line"> </span><br><span class="line">            # Error <span class="keyword">check</span></span><br><span class="line">            if <span class="keyword">not</span> (r <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="keyword">and</span> os.path.exists(weights) <span class="keyword">and</span> os.path.getsize(weights) <span class="operator">&gt;</span> <span class="number">1E6</span>):  # weights exist <span class="keyword">and</span> <span class="operator">&gt;</span> <span class="number">1</span>MB</span><br><span class="line">                os.remove(weights) if os.path.exists(weights) <span class="keyword">else</span> <span class="keyword">None</span>  # remove partial downloads</span><br><span class="line">                raise Exception(msg)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def gdrive_download(id<span class="operator">=</span><span class="string">&#x27;1HaXkef9z6y5l4vUnCYgdmEAj61c6bfWO&#x27;</span>, name<span class="operator">=</span><span class="string">&#x27;coco.zip&#x27;</span>):</span><br><span class="line">    # https:<span class="operator">/</span><span class="operator">/</span>gist.github.com<span class="operator">/</span>tanaikech<span class="operator">/</span>f0f2d122e05bf5f971611258c22c110f</span><br><span class="line">    # Downloads a file <span class="keyword">from</span> Google Drive, accepting presented query</span><br><span class="line">    # <span class="keyword">from</span> utils.google_utils import <span class="operator">*</span>; gdrive_download()</span><br><span class="line">    t <span class="operator">=</span> time.time()</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">&#x27;Downloading https://drive.google.com/uc?export=download&amp;id=%s as %s... &#x27;</span> <span class="operator">%</span> (id, name), <span class="keyword">end</span><span class="operator">=</span><span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    os.remove(name) if os.path.exists(name) <span class="keyword">else</span> <span class="keyword">None</span>  # remove existing</span><br><span class="line">    os.remove(<span class="string">&#x27;cookie&#x27;</span>) if os.path.exists(<span class="string">&#x27;cookie&#x27;</span>) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line"> </span><br><span class="line">    # Attempt file download</span><br><span class="line">    os.system(&quot;curl -c ./cookie -s -L \&quot;https:<span class="operator">/</span><span class="operator">/</span>drive.google.com<span class="operator">/</span>uc?export<span class="operator">=</span>download<span class="operator">&amp;</span>id<span class="operator">=</span><span class="operator">%</span>s\&quot; &gt; /dev/null&quot; <span class="operator">%</span> id)</span><br><span class="line">    if os.path.exists(<span class="string">&#x27;cookie&#x27;</span>):  # <span class="keyword">large</span> file</span><br><span class="line">        s <span class="operator">=</span> &quot;curl -Lb ./cookie \&quot;https:<span class="operator">/</span><span class="operator">/</span>drive.google.com<span class="operator">/</span>uc?export<span class="operator">=</span>download<span class="operator">&amp;</span>confirm<span class="operator">=</span>`awk <span class="string">&#x27;/download/ &#123;print $NF&#125;&#x27;</span> .<span class="operator">/</span>cookie`<span class="operator">&amp;</span>id<span class="operator">=</span><span class="operator">%</span>s\&quot; -o %s&quot; <span class="operator">%</span> (</span><br><span class="line">            id, name)</span><br><span class="line">    <span class="keyword">else</span>:  # small file</span><br><span class="line">        s <span class="operator">=</span> &quot;curl -s -L -o %s &#x27;https://drive.google.com/uc?export=download&amp;id=%s&#x27;&quot; <span class="operator">%</span> (name, id)</span><br><span class="line">    r <span class="operator">=</span> os.system(s)  # <span class="keyword">execute</span>, capture <span class="keyword">return</span> <span class="keyword">values</span></span><br><span class="line">    os.remove(<span class="string">&#x27;cookie&#x27;</span>) if os.path.exists(<span class="string">&#x27;cookie&#x27;</span>) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line"> </span><br><span class="line">    # Error <span class="keyword">check</span></span><br><span class="line">    if r <span class="operator">!=</span> <span class="number">0</span>:</span><br><span class="line">        os.remove(name) if os.path.exists(name) <span class="keyword">else</span> <span class="keyword">None</span>  # remove partial</span><br><span class="line">        print(<span class="string">&#x27;Download error &#x27;</span>)  # raise Exception(<span class="string">&#x27;Download error&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"> </span><br><span class="line">    # Unzip if archive</span><br><span class="line">    if name.endswith(<span class="string">&#x27;.zip&#x27;</span>):</span><br><span class="line">        print(<span class="string">&#x27;unzipping... &#x27;</span>, <span class="keyword">end</span><span class="operator">=</span><span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        os.system(<span class="string">&#x27;unzip -q %s&#x27;</span> <span class="operator">%</span> name)  # unzip</span><br><span class="line">        os.remove(name)  # remove zip <span class="keyword">to</span> <span class="keyword">free</span> space</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">&#x27;Done (%.1fs)&#x27;</span> <span class="operator">%</span> (time.time() <span class="operator">-</span> t))</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"> </span><br><span class="line"># def upload_blob(bucket_name, source_file_name, destination_blob_name):</span><br><span class="line">#     # Uploads a file <span class="keyword">to</span> a bucket</span><br><span class="line">#     # https:<span class="operator">/</span><span class="operator">/</span>cloud.google.com<span class="operator">/</span>storage<span class="operator">/</span>docs<span class="operator">/</span>uploading<span class="operator">-</span>objects#storage<span class="operator">-</span>upload<span class="operator">-</span>object<span class="operator">-</span>python</span><br><span class="line">#</span><br><span class="line">#     storage_client <span class="operator">=</span> storage.Client()</span><br><span class="line">#     bucket <span class="operator">=</span> storage_client.get_bucket(bucket_name)</span><br><span class="line">#     <span class="type">blob</span> <span class="operator">=</span> bucket.blob(destination_blob_name)</span><br><span class="line">#</span><br><span class="line">#     blob.upload_from_filename(source_file_name)</span><br><span class="line">#</span><br><span class="line">#     print(<span class="string">&#x27;File &#123;&#125; uploaded to &#123;&#125;.&#x27;</span>.format(</span><br><span class="line">#         source_file_name,</span><br><span class="line">#         destination_blob_name))</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># def download_blob(bucket_name, source_blob_name, destination_file_name):</span><br><span class="line">#     # Uploads a <span class="type">blob</span> <span class="keyword">from</span> a bucket</span><br><span class="line">#     storage_client <span class="operator">=</span> storage.Client()</span><br><span class="line">#     bucket <span class="operator">=</span> storage_client.get_bucket(bucket_name)</span><br><span class="line">#     <span class="type">blob</span> <span class="operator">=</span> bucket.blob(source_blob_name)</span><br><span class="line">#</span><br><span class="line">#     blob.download_to_filename(destination_file_name)</span><br><span class="line">#</span><br><span class="line">#     print(<span class="string">&#x27;Blob &#123;&#125; downloaded to &#123;&#125;.&#x27;</span>.format(</span><br><span class="line">#         source_blob_name,</span><br><span class="line">#         destination_file_name))</span><br></pre></td></tr></table></figure>

<p><a name="FqoFo"></a></p>
<h2 id="训练下载的coco128数据集"><a href="#训练下载的coco128数据集" class="headerlink" title="训练下载的coco128数据集"></a>训练下载的coco128数据集</h2><p>创建训练数据集的配置文件Dataset.yaml<br />上面下载好coco128.zip小型数据集之后，这些数据集可以用于训练和验证<br />&#x2F;content&#x2F;yolov5&#x2F;models&#x2F;yolov5l.yaml。coco128.yaml中定义了：<br />训练图片的路径（或训练图片列表的.txt文件）<br />与验证集相同的图片<br />目标的类别数<br />类名列表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># COCO <span class="number">2017</span> dataset http:<span class="operator">/</span><span class="operator">/</span>cocodataset.org <span class="operator">-</span> <span class="keyword">first</span> <span class="number">128</span> training images</span><br><span class="line"># Download command:  python <span class="operator">-</span>c &quot;from yolov5.utils.google_utils import gdrive_download; gdrive_download(&#x27;1n_oKgR81BJtqk75b00eAjdv03qVCQn2f&#x27;,&#x27;coco128.zip&#x27;)&quot;</span><br><span class="line"># Train command: python train.py <span class="comment">--data ./data/coco128.yaml</span></span><br><span class="line"># Dataset should be placed next <span class="keyword">to</span> yolov5 folder:</span><br><span class="line">#   <span class="operator">/</span>parent_folder</span><br><span class="line">#     <span class="operator">/</span>coco128</span><br><span class="line">#     <span class="operator">/</span>yolov5</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 训练集和验证集 （图片的目录路径或 <span class="operator">*</span>.txt图片路径）</span><br><span class="line">train: ..<span class="operator">/</span>coco128<span class="operator">/</span>images<span class="operator">/</span>train2017<span class="operator">/</span></span><br><span class="line">val: ..<span class="operator">/</span>coco128<span class="operator">/</span>images<span class="operator">/</span>train2017<span class="operator">/</span></span><br><span class="line"> </span><br><span class="line"># 类别数 number <span class="keyword">of</span> classes</span><br><span class="line">nc: <span class="number">80</span></span><br><span class="line"> </span><br><span class="line"># 类别列表 class names</span><br><span class="line">names: [<span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;bicycle&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;motorcycle&#x27;</span>, <span class="string">&#x27;airplane&#x27;</span>, <span class="string">&#x27;bus&#x27;</span>, <span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>, <span class="string">&#x27;boat&#x27;</span>, <span class="string">&#x27;traffic light&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;fire hydrant&#x27;</span>, <span class="string">&#x27;stop sign&#x27;</span>, <span class="string">&#x27;parking meter&#x27;</span>, <span class="string">&#x27;bench&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;sheep&#x27;</span>, <span class="string">&#x27;cow&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;elephant&#x27;</span>, <span class="string">&#x27;bear&#x27;</span>, <span class="string">&#x27;zebra&#x27;</span>, <span class="string">&#x27;giraffe&#x27;</span>, <span class="string">&#x27;backpack&#x27;</span>, <span class="string">&#x27;umbrella&#x27;</span>, <span class="string">&#x27;handbag&#x27;</span>, <span class="string">&#x27;tie&#x27;</span>, <span class="string">&#x27;suitcase&#x27;</span>, <span class="string">&#x27;frisbee&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;skis&#x27;</span>, <span class="string">&#x27;snowboard&#x27;</span>, <span class="string">&#x27;sports ball&#x27;</span>, <span class="string">&#x27;kite&#x27;</span>, <span class="string">&#x27;baseball bat&#x27;</span>, <span class="string">&#x27;baseball glove&#x27;</span>, <span class="string">&#x27;skateboard&#x27;</span>, <span class="string">&#x27;surfboard&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;tennis racket&#x27;</span>, <span class="string">&#x27;bottle&#x27;</span>, <span class="string">&#x27;wine glass&#x27;</span>, <span class="string">&#x27;cup&#x27;</span>, <span class="string">&#x27;fork&#x27;</span>, <span class="string">&#x27;knife&#x27;</span>, <span class="string">&#x27;spoon&#x27;</span>, <span class="string">&#x27;bowl&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;sandwich&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;broccoli&#x27;</span>, <span class="string">&#x27;carrot&#x27;</span>, <span class="string">&#x27;hot dog&#x27;</span>, <span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;donut&#x27;</span>, <span class="string">&#x27;cake&#x27;</span>, <span class="string">&#x27;chair&#x27;</span>, <span class="string">&#x27;couch&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;potted plant&#x27;</span>, <span class="string">&#x27;bed&#x27;</span>, <span class="string">&#x27;dining table&#x27;</span>, <span class="string">&#x27;toilet&#x27;</span>, <span class="string">&#x27;tv&#x27;</span>, <span class="string">&#x27;laptop&#x27;</span>, <span class="string">&#x27;mouse&#x27;</span>, <span class="string">&#x27;remote&#x27;</span>, <span class="string">&#x27;keyboard&#x27;</span>, <span class="string">&#x27;cell phone&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;microwave&#x27;</span>, <span class="string">&#x27;oven&#x27;</span>, <span class="string">&#x27;toaster&#x27;</span>, <span class="string">&#x27;sink&#x27;</span>, <span class="string">&#x27;refrigerator&#x27;</span>, <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;clock&#x27;</span>, <span class="string">&#x27;vase&#x27;</span>, <span class="string">&#x27;scissors&#x27;</span>, <span class="string">&#x27;teddy bear&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;hair drier&#x27;</span>, <span class="string">&#x27;toothbrush&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p><a name="cCzV7"></a></p>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>对数据集进行打标签，可以选择如下两种打标工具：<br />Labelbox<br />CVAT<br />也可以使用LabelImg，选用ylolo格式进行标注<br />将标签导出为darknet格式，每个标注图像有一个*.txt文件（如果图像中没有对象，则不需要*.txt文件），*.txt文件格式如下：</p>
<p>每行一个对象<br />每行都是：class x_center y_center width height格式<br />框的坐标格式必须采用归一化格式的xywh（从0到1），如果你框以像素为单位，则将x_center和width除以图像宽度，将y_center和height除以图像的高度<br />类别是从索引0开始的<br />通过在器路径名中将&#x2F;images&#x2F;<em>.jpg替换为&#x2F;label&#x2F;</em>.txt，可以定位每个图像的标签文件，示例图像和标签对为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">dataset<span class="operator">/</span>images<span class="operator">/</span>train2017<span class="operator">/</span><span class="number">000000109622.</span>jpg  # image</span><br><span class="line">dataset<span class="operator">/</span>labels<span class="operator">/</span>train2017<span class="operator">/</span><span class="number">000000109622.</span>txt  # label</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">45</span> <span class="number">0.479492</span> <span class="number">0.688771</span> <span class="number">0.955609</span> <span class="number">0.5955</span></span><br><span class="line"><span class="number">45</span> <span class="number">0.736516</span> <span class="number">0.247188</span> <span class="number">0.498875</span> <span class="number">0.476417</span></span><br><span class="line"><span class="number">50</span> <span class="number">0.637063</span> <span class="number">0.732938</span> <span class="number">0.494125</span> <span class="number">0.510583</span></span><br><span class="line"><span class="number">45</span> <span class="number">0.339438</span> <span class="number">0.418896</span> <span class="number">0.678875</span> <span class="number">0.7815</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.646836</span> <span class="number">0.132552</span> <span class="number">0.118047</span> <span class="number">0.096937</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.773148</span> <span class="number">0.129802</span> <span class="number">0.090734</span> <span class="number">0.097229</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.668297</span> <span class="number">0.226906</span> <span class="number">0.131281</span> <span class="number">0.146896</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.642859</span> <span class="number">0.079219</span> <span class="number">0.148063</span> <span class="number">0.148062</span></span><br></pre></td></tr></table></figure>

<p><a name="Fk4Lk"></a></p>
<h2 id="组织文件结构"><a href="#组织文件结构" class="headerlink" title="组织文件结构"></a>组织文件结构</h2><p><strong><em>&#x2F;coco128目录应该和yolov5目录同级，同时确保coco128&#x2F;labels和coco128&#x2F;images两个目录同级</em></strong><br><img src="/2024/04/10/yolo%E5%88%9D%E6%AD%A5/4cc9eb4348385e98b15dc0f5db0dc95.png" alt="4cc9eb4348385e98b15dc0f5db0dc95"></p>
<h2 id="选择训练模型"><a href="#选择训练模型" class="headerlink" title="选择训练模型"></a>选择训练模型</h2><p>上面已经修改了自定义数据集的配置文件，同时组织好了数据。下面就可以选择一个模型进行训练了。</p>
<p>从.&#x2F;models目录下选择一个模型的配置文件，这里我们选择yolov5s.ymal，这是一个最小最快的模型。关于其他模型之间的比较下面介绍。选择好模型之后，如果你使用的不是coco数据集进行训练，而是自定义的数据集，此时只需要修改*.yaml配置文件中的nc: 80参数和数据的类别列表</p>
<p>下面是yolo5s.ymal配置文件的内容：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># parameters</span><br><span class="line">nc: <span class="number">80</span>  # number <span class="keyword">of</span> classes</span><br><span class="line">depth_multiple: <span class="number">0.33</span>  # model depth multiple</span><br><span class="line">width_multiple: <span class="number">0.50</span>  # layer channel multiple</span><br><span class="line"> </span><br><span class="line"># anchors</span><br><span class="line">anchors:</span><br><span class="line">  <span class="operator">-</span> [<span class="number">116</span>,<span class="number">90</span>, <span class="number">156</span>,<span class="number">198</span>, <span class="number">373</span>,<span class="number">326</span>]  # P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">30</span>,<span class="number">61</span>, <span class="number">62</span>,<span class="number">45</span>, <span class="number">59</span>,<span class="number">119</span>]  # P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">10</span>,<span class="number">13</span>, <span class="number">16</span>,<span class="number">30</span>, <span class="number">33</span>,<span class="number">23</span>]  # P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line"> </span><br><span class="line"># YOLOv5 backbone</span><br><span class="line">backbone:</span><br><span class="line">  # [<span class="keyword">from</span>, number, <span class="keyword">module</span>, args]</span><br><span class="line">  [[<span class="number">-1</span>, <span class="number">1</span>, Focus, [<span class="number">64</span>, <span class="number">3</span>]],  # <span class="number">0</span><span class="operator">-</span>P1<span class="operator">/</span><span class="number">2</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">128</span>, <span class="number">3</span>, <span class="number">2</span>]],  # <span class="number">1</span><span class="operator">-</span>P2<span class="operator">/</span><span class="number">4</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">128</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]],  # <span class="number">3</span><span class="operator">-</span>P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">9</span>, BottleneckCSP, [<span class="number">256</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]],  # <span class="number">5</span><span class="operator">-</span>P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">9</span>, BottleneckCSP, [<span class="number">512</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">1024</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">7</span><span class="operator">-</span>P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, SPP, [<span class="number">1024</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">13</span>]]],</span><br><span class="line">  ]</span><br><span class="line"> </span><br><span class="line"># YOLOv5 head</span><br><span class="line">head:</span><br><span class="line">  [[<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">1024</span>, <span class="literal">False</span>]],  # <span class="number">9</span></span><br><span class="line"> </span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, <span class="string">&#x27;nearest&#x27;</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">6</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat backbone P4</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">512</span>, <span class="literal">False</span>]],  # <span class="number">13</span></span><br><span class="line"> </span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, <span class="string">&#x27;nearest&#x27;</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">4</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat backbone P3</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">256</span>, <span class="literal">False</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Conv2d, [na <span class="operator">*</span> (nc <span class="operator">+</span> <span class="number">5</span>), <span class="number">1</span>, <span class="number">1</span>]],  # <span class="number">18</span> (P3<span class="operator">/</span><span class="number">8</span><span class="operator">-</span>small)</span><br><span class="line"> </span><br><span class="line">   [<span class="number">-2</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">14</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat head P4</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">512</span>, <span class="literal">False</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Conv2d, [na <span class="operator">*</span> (nc <span class="operator">+</span> <span class="number">5</span>), <span class="number">1</span>, <span class="number">1</span>]],  # <span class="number">22</span> (P4<span class="operator">/</span><span class="number">16</span><span class="operator">-</span>medium)</span><br><span class="line"> </span><br><span class="line">   [<span class="number">-2</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">10</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat head P5</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">1024</span>, <span class="literal">False</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Conv2d, [na <span class="operator">*</span> (nc <span class="operator">+</span> <span class="number">5</span>), <span class="number">1</span>, <span class="number">1</span>]],  # <span class="number">26</span> (P5<span class="operator">/</span><span class="number">32</span><span class="operator">-</span><span class="keyword">large</span>)</span><br><span class="line"> </span><br><span class="line">   [[], <span class="number">1</span>, Detect, [nc, anchors]],  # Detect(P5, P4, P3)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>yolov5s.yaml配置文件中主要定义了：</p>
<ul>
<li>参数（parameters）：类别等</li>
<li>anchor</li>
<li>YOLOv5 backbone</li>
<li>YOLOv5 head</li>
</ul>
<p><a name="tQOKw"></a></p>
<h2 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h2><p>运行下面的命令训练coco128.ymal，训练5epochs。可以有两种训练方式，如下参数：</p>
<p>–cfg yolov5s.yaml –weights ‘’：从头开始训练<br />–cfg yolov5s.yaml –weights yolov5s.pt：从预训练的模型加载开始训练<br />YOLOv5在coco128上训练5epochs的命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">python train.py <span class="comment">--img 640 --batch 16 --epochs 5 --data ./data/coco128.yaml --cfg ./models/yolov5s.yaml --weights &#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>训练的更多可选参数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--epochs：训练的epoch，默认值300</span></span><br><span class="line"><span class="comment">--batch-size：默认值16</span></span><br><span class="line"><span class="comment">--cfg：模型的配置文件，默认为yolov5s.yaml</span></span><br><span class="line"><span class="comment">--data：数据集的配置文件，默认为data/coco128.yaml</span></span><br><span class="line"><span class="comment">--img-size：训练和测试输入大小，默认为[640, 640]</span></span><br><span class="line"><span class="comment">--rect：rectangular training，布尔值</span></span><br><span class="line"><span class="comment">--resume：是否从最新的last.pt中恢复训练，布尔值</span></span><br><span class="line"><span class="comment">--nosave：仅仅保存最后的checkpoint，布尔值</span></span><br><span class="line"><span class="comment">--notest：仅仅在最后的epoch上测试，布尔值</span></span><br><span class="line"><span class="comment">--evolve：进化超参数（evolve hyperparameters），布尔值</span></span><br><span class="line"><span class="comment">--bucket：gsutil bucket，默认值&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--cache-images：缓存图片可以更快的开始训练，布尔值</span></span><br><span class="line"><span class="comment">--weights：初始化参数路径，默认值&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--name：如果提供，将results.txt重命名为results_name.txt</span></span><br><span class="line"><span class="comment">--device：cuda设备，例如：0或0,1,2,3或cpu，默认&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--adam：使用adam优化器，布尔值</span></span><br><span class="line"><span class="comment">--multi-scale：改变图片尺寸img-size +/0- 50%，布尔值</span></span><br><span class="line"><span class="comment">--single-cls：训练单个类别的数据集，布尔值</span></span><br></pre></td></tr></table></figure>

<p><a name="ZacJ9"></a></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试的更多可选参数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--weights ：预训练模型路径，默认值weights/yolov5s.pt</span></span><br><span class="line"><span class="comment">--data：数据集的配置文件，默认为data/coco.yaml</span></span><br><span class="line"><span class="comment">--batch-size：默认值32</span></span><br><span class="line"><span class="comment">--img-size：推理大小（pixels），默认640</span></span><br><span class="line"><span class="comment">--conf-thres：目标置信度阈值，默认0.001</span></span><br><span class="line"><span class="comment">--iou-thres：NMS的IOU阈值，默认0.65</span></span><br><span class="line"><span class="comment">--save-json：把结果保存为cocoapi-compatible的json文件</span></span><br><span class="line"><span class="comment">--task：默认val，可选其他值：val, test, study</span></span><br><span class="line"><span class="comment">--device：cuda设备，例如：0或0,1,2,3或cpu，默认&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--half：半精度的FP16推理</span></span><br><span class="line"><span class="comment">--single-cls：将其视为单类别，布尔值</span></span><br><span class="line"><span class="comment">--augment：增强推理，布尔值</span></span><br><span class="line"><span class="comment">--verbose：显示类别的mAP，布尔值</span></span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">python test.py <span class="comment">--weights yolov5s.pt --data ./data/coco.yaml --img 640</span></span><br></pre></td></tr></table></figure>

<p><a name="t0dKT"></a></p>
<h1 id="实现yolo自由（自训练模型）"><a href="#实现yolo自由（自训练模型）" class="headerlink" title="实现yolo自由（自训练模型）"></a>实现yolo自由（自训练模型）</h1><p>上面的都是官方给出的训练模型，我也尝试了一下训练自己的。<br><a name="Jqm55"></a></p>
<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>首先是image的手框转换成yolo文件，我使用的是清华小丑（bushi）给的开源工具<a href="https://www.makesense.ai/">https://www.makesense.ai/</a>生成的。（由于小车上的回传节点还没开始写就用手机try一下）<br><a name="Y2qP3"></a></p>
<h2 id="yolo环境配置"><a href="#yolo环境配置" class="headerlink" title="yolo环境配置"></a>yolo环境配置</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="operator">/</span><span class="operator">/</span>github.com<span class="operator">/</span>ultralytics<span class="operator">/</span>yolov5 # clone repo</span><br></pre></td></tr></table></figure>

<p>同上，不过目录结构似乎不太一样(尤其是datasets的部分，差异太多我干脆直接提出来了)<br /></p>
<p><img src="/2024/04/10/yolo%E5%88%9D%E6%AD%A5/f299a1faae42c3dfa23869900cfc571.png" alt="f299a1faae42c3dfa23869900cfc571"></p>
<p>数据集标注好之后，存放如下目录格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(yolov5) shl<span class="variable">@zfcv</span>:<span class="operator">~</span><span class="operator">/</span>shl<span class="operator">/</span>yolov5$ tree hat_hair_beard</span><br><span class="line">hat_hair_beard</span><br><span class="line">├── images</span><br><span class="line">│   ├── train2017        # 训练集图片，这里我只列举几张示例</span><br><span class="line">│   │   ├── <span class="number">000050.</span>jpg</span><br><span class="line">│   │   ├── <span class="number">000051.</span>jpg</span><br><span class="line">│   │   └── <span class="number">000052.</span>jpg</span><br><span class="line">│   └── val2017          # 验证集图片</span><br><span class="line">│       ├── <span class="number">001800.</span>jpg</span><br><span class="line">│       ├── <span class="number">001801.</span>jpg</span><br><span class="line">│       └── <span class="number">001802.</span>jpg</span><br><span class="line">└── labels               </span><br><span class="line">    ├── train2017       # 训练集的标签文件</span><br><span class="line">    │   ├── <span class="number">000050.</span>txt</span><br><span class="line">    │   ├── <span class="number">000051.</span>txt</span><br><span class="line">    │   └── <span class="number">000052.</span>txt</span><br><span class="line">    └── val2017         # 验证集的标签文件</span><br><span class="line">        ├── <span class="number">001800.</span>txt</span><br><span class="line">        ├── <span class="number">001801.</span>txt</span><br><span class="line">        └── <span class="number">001802.</span>txt</span><br><span class="line"> </span><br><span class="line"><span class="number">6</span> directories, <span class="number">13</span> files</span><br><span class="line">(yolov5) shl<span class="variable">@zfcv</span>:<span class="operator">~</span><span class="operator">/</span>shl<span class="operator">/</span>yolov5$</span><br></pre></td></tr></table></figure>

<p><a name="UTe92"></a></p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p><a name="RF2a3"></a></p>
<h3 id="数据配置文件"><a href="#数据配置文件" class="headerlink" title="数据配置文件"></a>数据配置文件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># YOLOv5 🚀 <span class="keyword">by</span> Ultralytics, AGPL<span class="number">-3.0</span> license</span><br><span class="line"># COCO128 dataset https:<span class="operator">/</span><span class="operator">/</span>www.kaggle.com<span class="operator">/</span>ultralytics<span class="operator">/</span>coco128 (<span class="keyword">first</span> <span class="number">128</span> images <span class="keyword">from</span> COCO train2017) <span class="keyword">by</span> Ultralytics</span><br><span class="line"># Example usage: python train.py <span class="comment">--data coco128.yaml</span></span><br><span class="line"># parent</span><br><span class="line"># ├── yolov5</span><br><span class="line"># └── datasets</span><br><span class="line">#     └── coco128  ← downloads here (<span class="number">7</span> MB)</span><br><span class="line"></span><br><span class="line"># Train<span class="operator">/</span>val<span class="operator">/</span>test sets <span class="keyword">as</span> <span class="number">1</span>) dir: path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs, <span class="number">2</span>) file: path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs.txt, <span class="keyword">or</span> <span class="number">3</span>) list: [path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs1, path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs2, ..]</span><br><span class="line">path: .<span class="operator">/</span>datasets # dataset root dir</span><br><span class="line">train: images<span class="operator">/</span>train_test # train images (relative <span class="keyword">to</span> <span class="string">&#x27;path&#x27;</span>) <span class="number">128</span> images</span><br><span class="line">val: images<span class="operator">/</span>val_test # val images (relative <span class="keyword">to</span> <span class="string">&#x27;path&#x27;</span>) <span class="number">128</span> images</span><br><span class="line">test: # test images (optional)</span><br><span class="line"></span><br><span class="line"># Classes</span><br><span class="line">names:</span><br><span class="line">  <span class="number">0</span>: dijia</span><br><span class="line"></span><br><span class="line"># Download script<span class="operator">/</span>URL (optional)</span><br><span class="line">#download: https:<span class="operator">/</span><span class="operator">/</span>ultralytics.com<span class="operator">/</span>assets<span class="operator">/</span>coco128.zip</span><br></pre></td></tr></table></figure>

<p>主要修改了train和val的路径，以及names的数量和名称（用于测试）<br><a name="fMVyi"></a></p>
<h3 id="模型配置文件"><a href="#模型配置文件" class="headerlink" title="模型配置文件"></a>模型配置文件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># YOLOv5 🚀 <span class="keyword">by</span> Ultralytics, AGPL<span class="number">-3.0</span> license</span><br><span class="line"></span><br><span class="line"># Parameters</span><br><span class="line">nc: <span class="number">1</span> # number <span class="keyword">of</span> classes</span><br><span class="line">depth_multiple: <span class="number">0.33</span> # model depth multiple</span><br><span class="line">width_multiple: <span class="number">0.50</span> # layer channel multiple</span><br><span class="line">anchors:</span><br><span class="line">  <span class="operator">-</span> [<span class="number">10</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">33</span>, <span class="number">23</span>] # P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">30</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">45</span>, <span class="number">59</span>, <span class="number">119</span>] # P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>] # P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line"></span><br><span class="line"># YOLOv5 v6<span class="number">.0</span> backbone</span><br><span class="line">backbone:</span><br><span class="line">  # [<span class="keyword">from</span>, number, <span class="keyword">module</span>, args]</span><br><span class="line">  [</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">64</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>]], # <span class="number">0</span><span class="operator">-</span>P1<span class="operator">/</span><span class="number">2</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">128</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">1</span><span class="operator">-</span>P2<span class="operator">/</span><span class="number">4</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">128</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">3</span><span class="operator">-</span>P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">6</span>, C3, [<span class="number">256</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">5</span><span class="operator">-</span>P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">9</span>, C3, [<span class="number">512</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">1024</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">7</span><span class="operator">-</span>P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">1024</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, SPPF, [<span class="number">1024</span>, <span class="number">5</span>]], # <span class="number">9</span></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"># YOLOv5 v6<span class="number">.0</span> head</span><br><span class="line">head: [</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, &quot;nearest&quot;]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">6</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat backbone P4</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">512</span>, <span class="literal">False</span>]], # <span class="number">13</span></span><br><span class="line"></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, &quot;nearest&quot;]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">4</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat backbone P3</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">256</span>, <span class="literal">False</span>]], # <span class="number">17</span> (P3<span class="operator">/</span><span class="number">8</span><span class="operator">-</span>small)</span><br><span class="line"></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">14</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat head P4</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">512</span>, <span class="literal">False</span>]], # <span class="number">20</span> (P4<span class="operator">/</span><span class="number">16</span><span class="operator">-</span>medium)</span><br><span class="line"></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">10</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat head P5</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">1024</span>, <span class="literal">False</span>]], # <span class="number">23</span> (P5<span class="operator">/</span><span class="number">32</span><span class="operator">-</span><span class="keyword">large</span>)</span><br><span class="line"></span><br><span class="line">    [[<span class="number">17</span>, <span class="number">20</span>, <span class="number">23</span>], <span class="number">1</span>, Detect, [nc, anchors]], # Detect(P3, P4, P5)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>这里改个nc就行了（数据集的类别数）<br><a name="ShPbp"></a></p>
<h2 id="开始训练-1"><a href="#开始训练-1" class="headerlink" title="开始训练"></a>开始训练</h2><p>在终端输入以下命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">python train.py <span class="comment">--img 640 --batch 8 --epochs 300 --data ./data/test.yaml --cfg ./models/test.yaml --weights ./weights/yolov5s.pt --device cpu</span></span><br></pre></td></tr></table></figure>

<p>各个参数作用：</p>
<ul>
<li>img：640×640</li>
<li>batch：类别</li>
<li>epochs：训练迭代次数</li>
<li>data：数据配置文件位置</li>
<li>cfg：模型配置文件位置</li>
<li>weights： 训练权重数据，如果本地没有的话应该会自动下载，以开始训练</li>
<li>device： 这个还没搞明白 正常来说是应该调用gpu的，但是我的驱动似乎有点问题，故 cpu，启动！</li>
</ul>
<p><img src="/2024/04/10/yolo%E5%88%9D%E6%AD%A5/a5aa4e4d73279a6ea804ffc393a818b.png" alt="a5aa4e4d73279a6ea804ffc393a818b"></p>
<p>训练结束后，会生成两个预训练的模型：</p>
<ul>
<li>best.pt：保存的是中间一共比较好模型</li>
<li>last.pt：训练结束后保存的最后模型</li>
</ul>
<p>尽量把最终训练的模型保存拷贝一份，防止下载再训练给覆盖，白玩<br><a name="g8lUK"></a></p>
<h3 id="浅浅展示训练成果"><a href="#浅浅展示训练成果" class="headerlink" title="浅浅展示训练成果"></a>浅浅展示训练成果</h3><p><br /><img src="/2024/04/10/yolo%E5%88%9D%E6%AD%A5/d3b58a358174697795bb89c1d86d4bb.png" alt="d3b58a358174697795bb89c1d86d4bb"></p>
<p><img src="/2024/04/10/yolo%E5%88%9D%E6%AD%A5/4edb813049a6da8f7e926d72ebb0357.png" alt="4edb813049a6da8f7e926d72ebb0357"></p>
<p><img src="/2024/04/10/yolo%E5%88%9D%E6%AD%A5/d164b7d5fd9b273031ec37aca0e9872.png" alt="d164b7d5fd9b273031ec37aca0e9872"></p>
<h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">python3 detect.py <span class="comment">--source ./data/images/image_9.png --weights ./weights/best.pt --device cpu</span></span><br></pre></td></tr></table></figure>

<p>由于数据量较小，准确率较低，就不放图了）</p>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>yolo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于过年抢红包的数学模型</title>
    <url>/2024/02/09/%E5%85%B3%E4%BA%8E%E8%BF%87%E5%B9%B4%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="关于过年抢红包的数学模型"><a href="#关于过年抢红包的数学模型" class="headerlink" title="关于过年抢红包的数学模型"></a>关于过年抢红包的数学模型</h1><h2 id="建模初衷"><a href="#建模初衷" class="headerlink" title="建模初衷"></a>建模初衷</h2><p>旧词已去，新春将至，首先祝各位新春快乐，龙年大吉！   </p>
<p>​     最近，我不禁留意到许多朋友在抢红包这一传统活动中屡次受挫，心生疑惑与好奇。在这个新年风俗的背后，究竟隐藏着怎样的数学模型和本源机制呢？于是，我产生了一个突发奇想的想法，希望通过构建一个专注于抢红包的数学模型，深入探讨这一活动的规律、趋势以及可能的变数。</p>
<span id="more"></span>

<p>​     这个数学模型的目标不仅仅是揭示红包金额的分配方式，更是希望通过对抢红包过程的数学建模，挖掘其中的概率学、随机性、和博弈理论等数学原理。通过精心设计模型，我们或许能够理解为何有些人总能赢得更多，而有些人却屡屡受挫的原因。这也为我们提供了一个新的视角，来看待这个看似简单却又蕴含深厚数学内涵的传统文化现象。</p>
<h2 id="模型雏形"><a href="#模型雏形" class="headerlink" title="模型雏形"></a>模型雏形</h2><p>​    在红包数据庞大的情况下，抢红包的机制可以近似看作是随机抽样。我们可以采用蒙特卡洛模拟方法，通过生成大量的随机样本进行统计分析，从而估算红包分配的平均情况。这种方法通过模拟多次独立的红包抢夺过程，得到了一个近似的红包金额分布，</p>
<p>​    这种方法的优势在于，它不仅能够在庞大的数据集上进行模拟，而且还能够灵活地应用于不同的分布类型。我们引入了参数 <code>distribution</code>，使得模拟可以选择均匀分布或正态分布等。此外，为了提高效率，我们使用了 NumPy 库生成正态分布，使模拟更加高效。</p>
<p>   这个模型的局限性在于它仍然是一个概率模型，通过模拟得到的结果是一种期望的近似。在实际应用中，还可以进一步考虑更复杂的因素，例如用户心理、群体行为等，以得到更准确的模拟结果。这个模型的主要目的是为了提供一个直观的近似方法，用于初步理解红包分配的规律。   </p>
<h2 id="模型验证"><a href="#模型验证" class="headerlink" title="模型验证"></a>模型验证</h2><p>生成的图像是红包金额分配的模拟结果。在这个模型中，我们进行了多次蒙特卡洛模拟，每次模拟都对同一组人数和总金额进行了10000次红包抽取。图像中的 x 轴表示抢红包的人数，y 轴表示每个人抢到的红包平均金额。</p>
<p>通过这个图像，我们可以观察到在给定的总金额和人数下，每个人抢到的红包平均金额的分布情况。在模拟的多次试验中，我们得到了多个平均分布曲线，每条曲线代表一次模拟的结果。这样的可视化展示使我们能够更清晰地了解红包分配的随机性和不确定性。</p>
<p>在图像中，如果某个人数下的平均金额分布较为集中，说明在这种情况下，大多数人抢到的金额差异不大。相反，如果分布较为分散，说明抢到的金额存在较大的差异。</p>
<p><img src="/2024/02/09/%E5%85%B3%E4%BA%8E%E8%BF%87%E5%B9%B4%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/Figure_1.png" alt="Figure_1"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simulate_red_packet</span>(<span class="params">total_amount, total_people, num_simulations, distribution=<span class="string">&#x27;uniform&#x27;</span></span>):</span><br><span class="line">    all_results = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_simulations):</span><br><span class="line">        results = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):  <span class="comment"># 模拟10000次抢红包</span></span><br><span class="line">            remaining_amount = total_amount</span><br><span class="line">            remaining_people = total_people</span><br><span class="line">            red_packet = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(total_people - <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 随机生成一个红包金额</span></span><br><span class="line">                <span class="keyword">if</span> distribution == <span class="string">&#x27;uniform&#x27;</span>:</span><br><span class="line">                    amount = random.uniform(<span class="number">0.01</span>, remaining_amount - remaining_people * <span class="number">0.01</span>)</span><br><span class="line">                <span class="keyword">elif</span> distribution == <span class="string">&#x27;normal&#x27;</span>:</span><br><span class="line">                    amount = <span class="built_in">max</span>(<span class="number">0.01</span>, np.random.normal(remaining_amount / remaining_people, <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid distribution type&quot;</span>)</span><br><span class="line"></span><br><span class="line">                red_packet.append(amount)</span><br><span class="line">                remaining_amount -= amount</span><br><span class="line">                remaining_people -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 最后一个红包的金额等于剩余的金额</span></span><br><span class="line">            red_packet.append(remaining_amount)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 随机打乱红包顺序</span></span><br><span class="line">            random.shuffle(red_packet)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 记录每个人抢到的金额</span></span><br><span class="line">            results.append(red_packet)</span><br><span class="line"></span><br><span class="line">        all_results.append(results)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all_results</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_results</span>(<span class="params">all_results</span>):</span><br><span class="line">    average_amounts_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> results <span class="keyword">in</span> all_results:</span><br><span class="line">        average_amounts = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(results[<span class="number">0</span>])):</span><br><span class="line">            total_amount = <span class="built_in">sum</span>(result[i] <span class="keyword">for</span> result <span class="keyword">in</span> results)</span><br><span class="line">            average_amount = total_amount / <span class="built_in">len</span>(results)</span><br><span class="line">            average_amounts.append(average_amount)</span><br><span class="line"></span><br><span class="line">        average_amounts_list.append(average_amounts)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> average_amounts_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_distribution</span>(<span class="params">average_amounts_list, num_simulations</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_simulations):</span><br><span class="line">        plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(average_amounts_list[i]) + <span class="number">1</span>), average_amounts_list[i], label=<span class="string">f&#x27;Simulation <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Person&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Average Amount&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Red Packet Distribution with Varying Data Amount&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    total_amount = <span class="number">100</span>  <span class="comment"># 总金额</span></span><br><span class="line">    total_people = <span class="number">10</span>  <span class="comment"># 总人数</span></span><br><span class="line">    num_simulations = <span class="number">5</span>  <span class="comment"># 模拟次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟均匀分布下的抢红包情况</span></span><br><span class="line">    all_results_uniform = simulate_red_packet(total_amount, total_people, num_simulations, distribution=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line">    average_amounts_uniform = analyze_results(all_results_uniform)</span><br><span class="line">    plot_distribution(average_amounts_uniform, num_simulations)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟正态分布下的抢红包情况</span></span><br><span class="line">    all_results_normal = simulate_red_packet(total_amount, total_people, num_simulations, distribution=<span class="string">&#x27;normal&#x27;</span>)</span><br><span class="line">    average_amounts_normal = analyze_results(all_results_normal)</span><br><span class="line">    plot_distribution(average_amounts_normal, num_simulations)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h2><p>我们可以建立一个简单的数学模型，其中包含三个变量：引诱红包的金额量（<code>enticing_amount</code>）、引诱的群聊数量（<code>group_count</code>）、和最终净红包的回报率（<code>return_rate</code>）。我们可以假设这些变量之间存在某种线性关系。</p>
<p><em><strong>Net_Red_Packet&#x3D;enticing_amount×group_count×return_rate+noise</strong></em></p>
<p>其中，<em>noise</em> 表示模型中的随机噪声，可以包含一些不可预测的因素。</p>
<p>为了使用神经网络构建模型，我们可以将其视为一个回归问题。我们的输入特征为引诱红包的金额量、引诱的群聊数量，输出为最终净红包的回报率。</p>
<p><img src="/2024/02/09/%E5%85%B3%E4%BA%8E%E8%BF%87%E5%B9%B4%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/Figure_3.png" alt="Figure_2"></p>
<p>可以看到在epoch接近100时，尽管有一点波动，在之后训练损失值已经趋于稳定。</p>
<p><img src="/2024/02/09/%E5%85%B3%E4%BA%8E%E8%BF%87%E5%B9%B4%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/Figure_2.png" alt="Figure_3"></p>
<p>在以上可视化图像中不难发现，红包金额有以下几个特点：</p>
<ol>
<li><strong>随机性主导分配：</strong> 由于红包的随机性，抢到红包的金额呈现出随机分布的特征。这符合我们对红包抢够的直观认知，即每个人抢到的金额具有不确定性。</li>
<li><strong>平均金额趋向：</strong> 随着模拟次数的增加，我们观察到平均金额有向某个数值趋近的趋势。这可能是由于模型中设置的金额范围和总人数等参数导致的。在实际情况中，红包金额的平均分配可能受到更多因素的影响，例如红包金额设置、群聊人数等。</li>
<li><strong>模型的应用范围：</strong> 这个模型在一定程度上反映了红包随机分配的特性，但并不涵盖所有情况。实际中，红包分配还可能受到人为干预、算法调整等因素的影响，这些因素并未在模型中考虑。</li>
</ol>
<h2 id="模型总结"><a href="#模型总结" class="headerlink" title="模型总结"></a>模型总结</h2><ol>
<li><p><strong>更复杂的模型：</strong> 在实际应用中，可以考虑引入更多的因素，如用户关系、历史抢红包记录等，构建更为复杂的数学模型，以更准确地描述红包分配的机制。</p>
</li>
<li><p><strong>算法优化：</strong> 针对特定场景，可以优化红包分配的算法，以达到更好的用户体验。这可能需要对模型进行细致的参数调整和算法改进。</p>
</li>
<li><p><strong>社会学和心理学因素：</strong> 考虑到红包活动是一种社交行为，未来的研究可以引入社会学和心理学的因素，深入探讨红包背后的社交动机和心理机制。</p>
<p><strong>以及，可以适当考虑人品问题。</strong></p>
<p>（本文章无任何研究意义，仅供娱乐，相关可视化代码已经发布到Github上）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>屎山</category>
      </categories>
      <tags>
        <tag>屎山</tag>
      </tags>
  </entry>
  <entry>
    <title>删除数字</title>
    <url>/2023/12/09/%E5%88%A0%E9%99%A4%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="删除数字-合并空格"><a href="#删除数字-合并空格" class="headerlink" title="删除数字&amp;&amp;合并空格"></a>删除数字&amp;&amp;合并空格</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>从键盘接收一个字符串，由数字、大小写字母和空格组成。程序功能为去掉字符串中的所有数字，最后输出变更后的字符串。注意，并列的空格需要缩减为1个空格。比如键盘输入如下：</strong></p>
<p><strong>（1）</strong>能够从键盘正确接收字符串；（2分）</p>
<p><strong>（2）</strong>能够去除数字；（4分）</p>
<p><strong>（3）</strong>能够合并并列的空格；（4分）</p>
<p><strong>（4）</strong>能够输出变更后的字符串；（2分）</p>
<p><strong>（5）</strong>程序能够全面正确运行；（3分）</p>
<span id="more"></span>



<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">input</span><span class="params">(<span class="type">char</span> a[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">    fgets(a, <span class="number">100</span>, <span class="built_in">stdin</span>); <span class="comment">// 使用fgets获取一行输入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> a[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">char</span> a[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> spaceFlag = <span class="number">0</span>; <span class="comment">// 标志变量，用于检测空格连续性</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; a[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((a[i] &lt; <span class="string">&#x27;0&#x27;</span> || a[i] &gt; <span class="string">&#x27;9&#x27;</span>) &amp;&amp; a[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            a[j++] = a[i]; <span class="comment">// 将非数字字符和非空格字符移动到数组前部</span></span><br><span class="line">            spaceFlag = <span class="number">0</span>; <span class="comment">// 非空格字符出现时，重置空格连续性标志</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!spaceFlag) &#123;</span><br><span class="line">                a[j++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">// 保留一个空格</span></span><br><span class="line">                spaceFlag = <span class="number">1</span>; <span class="comment">// 标记已经出现一个空格</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 添加字符串结束标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">array</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">    fgets(<span class="built_in">array</span>, <span class="number">100</span>, <span class="built_in">stdin</span>); <span class="comment">// 读取输入的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original string: %s\n&quot;</span>, <span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line">    delete(<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After deleting and merging: %s\n&quot;</span>, <span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>屎山</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>凯撒密码</title>
    <url>/2023/11/22/%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>凯撒加密算法Caesar<br>    在密码学中，凯撒密码（英语：Caesar cipher），或称凯撒加密、凯撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。</p>
<span id="more"></span>

<p>​	凯撒密码的替换方法是通过排列明文和密文字母表，密文字母表示通过将明文字母表向左或向右移动一个固定数目的位置。例如，当偏移量是左移3的时候（解密时的密钥就是3）：<br>明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ<br>密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC</p>
<p>​	当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。<br>​	使用时，加密者查找明文字母表中需要加密的消息中的每一个字母所在位置，并且写下密文字母表中对应的字母。需要解密的人则根据事先已知的密钥反过来操作，得到原来的明文。例如：<br>明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG<br>密文：WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ<br>​	加密系统使用的秘诀是发送方和接收方需要知道加密用的偏移量，这个加密算法虽然现在看来特别容易破解，但是它刚开始使用的时候还是很安全的。<br>​	未加密的文字称为明文plaintext. 加密后的文字称为密文ciphertext. 偏移的位置称为钥匙 key.<br>例如用钥匙1 加密HELLO 产生密文IFMMP:<br>​	plaintext	H	E	L	L	O</p>
<p>​	key	1	1	1	1	1<br>​	&#x3D; ciphertext	I	F	M	M	P<br>​	如果p是明文, pi 是p中第 ith 个 字符, k是密码（正整数）,那么密文c中第i个字符 ci,的计算公式如下：<br>ci &#x3D; (pi + k) % 26<br>​	你可以把A看作一个数组的第一个元素 (下标是0), B 的下标是 1, …, Z 的下标就是25. 假设明文p是Hi ,密钥 k 是 3. p0 是 H (aka 7), 下一个字符 p1, 是 i (aka 8). 密文的第一个字符c0, 是 K, 第二个字符 c1是 L.<br>​	请写程序 Caesar.c 其功能是用 Caesar 加密算法给信息加密.用户输入的钥匙可能不是正整数，这时我们要求要求用户必须输入正整数作为密钥.<br>程序的运行如下例。密钥是1 ，明文是HELLO:<br>​	plaintext:  HELLO<br>​	ciphertext: IFMMP<br>​	明文是 hello, world，密钥是13时运行输入:<br>​	plaintext:  hello, world<br>​	ciphertext: uryyb, jbeyq<br>注意：标点符号和空格不加密，只有文本加密! 小写字母保持小写，大写字母保持大写。<br>部分代码已经给出，请将to-list 中的5的任务完成，就可以实现以上任务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">// 清空输入缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushInputBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取加密密钥</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_key</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入加密密钥（正整数）: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理密钥的非正整数输入</span></span><br><span class="line">    <span class="keyword">while</span> (key &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入正整数作为加密密钥: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密和解密函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">char</span> p[], <span class="type">char</span> c[], <span class="type">int</span> len, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; p[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            c[i] = <span class="string">&#x27;A&#x27;</span> + (p[i] - <span class="string">&#x27;A&#x27;</span> + key) % <span class="number">26</span>; <span class="comment">// 加密大写字母</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; p[i] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">            c[i] = <span class="string">&#x27;a&#x27;</span> + (p[i] - <span class="string">&#x27;a&#x27;</span> + key) % <span class="number">26</span>; <span class="comment">// 加密小写字母</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c[i] = p[i]; <span class="comment">// 保留非字母字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 在密文字符串的末尾添加空字符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查解密后的文本是否与原始文本匹配</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check</span><span class="params">(<span class="type">char</span> p[], <span class="type">char</span> origin[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(p, origin) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;加密正确。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;加密不正确。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;chcp 65001&quot;</span>);</span><br><span class="line">    <span class="type">int</span> key = get_key();</span><br><span class="line">    <span class="type">char</span> p[<span class="number">100</span>], c[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输入</span></span><br><span class="line">    flushInputBuffer();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入明文:&quot;</span>);</span><br><span class="line">    fgets(p, <span class="keyword">sizeof</span>(p), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理输入的换行符</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">if</span> (p[len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        p[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加密</span></span><br><span class="line">    change(p, c, len, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示加密后的结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;密文是: %s&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    <span class="type">char</span> origin[<span class="number">100</span>];</span><br><span class="line">    change(c, origin, len, <span class="number">26</span> - key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示解密后的结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始文本是:\n%s\n&quot;</span>, origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查加密是否正确</span></span><br><span class="line">    check(p, origin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>屎山——不倒就是山，倒了才是屎</strong></p>
]]></content>
      <categories>
        <category>屎山</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>句子倒置</title>
    <url>/2023/11/21/%E5%8F%A5%E5%AD%90%E5%80%92%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="句子倒置"><a href="#句子倒置" class="headerlink" title="句子倒置"></a>句子倒置</h1><hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个英语的语句，比如”London bridge is falling down”，把它完全倒装过来，”down falling is bridge London”，如何不使用额外的存储空间完成这个倒装过程？<br>常学习计算机算法的人在解决这个问题时，首先会想到把这个句子切割成一个个单词，然后把它们存到一个数组里，把这个数组顺序存入，逆序取出来就可以完成语句倒装的问题。但是，这种算法要额外地使用存储空间，因此不符合题目的要求。</p>
<span id="more"></span>

<p>我们可以考虑这样解决问题：<br>第一步，先将整个句子看成是一个完整的字符串，以字母为单位头尾对调，这样上面的句子就变成了下面这样一个乱七八糟的字符串：<br>“nwod gnillaf si egdirb nodnoL”<br>第二步，把用空格分割的每一个字串以字母为单位，头尾对调。比如第一个字串是nwod，头尾对调后是down，也就是原来句子中的最后一个单词。第二个字串是gnillaf，字母头尾对调后是falling，原来句子中倒数第二个单词。这样一个个地做，直到最后一个字串里的字母对调完毕。这样就得到了下面的倒装句子：<br>“down falling is bridge London.”</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>题目中已经给出了诱导式的方法：需要造两个轮子：<em>句子倒置</em>和<em>单词倒置</em>。</p>
<ul>
<li><p>单词倒置比较容易，可以在首尾各添一个指针逐渐向中间靠拢，每次两个指针各自指向的元素互换，从而达到倒置效果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Word</span><span class="params">(<span class="type">char</span>* start, <span class="type">char</span>* end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> temp = *start;</span><br><span class="line">        *start = *end;</span><br><span class="line">        *end = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>句子倒置也不算特别复杂，其根本原理是首先把整个句子倒置，再把句子拆分成为单词，以空格为分界，将每个单词再次倒置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Sentence</span><span class="params">(<span class="type">char</span>* sentence)</span> &#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(sentence);</span><br><span class="line">    <span class="type">char</span>* start = sentence;</span><br><span class="line">    Word(sentence, sentence + length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sentence[i] == <span class="string">&#x27; &#x27;</span> || sentence[i] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            Word(start, sentence + i - <span class="number">1</span>);</span><br><span class="line">            start = sentence + i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Word</span><span class="params">(<span class="type">char</span>* start, <span class="type">char</span>* end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> temp = *start;</span><br><span class="line">        *start = *end;</span><br><span class="line">        *end = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sentence</span><span class="params">(<span class="type">char</span>* sentence)</span> &#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(sentence);</span><br><span class="line">    <span class="type">char</span>* start = sentence;</span><br><span class="line">    Word(sentence, sentence + length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sentence[i] == <span class="string">&#x27; &#x27;</span> || sentence[i] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            Word(start, sentence + i - <span class="number">1</span>);</span><br><span class="line">            start = sentence + i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">input</span><span class="params">(<span class="type">char</span>* <span class="built_in">string</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span> || c == EOF) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span>[i] = c;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span>[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> sentence[] = <span class="string">&quot;London bridge is falling down&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original sentence: %s\n&quot;</span>, sentence);</span><br><span class="line">    Sentence(sentence);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reversed sentence: %s\n&quot;</span>, sentence);</span><br><span class="line"><span class="comment">//    char string[100]=&#123;&#125;;</span></span><br><span class="line"><span class="comment">//    input(string);</span></span><br><span class="line"><span class="comment">//    Sentence(string);</span></span><br><span class="line"><span class="comment">//    printf(&quot;%s&quot;,string);</span></span><br><span class="line"><span class="comment">//    这个是可以自己输入字符串的倒置程序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​	</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>基于stm32的蓝牙循迹小车思路</title>
    <url>/2023/11/05/%E5%9F%BA%E4%BA%8Estm32%E7%9A%84%E8%93%9D%E7%89%99%E5%BE%AA%E8%BF%B9%E5%B0%8F%E8%BD%A6%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="一-概况："><a href="#一-概况：" class="headerlink" title="一. 概况："></a>一. 概况：</h2><ol>
<li><p>基本思路。</p>
</li>
<li><p>最初代码实现。</p>
</li>
<li><p>最终代码实现。</p>
<span id="more"></span></li>
</ol>
<h2 id="二-思路实现-理解："><a href="#二-思路实现-理解：" class="headerlink" title="二. 思路实现&amp;&amp;理解："></a>二. 思路实现&amp;&amp;理解：</h2><h3 id="1-循迹："><a href="#1-循迹：" class="headerlink" title="1. 循迹："></a>1. 循迹：</h3><ul>
<li><p>整体思路：ADC采样—&gt;对ADC采样数据的数学处理—&gt;对得到的数据进行PID算法运算—&gt;赋值给ccr调整pwm波输出占空比驱动电机。循环此过程则可实现速度闭环实现直角弯道除外的赛道。</p>
</li>
<li><p>方案：两灯&amp;三灯及以上。</p>
</li>
</ul>
<p>​       <strong>归根结底，重点在于数学算法处理。</strong></p>
<ul>
<li><p>实操理解：</p>
<p><strong>针对采样：</strong></p>
</li>
</ul>
<p>​      <em>重要参数</em>：单个采样范围及变化趋势&amp;&amp;单个采样值。</p>
<p>​              单个采样范围及变化趋势：非常有限，几乎不触及黑线采样值变化很小，但一接近黑线立即成指数增长。</p>
<p>​              单个采样值：几百（个体差异）<del>约2300的原始值。但转化为电压值之后仅为0</del>3.3，大量数据被压缩，损失了很多精度，最终决定采用原始                                        值进行操作。</p>
<p>​      		误差来源<em>包括但不限</em>：环境红外线影响  红外对管个体差异  红外对管彼此距离  红外对管对地距离。</p>
<p>​              环境红外线影响：</p>
<p>​					非常影响红外对管采集数据。最终解决办法有两种：</p>
<p>​				（1）在每个红外对管四周缠上黑胶布，用以反射环境红外线并聚合红外对管发出的红外线；</p>
<p>​				（2）在代码中初始化过程中消除环境误差并不需要测得，但随着小车运动导 致的位置改变，环境误差在变化，而我们只消除了开始的误差，但我们放弃使用动态消除误差，可能会影响正常循迹和路口识别。</p>
<p>​               红外对管个体差异：</p>
<p>​					不同红外对管的峰值大致相同，但最低值各有千秋。有的一两百，有的却五六百。考虑到对ADC采样数据进行处理时，个体误差的存在会影响很多计算结果造成两个灯调节作用差别很大。故必须消除。最终我们采用个体采样值域大的红外对管，以输出更加灵敏的值，并在代码中在初始化过程中，连同环境误差一起消除。</p>
<p>​               红外对管彼此距离：</p>
<p>​					主要影响两点，一是识别范围，二是数学处理时产生漏洞。对于第一点，两灯距离太小时，识别范围就太小，小车遇到稍抖一点的弯路时极易偏线，但两灯距离过大时，就相当于允许小车有一定程度的偏线，造成循迹不流畅。对于第二点，若两灯距离过小，此时可以忽略个体误差，但同时ADC数学处理获得值值域很小，调节精度或说范围很小，若两灯距离过大，两灯之间会留出一个处理值为0的空白区允许小车一定程度偏线，这是我们不希望看到的。</p>
<p>​               红外对管对地距离：</p>
<p>​					主要影响红外对管的采样值域。对地距离过低时红外对管接收不到反射光，采样值很低，对地距离过高时很受环境光干扰，接收红外线很多，采样值很高，通过打印波形图来观察何对地距离红外对管的检测距离最大，以及采样值域最大。</p>
<p>​		<strong>针对数学处理：</strong></p>
<p>​       处理参数：识别范围，输出值。</p>
<p>​                  识别范围：即小车的“视野”，能够允许偏线程度最大的情况下依然可以回归正轨。</p>
<p>​                   输出值：作为偏差，进行PID运算后，改变ccr来改变电机占空比。</p>
<p>​       处理方法与消除误差：</p>
<p>​                   两灯： 缺少能够作为条件的判断，所以只有让两灯采样值相减，同时让两灯在同一环境下初始化，记录两灯差值，然后代入程序中来消除个体误差和环境误差，然后调用ADC数据处理函数，得到曲线。</p>
<p>​      </p>
<p>​	<strong>针对PID：</strong></p>
<p>​        本次任务中采用位置式PID，且用到P与D参与运算。</p>
<p>​        采用PD系统调节原因：通过P进行主导线形控制，通过D来计算未来趋势抑制系统震荡，即通过PD系统获得更快的反应速度。符合循迹需求。</p>
<p>​        输入值：实时计算ADC数学处理获得值与目标值0的差值</p>
<p>​        输出值：除了初始占空比以外的用于控制电机的pwm</p>
<p>​        偏差：ADC数学处理获得值与目标值0的差值，用于P计算</p>
<p>​        二次偏差：前后两次偏差的差值，用于D计算</p>
<p>​        调参注意：P过小调节作用小，P过大造成过冲系统震荡。D过小调节作用小，D过大会放大系统趋势的影响，使系统震荡。</p>
<p>​        调参顺序：先设D&#x3D;0，调P，从0逐渐增大，直到系统震荡。再调D使其逐渐增大，直到系统震荡。之后进行微调，直到系统稳定。</p>
<p>​	  <strong>针对电机控制：</strong></p>
<p>​          调节方式：对两边电机同时附PID运算值，以达到使两测车轮具有相同效果的调节作用。</p>
<p>​          调节精度及限制：</p>
<p>​          考虑到可供调节的ccr范围为0~500( 有点小，占空比的相对调节精度小），但考虑到对循迹小车来讲500的调节范围够用，所以没改，但后来调车发现问题，发现有些曲率较大的弯转不过去，起初认为是P设的过小，但经过数学运算后发现问题是数值溢出，即能转过这个弯路的PID处理值没发挥出它的作用，因为溢出下限即占空比为0，溢出上限即占空比为100，所以最终采用【循迹电机反转函数】的使用，使溢出值得到充分利用。事实上增大ccr的可操作区间亦可。</p>
<p>​           初始值设置：一开始设置为50%占空比，因为考虑到想使PID调节具有对称性。事实效果很好，循迹很丝滑，但后来考虑到走直线速度较慢，故逐渐增大初始占空比，再具体进行调参。</p>
<p>​           置“0”操作：每次赋值给电机后，电机会保持这个数值运动，但在赋新的值之前，若不将之前赋过值的电机置0，两者会发生冲突比如相互抵消。</p>
<h3 id="2-机械结构："><a href="#2-机械结构：" class="headerlink" title="2. 机械结构："></a>2. 机械结构：</h3><ul>
<li>机械臂：</li>
</ul>
<p>​          	负责能量块夹放及将普通矿放入盒子内。</p>
<ul>
<li>机械铲：</li>
</ul>
<p>​			  负责为机械臂工作铺路。（可根据具体需要调整）</p>
<h2 id="三-最初代码实现："><a href="#三-最初代码实现：" class="headerlink" title="三. 最初代码实现："></a>三. 最初代码实现：</h2><h2 id="1-循迹：-1"><a href="#1-循迹：-1" class="headerlink" title="1. 循迹："></a>1. 循迹：</h2><ul>
<li>两灯：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_caiyang</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> wucha=<span class="number">0</span>;             <span class="comment">//定义两灯远离黑线的个体误差</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> LeftMax=<span class="number">0</span>;     <span class="comment">//定义左灯峰值 </span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> RightMax=<span class="number">0</span>;    <span class="comment">//定义右灯峰值</span></span><br><span class="line"></span><br><span class="line">	Right_AD=ADC_ConvertedValue[<span class="number">4</span>]; 	<span class="comment">//定义左右灯实时采样数据</span></span><br><span class="line">	Left_AD=ADC_ConvertedValue[<span class="number">7</span>];		</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(Left_AD&gt;LeftMax)	       <span class="comment">//确定左灯峰值</span></span><br><span class="line">	&#123;</span><br><span class="line">		LeftMax=Left_AD;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Right_AD&gt;RightMax)       <span class="comment">//确定右灯峰值</span></span><br><span class="line">	&#123;</span><br><span class="line">		RightMax=Right_AD;</span><br><span class="line">	&#125;		</span><br><span class="line">	</span><br><span class="line">	wucha=Right_AD-Left_AD;    <span class="comment">//确定两灯远离黑线的个体误差</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Right_AD:%d Left_AD:%d\r\n&quot;</span>,Right_AD,Left_AD);    <span class="comment">//用rawdate实时打印方便记录</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wucha:%d LeftMax:%d RightMax:%d \r\n&quot;</span>,wucha,LeftMax,RightMax);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">FloatToByte</span>                             //联合体函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">float</span> ADC_ConvertedValueLocal[NOFCHANEL];   <span class="comment">//用于保存转换计算后的电压值</span></span><br><span class="line">	<span class="type">char</span> byte[NOFCHANEL*<span class="number">4</span>+<span class="number">4</span>];                   <span class="comment">//联合体    将1个浮点数为4个字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">FloatToByte</span> <span class="title">a</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> Data_Out;            <span class="comment">//ADC数学处理获得值</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> Left_AD,Right_AD;    <span class="comment">//左右灯实时采样数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test_ADC_PRINTF</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	  a.byte[NOFCHANEL*<span class="number">4</span>+<span class="number">0</span>]=<span class="number">0x00</span>;</span><br><span class="line">	  a.byte[NOFCHANEL*<span class="number">4</span>+<span class="number">1</span>]=<span class="number">0x00</span>;</span><br><span class="line">	  a.byte[NOFCHANEL*<span class="number">4</span>+<span class="number">2</span>]=<span class="number">0x80</span>;</span><br><span class="line">    a.byte[NOFCHANEL*<span class="number">4</span>+<span class="number">3</span>]=<span class="number">0x7f</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">0</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">0</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">1</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">1</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">2</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">2</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">3</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">3</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">4</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">4</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">5</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">5</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">6</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">6</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">7</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">7</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">8</span>] = (<span class="type">float</span>)Right_AD ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">9</span>] = (<span class="type">float</span>)Left_AD ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">10</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">10</span>];</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">11</span>] = (<span class="type">float</span>)Data_Out ;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NOFCHANEL*<span class="number">4</span>+<span class="number">4</span>;i++)      <span class="comment">//NOFCHANEL*4+4为数值12*4+4=52</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a.byte[i]);</span><br><span class="line">			&#125;</span><br><span class="line">       </span><br><span class="line">        Delay_MS(<span class="number">5</span>);        <span class="comment">//5ms一采样</span></span><br><span class="line">				</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WUCHA -400 		</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT_MAX 2927   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT_MAX 2868  	</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_chuli</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	Left_AD=ADC_ConvertedValue[<span class="number">4</span>];</span><br><span class="line">	Right_AD=ADC_ConvertedValue[<span class="number">7</span>];</span><br><span class="line">	</span><br><span class="line">	Data_Out=(Left_AD-Right_AD+WUCHA);   <span class="comment">//只有两个灯，故只能作差处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	 <span class="type">uint16_t</span> kp;</span><br><span class="line">	 <span class="type">uint16_t</span> ki;</span><br><span class="line">	 <span class="type">uint16_t</span> kd;</span><br><span class="line"></span><br><span class="line">&#125;PID;</span><br><span class="line"></span><br><span class="line">PID pid;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">PositionPID</span><span class="params">(<span class="type">float</span> dev)</span>         <span class="comment">//此为位置式pid（需要两次），可以考虑增量式pid（需要三次）</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> Position_kp=(<span class="type">float</span>)pid.kp,Position_ki=(<span class="type">float</span>)pid.ki,Position_kd=(<span class="type">float</span>)pid.kd;</span><br><span class="line">  <span class="type">static</span> <span class="type">float</span> Bias,Pwm,Integral_Bias,Last_Bias;</span><br><span class="line">	Bias=Data_Out;</span><br><span class="line">	Integral_Bias+=Bias;</span><br><span class="line">	</span><br><span class="line">	Pwm=Position_kp*Bias+Position_ki*Integral_Bias+Position_kd*(Bias-Last_Bias);</span><br><span class="line">	</span><br><span class="line">	Last_Bias=Bias;</span><br><span class="line">	<span class="keyword">return</span> Pwm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">motor_xunji</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Motor_Run(motor_1, <span class="number">200</span>-PositionPID(Data_Out));</span><br><span class="line">  Motor_Run(motor_2, <span class="number">0</span>);</span><br><span class="line">  Motor_Run(motor_3, <span class="number">200</span>-PositionPID(Data_Out));</span><br><span class="line">  Motor_Run(motor_4, <span class="number">0</span>);</span><br><span class="line">  Motor_Run(motor_5, <span class="number">200</span>+PositionPID(Data_Out));</span><br><span class="line">  Motor_Run(motor_6, <span class="number">0</span>);</span><br><span class="line">  Motor_Run(motor_7, <span class="number">200</span>+PositionPID(Data_Out));</span><br><span class="line">	Motor_Run(motor_8, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ADC_chuli</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ADC_caiyang</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">motor_xunji</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 将 ADC1 转换的电压值通过 DMA 方式传到 SRAM</span></span><br><span class="line"><span class="keyword">extern</span> __IO <span class="type">uint16_t</span> ADC_ConvertedValue[NOFCHANEL];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量，用于保存转换计算后的电压值</span></span><br><span class="line"><span class="type">float</span> ADC_ConvertedValueLocal[NOFCHANEL];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Data_Out;            </span><br><span class="line"><span class="type">int</span> Left_AD,Right_AD;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	pid.kp=<span class="number">0</span>;</span><br><span class="line">	pid.kp=<span class="number">0</span>;</span><br><span class="line">	pid.kp=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	USART_Config();</span><br><span class="line">	ADCx_Init();</span><br><span class="line">	Delay_Init();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//	ADC_caiyang();     //获得adc采样数据</span></span><br><span class="line">    ADC_chuli();    <span class="comment">//只进行adc采样数据处理</span></span><br><span class="line"></span><br><span class="line">		Delay_MS(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//	Test_ADC_PRINTF(); //打印ADC波形</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//		void motor_xunji();    //循迹启动</span></span><br><span class="line">		</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-机械臂："><a href="#2-机械臂：" class="headerlink" title="2.机械臂："></a>2.机械臂：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">66</span> == i)                         <span class="comment">//上升</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (; rise &gt; <span class="number">500</span>; rise--)</span><br><span class="line">	&#123;</span><br><span class="line">		Servo_Run(servo_1, rise);</span><br><span class="line">		Delay_MS(<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">54</span> == i)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">65</span> == i)                          <span class="comment">//下降</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (; rise &lt; <span class="number">2500</span>; rise++)</span><br><span class="line">	&#123;</span><br><span class="line">		Servo_Run(servo_1, rise);</span><br><span class="line">		Delay_MS(<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">54</span> == i)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">67</span> == i)                        <span class="comment">//夹取</span></span><br><span class="line">&#123;</span><br><span class="line">	Servo_Run(servo_2, <span class="number">1000</span>);</span><br><span class="line">	Servo_Run(servo_3, <span class="number">1400</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">68</span> == i)                        <span class="comment">//松开</span></span><br><span class="line">&#123; </span><br><span class="line">	Servo_Run(servo_2, <span class="number">1200</span>);</span><br><span class="line">	Servo_Run(servo_3, <span class="number">1200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于本次赛制并不是单纯实现循迹功能，而是走迷宫，需要在十字路口，T字路口，环形岛等情况时进行特殊判断，故舍弃原先两灯方案。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>成绩单</title>
    <url>/2023/12/09/%E6%88%90%E7%BB%A9%E5%8D%95/</url>
    <content><![CDATA[<h1 id="TXT成绩单"><a href="#TXT成绩单" class="headerlink" title="TXT成绩单"></a>TXT成绩单</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>一份班级成绩表存储在一个TXT文件中，每行由学号、姓名、数学成绩、英语成绩、C语言成绩组成，如下：</strong></p>
<p><strong>192000101</strong> <strong>张天天 86 76 85</strong></p>
<p><strong>192000102</strong> <strong>李笑笑 91 88 76</strong></p>
<p><strong>…</strong></p>
<p><strong>192000130</strong> <strong>王维维 88 75 91</strong></p>
<span id="more"></span>

<p><strong>编制一个程序，完成下列任务。</strong></p>
<p>（1）构建一个结构体数组，来存储这个成绩表；（4分）</p>
<p>（2）能够正确的从文件读取数据到该结构体数组；（5分）</p>
<p>（3）能够将成绩表输出到屏幕；（4分）</p>
<p>（4）能输出总成绩进行排序并输出排序后的结果；（7分）</p>
<p>（5）程序架构良好、代码清晰、能够全面正确运行；（5分）</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li><strong>单文件版</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> number;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> en;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> student a)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld &quot;</span>, a.number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, a.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a.math);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a.en);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a.c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a.sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_sum</span><span class="params">(<span class="keyword">struct</span> student *b)</span> &#123;</span><br><span class="line">    b-&gt;sum = b-&gt;math + b-&gt;en + b-&gt;c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="keyword">struct</span> student *arr, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">temp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j].sum &gt; arr[j + <span class="number">1</span>].sum) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">students</span>[3] =</span> &#123;</span><br><span class="line">        &#123;<span class="number">123</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>, <span class="number">75</span>, <span class="number">85</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">456</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">70</span>, <span class="number">65</span>, <span class="number">75</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">789</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        calculate_sum(&amp;students[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before sorting:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        output(students[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(students, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nAfter sorting:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        output(students[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>多文件版（txt文件读取）</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> number;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> en;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件数据到结构体数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">readData</span><span class="params">(<span class="keyword">struct</span> Student students[], <span class="type">int</span> *count)</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;grades.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unable to open the file.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(file, <span class="string">&quot;%ld%s%d%d%d&quot;</span>, &amp;students[*count].number, students[*count].name,</span><br><span class="line">                  &amp;students[*count].math, &amp;students[*count].en, &amp;students[*count].c) != EOF) &#123;</span><br><span class="line">        students[*count].total = students[*count].math + students[*count].en + students[*count].c;</span><br><span class="line">        (*count)++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结构体数组数据到屏幕</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printData</span><span class="params">(<span class="keyword">struct</span> Student students[], <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Student Number\tName\tMath\tEnglish\tC Language\tTotal\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld\t%s\t%d\t%d\t%d\t%d\n&quot;</span>, students[i].number, students[i].name,</span><br><span class="line">               students[i].math, students[i].en, students[i].c, students[i].total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数用于排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">studentA</span> =</span> (<span class="keyword">struct</span> Student *)a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">studentB</span> =</span> (<span class="keyword">struct</span> Student *)b;</span><br><span class="line">    <span class="keyword">return</span> studentB-&gt;total - studentA-&gt;total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">students</span>[100];</span> <span class="comment">// 假设最多有100个学生</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    readData(students, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Student Records:\n&quot;</span>);</span><br><span class="line">    printData(students, count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序并输出排序后的结果</span></span><br><span class="line">    qsort(students, count, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student), compare);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nStudent Records after sorting by total score:\n&quot;</span>);</span><br><span class="line">    printData(students, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>屎山</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2023/11/07/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="一、概念及其介绍"><a href="#一、概念及其介绍" class="headerlink" title="一、概念及其介绍"></a>一、概念及其介绍</h3><p>插入排序(InsertionSort)，一般也被称为直接插入排序。</p>
<p>对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。</p>
<span id="more"></span>

<h3 id="二、适用说明"><a href="#二、适用说明" class="headerlink" title="二、适用说明"></a>二、适用说明</h3><p>插入排序的平均时间复杂度也是 **O(n^2)**，空间复杂度为常数阶 **O(1)**，具体时间复杂度和数组的有序性也是有关联的。</p>
<p>插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 <strong>N-1</strong> 次，时间复杂度为 **O(N)**。最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 **O(n^2)**。</p>
<h3 id="三、过程图示"><a href="#三、过程图示" class="headerlink" title="三、过程图示"></a>三、过程图示</h3><p>假设前面 <strong>n-1</strong>(其中 <strong>n&gt;&#x3D;2</strong>)个数已经是排好顺序的，现将第 <strong>n</strong> 个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。</p>
<p>按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序。</p>
<p>从小到大的插入排序整个过程如图示：</p>
<p><strong>第一轮：</strong>从第二位置的 6 开始比较，比前面 7 小，交换位置。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/09/InsertSort-01.png" alt="img"></p>
<p><strong>第二轮：</strong>第三位置的 9 比前一位置的 7 大，无需交换位置。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/09/InsertSort-02.png" alt="img"></p>
<p><strong>第三轮：</strong>第四位置的 3 比前一位置的 9 小交换位置，依次往前比较。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/09/InsertSort-03.png" alt="img"></p>
<p><strong>第四轮：</strong>第五位置的 1 比前一位置的 9 小，交换位置，再依次往前比较。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/09/InsertSort-04.png" alt="img"></p>
<p>就这样依次比较到最后一个元素。</p>
<h3 id="四、C语言代码实现"><a href="#四、C语言代码实现" class="headerlink" title="四、C语言代码实现"></a>四、C语言代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">8</span>]=&#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">1</span>; <span class="comment">//定义交换中间变量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=i;p&gt;<span class="number">0</span>;p--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[p]&lt;num[p<span class="number">-1</span>])&#123;<span class="comment">//判定是否小于前一个数</span></span><br><span class="line">                temp=num[p];</span><br><span class="line">                num[p]=num[p<span class="number">-1</span>];</span><br><span class="line">                num[p<span class="number">-1</span>]=temp;<span class="comment">//若小于，则两数交换</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> q=<span class="number">0</span>;q&lt;<span class="number">8</span>;q++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,num[q]);<span class="comment">//输出数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="一、概念及其介绍-1"><a href="#一、概念及其介绍-1" class="headerlink" title="一、概念及其介绍"></a>一、概念及其介绍</h3><p>希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。</p>
<p>希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。</p>
<p>它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。</p>
<h3 id="二、适用说明-1"><a href="#二、适用说明-1" class="headerlink" title="二、适用说明"></a>二、适用说明</h3><p>希尔排序时间复杂度是 **O(n^(1.3-2))**，空间复杂度为常数阶 **O(1)**。希尔排序没有时间复杂度为 <strong>O(n(logn))</strong> 的快速排序算法快 ，因此对中等大小规模表现良好，但对规模非常大的数据排序不是最优选择，总之比一般 <strong>O(n^2 )</strong> 复杂度的算法快得多。</p>
<h3 id="三、过程图示-1"><a href="#三、过程图示-1" class="headerlink" title="三、过程图示"></a>三、过程图示</h3><p>希尔排序目的为了加快速度改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。</p>
<p>在此我们选择增量 <strong>gap&#x3D;length&#x2F;2</strong>，缩小增量以 <strong>gap &#x3D; gap&#x2F;2</strong> 的方式，用序列 <strong>{n&#x2F;2,(n&#x2F;2)&#x2F;2…1}</strong> 来表示。</p>
<p>如图示例：</p>
<p>（1）初始增量第一趟 <strong>gap &#x3D; length&#x2F;2 &#x3D; 4</strong></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/09/ShellSort-01.png" alt="img"></p>
<p>（2）第二趟，增量缩小为 2</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/09/ShellSort-02.png" alt="img"></p>
<p>（3）第三趟，增量缩小为 1,得到最终排序结果</p>
<p>​                                                           <img src="https://www.runoob.com/wp-content/uploads/2020/09/ShellSort-03.png" alt="img"></p>
<h3 id="四、C语言代码示例"><a href="#四、C语言代码示例" class="headerlink" title="四、C语言代码示例"></a>四、C语言代码示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lenth 8</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num[lenth]=&#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> gap,j;<span class="comment">//定义增量，循环变量</span></span><br><span class="line">    <span class="keyword">for</span>(gap=lenth/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=gap;i&lt;lenth;i++)&#123;<span class="comment">//外层循环，gap每次缩小1/2</span></span><br><span class="line">            <span class="type">int</span> temp=num[i];<span class="comment">//将数组元素赋值给中间值</span></span><br><span class="line">            <span class="keyword">for</span>(j=i;j&gt;=gap&amp;&amp;temp&lt;num[j-gap];j-=gap)&#123;</span><br><span class="line">                num[j]=num[j-gap];</span><br><span class="line">            &#125;</span><br><span class="line">            num[j]=temp;<span class="comment">//判定若小于，两元素交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> q=<span class="number">0</span>;q&lt;<span class="number">8</span>;q++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,num[q]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h3 id="1-算法步骤"><a href="#1-算法步骤" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p>
<p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
<p>重复第二步，直到所有元素均排序完毕。</p>
<h3 id="2-动图演示"><a href="#2-动图演示" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="img"></p>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> n 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        a[i] = rand() % <span class="number">101</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//初始化随机数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//数组输出函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span> <span class="comment">//交换两数</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> temp = *a;</span><br><span class="line">      *a = *b;</span><br><span class="line">      *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">choose</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++)</span><br><span class="line">      &#123;</span><br><span class="line">                <span class="type">int</span> min = i;</span><br><span class="line">                <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)   <span class="comment">//走访未排序的元素</span></span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &lt; arr[min])  <span class="comment">//找到目前最小值</span></span><br><span class="line">                        min = j;  <span class="comment">//记录最小值</span></span><br><span class="line">                swap(&amp;arr[min], &amp;arr[i]);  <span class="comment">//做交換</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    init(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original array:\n&quot;</span>);</span><br><span class="line">    print(a);</span><br><span class="line">    choose(a,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorted array:\n&quot;</span>);</span><br><span class="line">    print(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p>
</li>
<li><p>作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。</p>
</li>
</ul>
<h3 id="1-算法步骤-1"><a href="#1-算法步骤-1" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
<p>针对所有的元素重复以上的步骤，除了最后一个。</p>
<p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<h3 id="2-动图演示-1"><a href="#2-动图演示-1" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="img"></p>
<h3 id="3-什么时候最快"><a href="#3-什么时候最快" class="headerlink" title="3. 什么时候最快"></a>3. 什么时候最快</h3><p>当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。</p>
<h3 id="4-什么时候最慢"><a href="#4-什么时候最慢" class="headerlink" title="4. 什么时候最慢"></a>4. 什么时候最慢</h3><p>当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用冒泡排序呢，我是闲的吗）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> n 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        a[i] = rand() % <span class="number">101</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//初始化随机数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//数组输出函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gudu</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> swapped; <span class="comment">// 用于标记是否发生交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swapped = <span class="number">0</span>; <span class="comment">// 每轮开始前重置为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; i; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[p] &gt; a[p + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = a[p];</span><br><span class="line">                a[p] = a[p + <span class="number">1</span>];</span><br><span class="line">                a[p + <span class="number">1</span>] = temp;</span><br><span class="line">                swapped = <span class="number">1</span>; <span class="comment">// 发生交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="comment">// 如果没有发生交换，说明已经排序完成</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    init(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original array:\n&quot;</span>);</span><br><span class="line">    print(a);</span><br><span class="line">    gudu(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorted array:\n&quot;</span>);</span><br><span class="line">    print(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>文件基本操作</title>
    <url>/2023/12/10/%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h3><p>（临时抱佛脚，捞捞）</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file; <span class="comment">// 文件指针</span></span><br><span class="line">    <span class="type">char</span> filename[] = <span class="string">&quot;example.txt&quot;</span>; <span class="comment">// 文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件以进行读写操作（如果文件不存在，则创建新文件）</span></span><br><span class="line">    file = fopen(filename, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件 %s\n&quot;</span>, filename);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据到文件</span></span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;这是一个文件操作示例。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;欢迎使用 C 语言进行文件操作！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件指针移到文件开头</span></span><br><span class="line">    fseek(file, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取内容并输出到屏幕上</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), file) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>欧几里得算法</title>
    <url>/2023/10/25/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>最近发现了这样一种求最大公约数的算法，因此写此篇博客记录一下</p>
<h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p>欧几里德算法，也称为辗转相除法，是一种用于计算两个整数的最大公约数（GCD，Greatest Common Divisor）的经典算法。这个算法的名字来源于古希腊数学家欧几里德（Euclid），他在公元前300年左右的《几何原本》一书中首次描述了这一算法。</p>
<span id="more"></span>

<p>欧几里德算法的核心思想是通过不断取两个整数的余数，将问题规模不断减小，直到找到它们的公约数。算法的步骤如下：</p>
<ol>
<li><p>假设有两个整数 a 和 b，其中 a &gt; b。</p>
</li>
<li><p>计算 a 除以 b 的余数，记为 r（r &#x3D; a % b）。</p>
</li>
<li><p>如果 r 等于 0，则 b 即为最大公约数，算法结束。否则，将 a 的值更新为 b，将 b 的值更新为 r，然后回到步骤 2。</p>
</li>
<li><p>重复步骤 2 和 3 直到余数 r 等于 0。此时，b 的值即为最大公约数。</p>
</li>
</ol>
<p>欧几里德算法的关键观察是，两个整数的最大公约数等于其中较小的整数和这两个整数相除的余数的最大公约数。这个观察使得算法能够快速而有效地找到最大公约数，而且不需要枚举所有可能的因子。</p>
<p>欧几里德算法在计算机科学和数学领域中具有广泛的应用，包括：</p>
<ul>
<li>求解整数的最大公约数。</li>
<li>判断两个整数是否互质（最大公约数为1）。</li>
<li>求解不定方程的整数解，如贝祖等式。</li>
<li>在密码学中用于生成加密密钥。</li>
</ul>
<p>欧几里德算法是一种高效的算法，其时间复杂度是 O(log(min(a, b)))，其中 a 和 b 是输入的两个整数。这使得它成为解决大整数问题的首选方法。</p>
<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> (b,a%b);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络初识</title>
    <url>/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://blog.csdn.net/qq_22583741/article/details/129444508?ops_request_misc=%7B%22request_id%22:%22170486960516800197010429%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170486960516800197010429&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129444508-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&spm=1018.2226.3001.4187">新手入门python实现神经网络，超级简单!_py 神经网络-CSDN博客</a></p>
<p><a href="https://hitwhlc.yuque.com/attachments/yuque/0/2024/pdf/39221021/1704869715414-7f00ccda-2452-42d9-a816-4a09a794e0ad.pdf">📎Python神经网络编程.pdf</a></p>
<p><a href="https://blog.csdn.net/weixin_40221426/article/details/132255702?ops_request_misc=%7B%22request_id%22:%22170486960516800197010429%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170486960516800197010429&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-5-132255702-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&spm=1018.2226.3001.4187">Python学习篇30-神经网络_python神经网络-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/ft_sunshine/article/details/90221691?ops_request_misc=%7B%22request_id%22:%22170487093716800192217002%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170487093716800192217002&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-90221691-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">“反向传播算法”过程及公式推导（超直观好懂的Backpropagation）-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/baidu_41774120/article/details/125764136?ops_request_misc=%7B%22request_id%22:%22170487093716800192217002%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170487093716800192217002&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-125764136-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">反向传播算法推导过程（看一篇就够了）_神经网络反向传播算法推导-CSDN博客</a></p>
<span id="more"></span>

<h2 id="1-发展历史"><a href="#1-发展历史" class="headerlink" title="1.发展历史"></a>1.发展历史</h2><p>神经网络的发展历史可以追溯到20世纪中叶。</p>
<ol>
<li><strong>McCulloch和Pitts的神经元模型（1943）：</strong></li>
</ol>
<p>​		Warren McCulloch和Walter Pitts提出了神经元模型，将神经元抽象为二进制开关，形成了后来神经网络的基础。</p>
<ol start="2">
<li><strong>感知器的提出（1957）：</strong></li>
</ol>
<p>​		Frank Rosenblatt提出了感知器，这是一种基于神经元模型的学习算法。感知器可以实现简单的二分类任务。</p>
<ol start="3">
<li><strong>早期神经网络的研究（1960s-1970s）：</strong></li>
</ol>
<p>在这一时期，神经网络受到了关注，但受到了硬件和理论上的限制。神经网络的训练和应用遇到了困难。</p>
<ol start="4">
<li><strong>反向传播算法的提出（1986）：</strong></li>
</ol>
<ul>
<li>David Rumelhart、Geoffrey Hinton和Ronald Williams提出了反向传播算法，为多层神经网络的训练提供了有效的方法。这一突破重新激发了对神经网络的研究兴趣。</li>
</ul>
<ol start="5">
<li><strong>计算能力的提升（1990s）：</strong></li>
</ol>
<p>随着计算能力的提高，研究者们开始更深入地研究神经网络的理论和应用。但由于数据集和计算资源的限制，发展相对较慢。</p>
<ol start="6">
<li><strong>深度学习的崛起（2000年后）：</strong></li>
</ol>
<ul>
<li>随着大规模数据集和强大的计算能力的可用性，深度学习（深度神经网络）再次引起了广泛关注。</li>
</ul>
<ul>
<li>图像分类、语音识别、自然语言处理等领域的成功应用推动了神经网络的发展。</li>
</ul>
<ol start="7">
<li><p><strong>卷积神经网络（CNN）和循环神经网络（RNN）的出现：</strong></p>
<ul>
<li>2012年，AlexNet的成功标志着卷积神经网络（CNN）的兴起，对图像处理任务取得了巨大成功。</li>
<li>循环神经网络（RNN）在处理序列数据（如自然语言）方面表现出色，为更多领域的应用提供了解决方案。</li>
</ul>
</li>
<li><p><strong>深度学习在各领域的广泛应用：</strong></p>
</li>
</ol>
<ul>
<li>深度学习技术在计算机视觉、自然语言处理、语音识别、医学影像等领域取得了显著的进展，推动了人工智能的发展。</li>
</ul>
<h2 id="2-主体流程"><a href="#2-主体流程" class="headerlink" title="2.主体流程"></a>2.主体流程</h2><p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/1.png" alt="1"></p>
<p><strong>输入层（Input Layer）：</strong></p>
<ul>
<li>神经网络的第一层，负责接收输入数据。每个输入节点对应输入数据的一个特征。</li>
</ul>
<p><strong>权重和偏差（Weights and Biases）：</strong></p>
<ul>
<li>每个连接（神经元之间的连接）都有一个权重，用于调整输入的影响力。每个神经元还有一个偏差，用于调整整体激活的阈值。</li>
</ul>
<p><strong>线性组合（Linear Combination）：</strong></p>
<ul>
<li>输入层的每个神经元将其输入与相应的权重相乘，然后将所有乘积相加，再加上偏差。这形成了线性组合。</li>
</ul>
<p><strong>激活函数（Activation Function）：</strong></p>
<ul>
<li>线性组合的结果通常通过激活函数，如Sigmoid、ReLU等，以引入非线性特性。这使得神经网络能够学习非线性关系。这个函数有点像高中学过的神经元阈值（神经网络似乎就是模拟人脑结构），当输入信号或信号组合以某种方式达到一定阈值，才会激活这个节点。</li>
</ul>
<p><strong>隐藏层（Hidden Layers）：</strong></p>
<ul>
<li>在输入层和输出层之间的层称为隐藏层。神经网络的深度取决于隐藏层的数量。每个隐藏层的神经元接收前一层的输出，并重复之前的步骤。</li>
</ul>
<p><strong>输出层（Output Layer）：</strong></p>
<ul>
<li>最后一个隐藏层的输出作为神经网络的最终输出。输出的数量通常取决于任务类型，如二分类问题有一个输出节点，多分类问题有多个输出节点。</li>
</ul>
<p><strong>损失函数（Loss Function）：</strong></p>
<ul>
<li>损失函数度量神经网络输出与真实标签之间的差异。训练过程的目标是最小化损失函数。</li>
</ul>
<p><strong>优化算法（Optimization Algorithm）：</strong></p>
<ul>
<li>优化算法，如梯度下降，用于调整权重和偏差，以降低损失函数。通过计算损失函数关于权重和偏差的梯度，优化算法更新参数。</li>
</ul>
<p><strong>反向传播（Backpropagation）：</strong></p>
<ul>
<li>反向传播算法是训练神经网络的关键步骤。通过计算梯度，反向传播从输出层到输入层反向传播误差，并更新权重和偏差。</li>
</ul>
<p><strong>训练和预测（Training and Prediction）：</strong></p>
<ul>
<li>神经网络通过多次迭代训练数据来学习权重和偏差。在训练后，神经网络可以用于对新数据的预测。</li>
</ul>
<p><strong>正则化和调参（Regularization and Hyperparameter Tuning）：</strong></p>
<ul>
<li>为了提高泛化能力，可以使用正则化技术，并调整超参数（如学习率、隐藏层节点数）。</li>
</ul>
<h2 id="3-矩阵的应用"><a href="#3-矩阵的应用" class="headerlink" title="3.矩阵的应用"></a>3.矩阵的应用</h2><h5 id="学习资料与平台"><a href="#学习资料与平台" class="headerlink" title="学习资料与平台"></a>学习资料与平台</h5><p><a href="https://www.bilibili.com/video/BV1bx411M7Zx/?t=6&spm_id_from=333.1350.jump_directly&vd_source=a29f1a7926ed643fe5076ad7bf93a8f2">【官方双语】深度学习之神经网络的结构 Part 1 ver 2.0_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.bilibili.com/video/BV1Ux411j7ri/?spm_id_from=333.788.recommend_more_video.-1&vd_source=a29f1a7926ed643fe5076ad7bf93a8f2">【官方双语】深度学习之梯度下降法 Part 2 ver 0.9 beta_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.bilibili.com/video/BV16x411V7Qg/?spm_id_from=333.788.recommend_more_video.-1&vd_source=a29f1a7926ed643fe5076ad7bf93a8f2">【官方双语】深度学习之反向传播算法 上&#x2F;下 Part 3 ver 0.9 beta_哔哩哔哩_bilibili</a></p>
<p>（作为计算机专业小白常常听说线性代数在计算机领域尤其重要，今天才真正理解）。</p>
<p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/2.png" alt="2"></p>
<p>​      在神经网络的构建中，存在着巨量的参数权重，每一层的数据都代表着运算量进一步飙升。矩阵作为一种数据间关系表达的优良方式（其实就是数表），可以极大程度的简化运算，并能非常简易地表示出结果。下例：</p>
<p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/3.png" alt="3"></p>
<h2 id="4-梯度下降"><a href="#4-梯度下降" class="headerlink" title="4.梯度下降"></a>4.梯度下降</h2><h4 id="梯度："><a href="#梯度：" class="headerlink" title="梯度："></a>梯度：</h4><ul>
<li><p><strong>梯度</strong>表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（梯度的方向）变化最快，变化率（梯度的模）最大，<strong>可理解为导数</strong>。</p>
</li>
<li><p>梯度上升和梯度下降是优化算法中常用的两种方法，主要目的是通过迭代找到目标函数的最大值和最小值。</p>
</li>
<li><p>例如：</p>
</li>
<li><ul>
<li>想象我们在一座很高的山上，怎么才能以最快的速度下山？我们可以先选择坡度最倾斜的方向走一段距离，然后再重新选择坡度最倾斜的方向，再走一段距离。以此类推，我们就可以以最快的速度到达山底。<strong>（梯度的方向，就是我们要选择的方向）</strong></li>
</ul>
</li>
</ul>
<h4 id="梯度下降法："><a href="#梯度下降法：" class="headerlink" title="梯度下降法："></a>梯度下降法：</h4><p><strong>梯度下降算法</strong>针对的是最小优化问题(即求最小值问题)，目的是使目标函数沿最快路径下降到最小值。</p>
<p>通俗的解释，是模拟下山，每次沿着当前位置最陡峭最易下山的方向前进一小步，然后继续沿下一个位置最陡方向前进一小步。这样一步一步走下去，一直走到觉得我们已经到了山脚。</p>
<p>算法作用于损失函数(也称目标函数、代价函数、误差函数)，是为了找到使损失函数取最小值的权重(w)和偏置(b)。</p>
<p>梯度下降运行步骤：</p>
<ol>
<li>用随机值初始化权重和偏差</li>
<li>把输入传入网络，得到输出值(预测值)</li>
<li>计算预测值和真实值(标签值)之间的误差</li>
<li><strong>对每一个产生误差的神经元，调整相应的（权重和偏差）值以减小误差</strong></li>
<li>重复迭代，直至得到网络权重和偏差的最佳值</li>
</ol>
<p>**批量梯度下降法(BGD)**：每次迭代计算梯度，使用整个数据集。每次更新都会朝着正确的方向进行，最后能够保证收敛于极值点，凸函数收敛于全局极值点，非凸函数可能会收敛于局部极值点，缺陷就是学习时间太长，消耗大量内存。</p>
<p>**随机梯度下降法(SGD)**：每次迭代计算梯度，从整个数据集中随机选取一个数据，所以每次迭代的时间非常快。但收敛时震荡，不稳定，在最优解附近波动，难以判断是否已经收敛。</p>
<p>**小批量梯度下降法(MBGD)**：这个是 <strong>BGD</strong> 和 <strong>SGD</strong> 的折中方法， <strong>BGD</strong> 每次使用整体数据，收敛太慢， <strong>SGD</strong> 每次只使用一条数据，虽然收敛快但震荡厉害，所以出现了折中的 <strong>MBGD</strong>，每次使用 <strong>n</strong> 条数据，如果 <strong>n(batch size)</strong> 选择的合适，不仅收敛速度比SGD更快、更稳定，而且在最优解附近的震荡也不会很大，甚至得到比 <strong>BGD</strong> 更好的解。</p>
<p><strong>batch size</strong> 的选择，一般取2的幂次时能充分利用矩阵运算操作，因此可以在2的幂次中挑选最优取值。例如16、32、64、128、256等等。</p>
<h2 id="5-反向传播"><a href="#5-反向传播" class="headerlink" title="5.反向传播"></a>5.反向传播</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>首先来一个<strong>反向传播算法</strong>的定义（转自维基百科）：<strong>反向传播</strong>（英语：<strong>Backpropagation</strong>，缩写为<strong>BP</strong>）是“<strong>误差反向传播</strong>”的简称，是一种与最优化方法（如梯度下降法）结合使用的，用来训练人工神经网络的常见方法。 该方法对网络中<strong>所有权重</strong>计算损失函数的梯度。 这个梯度会反馈给最优化方法，用来更新权值以最小化损失函数。（<strong>误差</strong>的反向传播）</p>
<p>首先拿一个简单的三层神经网络来举例，如下：<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515095532783.png" alt="20190515095532783"></p>
<h5 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h5><p>每个神经元由两部分组成，第一部分（e）是<strong>输入值</strong>和<strong>权重系数</strong>乘积的<strong>和</strong>，第二部分（f(e)）是一个<strong>激活函数</strong>（非线性函数）的输出， y&#x3D;f(e)即为某个神经元的输出，如下：<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515100159284.png" alt="20190515100159284"></p>
<p>下面是<strong>前向传播</strong>过程：<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515100805671.png" alt="20190515100805671"><br>———–手动分割———–<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515100845442.png" alt="20190515100845442"><br>———–手动分割———–<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515101005589.png" alt="20190515101005589"></p>
<p>到这里为止，神经网络的前向传播已经完成，最后输出的y就是本次前向传播神经网络计算出来的结果（预测结果），但这个预测结果不一定是正确的，要和真实的标签（z）相比较，计算预测结果和真实标签的误差（δ \deltaδ），如下：<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515101232916.png" alt="20190515101232916"></p>
<p>下面开始计算每个神经元的误差（δ \deltaδ）：<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515101334960.png" alt="20190515101334960"></p>
<h5 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h5><p>下面开始利用反向传播的误差，计算各个神经元（权重）的导数，开始反向传播修改权重。</p>
<p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515103014208.png" alt="20190515103014208"></p>
<p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515103033715.png" alt="20190515103033715"></p>
<p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515103116521.png" alt="20190515103116521"></p>
<h4 id="“正向传播”求损失，“反向传播”回传误差。"><a href="#“正向传播”求损失，“反向传播”回传误差。" class="headerlink" title="“正向传播”求损失，“反向传播”回传误差。"></a><strong>“正向传播”求损失，“反向传播”回传误差</strong>。</h4><p><strong>BP算法，也叫<strong><strong>δ \delta</strong></strong>δ****算法</strong>，下面以3层的感知机为例进行举例讲解。<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515104858190.png" alt="20190515104858190"></p>
<p>上图的前向传播（网络输出计算）过程如下：（此处为网络的整个误差的计算，误差E计算方法为mse）</p>
<p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20200331121115812.png" alt="20200331121115812"></p>
<p>上面的计算过程并不难，只要耐心一步步的拆开式子，逐渐分解即可。现在还有两个问题需要解决：</p>
<ol>
<li>误差E有了，怎么调整权重让误差不断减小？</li>
<li>E是权重w的函数，何如找到使得函数值最小的w。</li>
</ol>
<h4 id="（其实这些稀奇古怪的公式已经看不懂了）"><a href="#（其实这些稀奇古怪的公式已经看不懂了）" class="headerlink" title="（其实这些稀奇古怪的公式已经看不懂了）"></a>（其实这些稀奇古怪的公式已经看不懂了）</h4><p>通俗来讲，反向传播就是根据计算结果的误差修改权重信号，俗称打哪指哪，像极了我强行凑答案的样子。通过这种方法可以优化神经网络的整体权重布局，从而使训练结果更上一层楼（也可能中间层的黑箱子照着无法预测的方向走远但是结果准确率超高）</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综上所述感觉神经网络就是人们用计算机模拟人脑神经元链接构建出来的玩意（果然生物结构才是顶级码农的创造）。对于深度学习，神经网络属于机器学习的一部分，更具体地说是深度学习的一种。机器学习是一种让计算机从数据中学习的方法，而深度学习则是机器学习中的一个分支，强调使用深层次的神经网络结构。</p>
<p>对于神经网络是否智能这件事，我也说不好，感觉相对人脑来说这种结构实在是太简单了。（比如说计算机永远无法理解我怎么眼睁睁地看着自己把7x8算成45）。目前神经网络似乎缺少了较高程度的自我学习能力，例如发现个什么定律啥的，（照《终结者》一比还是差着层次），但是chatgpt确实很香，看起来AI方面的发展还是很大的，贾维斯指日可待（乐）。</p>
<h2 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h2><p>直接上代码吧，内容都写在注释里了</p>
<h5 id="神经网络类："><a href="#神经网络类：" class="headerlink" title="神经网络类："></a>神经网络类：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 神经网络类定义</span></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> scipy.special</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">neuralNetwork</span>:</span><br><span class="line">    <span class="comment"># 初始化神经网络</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, inputnodes, hiddennodes, outputnodes, learningrate</span>):</span><br><span class="line">        <span class="comment"># 设置每个层中的节点数</span></span><br><span class="line">        self.inodes = inputnodes</span><br><span class="line">        self.hnodes = hiddennodes</span><br><span class="line">        self.onodes = outputnodes</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用随机值初始化权重</span></span><br><span class="line">        self.wih = numpy.random.normal(<span class="number">0.0</span>, <span class="built_in">pow</span>(self.hnodes, -<span class="number">0.5</span>), (self.hnodes, self.inodes))</span><br><span class="line">        self.who = numpy.random.normal(<span class="number">0.0</span>, <span class="built_in">pow</span>(self.onodes, -<span class="number">0.5</span>), (self.onodes, self.hnodes))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置学习率</span></span><br><span class="line">        self.lr = learningrate</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义激活函数为sigmoid函数</span></span><br><span class="line">        self.activation_function = <span class="keyword">lambda</span> x: scipy.special.expit(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练神经网络</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, inputs_list, targets_list</span>):</span><br><span class="line">        <span class="comment"># 将输入和目标转换为2维数组</span></span><br><span class="line">        inputs = numpy.array(inputs_list, ndmin=<span class="number">2</span>).T</span><br><span class="line">        targets = numpy.array(targets_list, ndmin=<span class="number">2</span>).T</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算隐藏层的输入和输出信号</span></span><br><span class="line">        hidden_inputs = numpy.dot(self.wih, inputs)</span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算输出层的输入和输出信号</span></span><br><span class="line">        final_inputs = numpy.dot(self.who, hidden_outputs)</span><br><span class="line">        final_outputs = self.activation_function(final_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算输出层的误差</span></span><br><span class="line">        output_errors = targets - final_outputs</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算隐藏层的误差</span></span><br><span class="line">        hidden_errors = numpy.dot(self.who.T, output_errors)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用学习率和梯度更新权重</span></span><br><span class="line">        self.who += self.lr * numpy.dot((output_errors * final_outputs * (<span class="number">1.0</span> - final_outputs)), numpy.transpose(hidden_outputs))</span><br><span class="line">        self.wih += self.lr * numpy.dot((hidden_errors * hidden_outputs * (<span class="number">1.0</span> - hidden_outputs)), numpy.transpose(inputs))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询神经网络</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, input_list</span>):</span><br><span class="line">        <span class="comment"># 将输入转换为2维数组</span></span><br><span class="line">        inputs = numpy.array(input_list, ndmin=<span class="number">2</span>).T</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算隐藏层的输入和输出信号</span></span><br><span class="line">        hidden_inputs = numpy.dot(self.wih, inputs)</span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算输出层的输入和输出信号</span></span><br><span class="line">        final_inputs = numpy.dot(self.who, hidden_outputs)</span><br><span class="line">        final_outputs = self.activation_function(final_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回网络的输出</span></span><br><span class="line">        <span class="keyword">return</span> final_outputs</span><br></pre></td></tr></table></figure>







<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_file=<span class="built_in">open</span>(<span class="string">&quot;/home/zuquanzhi/pythonProject/mnist_dataset/mnist_train.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">data_list=data_file.readlines()</span><br><span class="line">all_values=data_list[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">image_array=numpy.asfarray(all_values[<span class="number">1</span>:]).reshape((<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">matplotlib.pyplot.imshow(image_array,cmap=<span class="string">&#x27;Greys&#x27;</span>,interpolation=<span class="string">&#x27;None&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>**data_file&#x3D;…**：打开 MNIST 训练数据集文件，并将其内容读取到 <strong>data_list</strong> 列表中。</li>
<li>**data_list&#x3D;data_file.readlines()**：读取文件的所有行，并存储在 <strong>data_list</strong> 列表中。</li>
<li>**all_values&#x3D;data_list[0].split(‘,’)**：将第一行数据按逗号分隔，存储到 <strong>all_values</strong> 列表中。</li>
<li>**image_array&#x3D;numpy.asfarray(all_values[1:]).reshape((28,28))**：将 <strong>all_values</strong> 中的像素值转换为浮点数，并重新形状为 28x28 的数组，表示图像的像素矩阵。</li>
<li>**matplotlib.pyplot.imshow(image_array,cmap&#x3D;’Greys’,interpolation&#x3D;’None’)**：使用 Matplotlib 的 <strong>imshow</strong> 函数将图像以灰度的形式显示在图像窗口中。</li>
</ol>
<p>这段代码读取 MNIST 数据集中的第一张图像数据，并显示在图像窗口中。</p>
<p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/a350e116ec9ac187600f639bb8574216.png" alt="a350e116ec9ac187600f639bb8574216"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_file=<span class="built_in">open</span>(<span class="string">&quot;/home/zuquanzhi/pythonProject/mnist_dataset/mnist_train.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">data_list=data_file.readlines()</span><br><span class="line">all_values=data_list[<span class="number">5</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">image_array=numpy.asfarray(all_values[<span class="number">1</span>:]).reshape((<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">matplotlib.pyplot.imshow(image_array,cmap=<span class="string">&#x27;Greys&#x27;</span>,interpolation=<span class="string">&#x27;None&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>data_list[5]</strong> 表示第6行数据，<strong>all_values&#x3D;data_list[5].split(‘,’)</strong> 将这一行数据根据逗号分割成一个值的列表。然后，将列表中除第一个值外的其余值转换为浮点数数组，并reshape为28x28的图像矩阵，最后使用<strong>matplotlib</strong>库将图像显示在灰度色图上。</p>
<p>(其实就是根据数据显示原图)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scaled_input=(numpy.asfarray(all_values[<span class="number">1</span>:]) /<span class="number">255.0</span>*<span class="number">0.99</span>)+<span class="number">0.01</span></span><br><span class="line"><span class="built_in">print</span>(scaled_input)</span><br></pre></td></tr></table></figure>

<p>这段代码对MNIST数据集中第6行的像素值进行了预处理。首先，<strong>numpy.asfarray(all_values[1:])</strong> 将第6行除第一个值外的其余值转换为浮点数数组。然后，通过除以255.0将像素值缩放到0到1之间，接着将数据范围缩放到0.01到1之间，而不是0到1。这是因为在神经网络中，为了避免输入值为0的情况（可能会影响权重的更新），将数据范围设置为稍微偏离0的范围。</p>
<p>最后，通过<strong>print(scaled_input)</strong> 将缩放后的输入值打印出来，以便查看处理后的数值范围和数据。</p>
<p>这段代码可以帮助确保在使用神经网络之前对输入数据进行了适当的预处理，以提高神经网络的训练效果。</p>
<p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/416a55bcc508c87e6a28fb7d848dcec6_720.png" alt="416a55bcc508c87e6a28fb7d848dcec6_720"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">onodes=<span class="number">10</span></span><br><span class="line">targets=numpy.zeros(onodes)+<span class="number">0.01</span></span><br><span class="line">targets[<span class="built_in">int</span>(all_values[<span class="number">0</span>])]=<span class="number">0.99</span></span><br></pre></td></tr></table></figure>

<p>这段代码是为了准备目标输出。它创建了一个长度为<strong>onodes</strong>的零数组（全零数组），然后将第**int(all_values[0])<strong>个位置设置为0.99。这个位置对应于</strong>all_values[0]<strong>中的值，通常表示图像中显示的数字。</strong>int(all_values[0])**的值被用作索引，用于将目标输出数组中对应的位置值设置为0.99。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_file=<span class="built_in">open</span>(<span class="string">&quot;/home/zuquanzhi/pythonProject/mnist_dataset/mnist_test.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">data_list=data_file.readlines()</span><br><span class="line">all_values=data_list[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">image_array=numpy.asfarray(all_values[<span class="number">1</span>:]).reshape((<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">matplotlib.pyplot.imshow(image_array,cmap=<span class="string">&#x27;Greys&#x27;</span>,interpolation=<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line"></span><br><span class="line">all_values=test_data_list[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(all_values[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/1014148cd6ee8d823f12ab6de2c2ea0b_720.png" alt="1014148cd6ee8d823f12ab6de2c2ea0b_720"></p>
<ol>
<li><strong>data_file&#x3D;open(“&#x2F;home&#x2F;zuquanzhi&#x2F;pythonProject&#x2F;mnist_dataset&#x2F;mnist_test.csv”,’r’)</strong>: 打开了一个名为<strong>mnist_test.csv</strong>的CSV文件来读取测试数据。</li>
<li><strong>data_list&#x3D;data_file.readlines()</strong>: 读取CSV文件的内容，并将每一行数据存储在<strong>data_list</strong>列表中。</li>
<li><strong>all_values&#x3D;data_list[0].split(‘,’)</strong>: 从第一行提取数据，使用逗号作为分隔符将数据拆分为一个值的列表<strong>all_values</strong>。</li>
<li><strong>image_array&#x3D;numpy.asfarray(all_values[1:]).reshape((28,28))</strong>: 将<strong>all_values</strong>列表中的字符串转换为浮点数，并根据这些值创建一个28x28的二维数组 <strong>image_array</strong>，用于表示图像的像素值。</li>
<li><strong>matplotlib.pyplot.imshow(image_array,cmap&#x3D;’Greys’,interpolation&#x3D;’None’)</strong>: 使用Matplotlib库中的<strong>imshow</strong>函数将<strong>image_array</strong>作为灰度图像显示出来。</li>
<li><strong>all_values&#x3D;test_data_list[0].split(‘,’)</strong>: 这里应该更正为<strong>data_list</strong>而不是<strong>test_data_list</strong>，以便使用刚刚加载的测试集数据。这行代码意图是重新读取<strong>data_list</strong>的第一行数据并将其拆分。</li>
<li><strong>print(all_values[0])</strong>: 打印 <strong>all_values</strong> 列表的第一个值，这可能是与图像相关联的标签或类别。</li>
</ol>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学（1）</title>
    <url>/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="离散数学基础"><a href="#离散数学基础" class="headerlink" title="离散数学基础"></a>离散数学基础</h1><p>本来是打算一点点肝的，谁知道讲这么快，干脆就一晚上肝完吧</p>
<span id="more"></span>

<h2 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h2><h3 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h3><p>看了下定义：大抵是说一个集合到自身的一一对应，<br>这句简单的话透露出一个信息：置换这种运算应该是自闭的，也就是说没有每个元素必然被一个元素指向，自身也指向一个元素（或自身）。<img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711624643658.png" alt="1711624643658"><br>按照我目前的理解，大概就是说r是使γ置换成自身的最小次数，在此之前咋换都不行。<br><img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711625730481.png" alt="1711625730481"><br>这个定理大概是说反正没有重复数字，可以瞎jb换，也不会影响什么。<br><img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711625796751.png" alt="1711625796751"><br><img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711625891397.png" alt="1711625891397"><br>PS：这里的个数指置换中元素的个数</p>
<h3 id="二元和n元运算"><a href="#二元和n元运算" class="headerlink" title="二元和n元运算"></a>二元和n元运算</h3><p><img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711626677152.png" alt="1711626677152"><br>本来这个二元运算的概念没太理解，知道看到了这张图<br><img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711627084928.png" alt="1711627084928"><br>忽然间理解了奥义：两个加数（乘数）分别是二进制数域，运算之后的结过依然属于二进制数，这就是二元运算；相似地一一对应的那种函数就是一元运算了，以此类推。<br><img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711627187999.png" alt="1711627187999"><br>值得注意的是二元运算并不都符合结合律，交换律，分配率那些。。。</p>
<p><img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711627256797.png" alt="1711627256797"><br>其实同构的代数系本质上是一样的，元素对象的命名不同而已。</p>
]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学（2）</title>
    <url>/2024/03/30/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h2 id="离散数学基础（2）"><a href="#离散数学基础（2）" class="headerlink" title="离散数学基础（2）"></a>离散数学基础（2）</h2><p>本篇博客简单理解一下各种映射的本质</p>
<span id="more"></span>

<p>对于一个映射A→B：</p>
<ul>
<li><p>单射：</p>
<ul>
<li>类似于函数的一一对应性质，不包括多对一的情况。限制于A集合，即B集合可以有元未被映射</li>
<li><img src="https://pic3.zhimg.com/80/v2-070562850aaee357be93a2a67c794a36_1440w.webp" alt="img"></li>
</ul>
</li>
<li><p>满射：</p>
<ul>
<li>即把B中的所有元都用上，主要限制于B集合，即A集合可以不指向B的元</li>
<li><img src="https://pic4.zhimg.com/80/v2-a7d76ec834eee4adb7df74857a3b8a07_1440w.webp" alt="img"></li>
</ul>
</li>
<li><p>双射：</p>
<ul>
<li>既是单射又是满射，严格的一一对应关系。</li>
<li><img src="https://pic2.zhimg.com/80/v2-c13f789dab192de9ca2ed763995a956d_1440w.webp" alt="img"></li>
</ul>
</li>
</ul>
<p>接着是逆映射的概念：</p>
<p>只有双射才可以定义逆映射。类比于函数的可逆函数。</p>
<p>复合映射：</p>
<p>类比于复合函数。</p>
]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>筛去重复元素</title>
    <url>/2023/12/14/%E7%AD%9B%E5%8E%BB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="筛去重复元素"><a href="#筛去重复元素" class="headerlink" title="筛去重复元素"></a>筛去重复元素</h1><p>最近发现这样一道题，大致意思是给定一个数组，其中元素仅有一个只出现一次，其余元素均出现两次，编写程序以找出这个数。</p>
<p>这里可以用到异或运算。</p>
<span id="more"></span>

<p>异或运算法则如下：</p>
<ol>
<li><p>交换律：A ^ B &#x3D; B ^ A</p>
</li>
<li><p>结合律：A ^ (B ^ C) &#x3D; (A ^ B) ^ C</p>
</li>
<li><p><strong>恒等律：X ^ 0 &#x3D; X</strong></p>
</li>
<li><p><strong>归零律：X ^ X &#x3D; 0</strong></p>
</li>
<li><p>自反：A ^ B ^ B &#x3D; A ^ 0 &#x3D; A</p>
<p>这里主要用到后三条性质，可以定义变量key，不断与数组元素进行异或运算，某种意义上达到对于数组的压缩储存。</p>
</li>
</ol>
<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> key=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        key^=<span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,func(<span class="built_in">array</span>,<span class="number">13</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体编程</title>
    <url>/2023/11/27/%E7%BB%93%E6%9E%84%E4%BD%93%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>屎山测试第二趴</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">某校的惯例是在每学期的期末考试之后发放奖学金。发 放</span><br><span class="line">的奖学金共有五种，每项奖学金获取的条件分别如下：</span><br><span class="line"><span class="number">1</span>) 院士奖学金：期末平均成绩高于 <span class="number">80</span> 分（&gt;<span class="number">80</span>），并且在本学期内发表 <span class="number">1</span> 篇或</span><br><span class="line"><span class="number">1</span> 篇以上论文的学生每人均可获得 <span class="number">8000</span> 元；</span><br><span class="line"><span class="number">2</span>) 五四奖学金：期末平均成绩高于 <span class="number">85</span> 分（&gt;<span class="number">85</span>），并且班级评议成绩高于 <span class="number">80</span> 分</span><br><span class="line">（&gt;<span class="number">80</span>）的学生每人均可获得 <span class="number">4000</span> 元；</span><br><span class="line"><span class="number">3</span>) 成绩优秀奖：期末平均成绩高于 <span class="number">90</span> 分（&gt;<span class="number">90</span>）的学生每人均可获得 <span class="number">2000</span> 元；</span><br><span class="line"><span class="number">4</span>) 西部奖学金：期末平均成绩高于 <span class="number">85</span> 分（&gt;<span class="number">85</span>）的西部省份学生每人均可获得</span><br><span class="line"><span class="number">1000</span> 元；</span><br><span class="line"><span class="number">5</span>) 班级贡献奖：班级评议成绩高于 <span class="number">80</span> 分（&gt;<span class="number">80</span>）的学生干部每人均可获得 <span class="number">850</span></span><br><span class="line">元；</span><br><span class="line">只要符合上述条件就可获得相应的奖项，每项奖学金的获奖人数没有限制，每</span><br><span class="line">名学生也可以同时获得多项奖学金。例如姚明的期末平均成绩是 <span class="number">87</span> 分，班级</span><br><span class="line">评议成绩 <span class="number">82</span> 分，同时他还是一位学生干部，那么他可以同时获得五四奖学金</span><br><span class="line">和班级贡献奖，奖金总数是 <span class="number">4850</span> 元。</span><br><span class="line">现在给出若干学生的相关数据（假设总有同学能满足获得奖学金的条件），</span><br><span class="line">程序运行时，要先输入学生人数。提示：<span class="string">&quot;Input n:&quot;</span>，然后逐个输入学生信息：</span><br><span class="line">输入学生姓名提示：<span class="string">&quot;Input name:&quot;</span></span><br><span class="line">输入学生期末平均成绩提示：<span class="string">&quot;Input final score:&quot;</span></span><br><span class="line">输入学生班级评议成绩提示：<span class="string">&quot;Input class score:&quot;</span></span><br><span class="line">输入是否为学生干部提示：<span class="string">&quot;Class cadre or not?(Y/N):&quot;</span></span><br><span class="line">输入是否为西部学生提示：<span class="string">&quot;Students from the West or not?(Y/N):&quot;</span></span><br><span class="line">输入发表文章数量提示：<span class="string">&quot;Input the number of published papers:&quot;</span></span><br><span class="line"><span class="number">1.</span>请定义结构体类型 S</span><br><span class="line"><span class="number">2.</span> 编程输入所有学生的数据（定义 input 函数 ）</span><br><span class="line"><span class="number">3.</span>将所有的学生按照姓名进行排序（定义 sort 函数 <span class="number">10</span> 分）</span><br><span class="line"><span class="number">4.</span>后输出每个人的信息（print 函数）</span><br><span class="line"><span class="number">5.</span>计算每个同学获得的奖金总数（定义 addup 函数）</span><br><span class="line"><span class="number">6.</span>并找到奖金最高者（定义 findMax 函数 <span class="number">5</span> 分），打印出他的名字和奖金数额。</span><br><span class="line"><span class="number">7.</span>主函数。注意请不要使用全局变量。</span><br></pre></td></tr></table></figure>





<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">float</span> final_score;</span><br><span class="line">    <span class="type">float</span> class_score;</span><br><span class="line">    <span class="type">char</span> is_cadre; <span class="comment">// &#x27;Y&#x27;表示是学生干部，&#x27;N&#x27;表示不是</span></span><br><span class="line">    <span class="type">char</span> is_west; <span class="comment">// &#x27;Y&#x27;表示来自西部省份，&#x27;N&#x27;表示不是</span></span><br><span class="line">    <span class="type">int</span> published_papers;</span><br><span class="line">    <span class="type">int</span> scholarship;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义输入函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input</span><span class="params">(<span class="keyword">struct</span> S *s)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input name: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input final score: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;(s-&gt;final_score));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input class score: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;(s-&gt;class_score));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Class cadre or not? (Y/N): &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;(s-&gt;is_cadre));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Students from the West or not? (Y/N): &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;(s-&gt;is_west));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input the number of published papers: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(s-&gt;published_papers));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义排序函数（造个小轮子方便引用qsort）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sort</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(((<span class="keyword">struct</span> S *)a)-&gt;name, ((<span class="keyword">struct</span> S *)b)-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="keyword">struct</span> S *s)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, s-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final score: %.2f\n&quot;</span>, s-&gt;final_score);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Class score: %.2f\n&quot;</span>, s-&gt;class_score);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Class cadre: %c\n&quot;</span>, s-&gt;is_cadre);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Students from the West: %c\n&quot;</span>, s-&gt;is_west);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Published papers: %d\n&quot;</span>, s-&gt;published_papers);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Scholarship: %d\n&quot;</span>, s-&gt;scholarship);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addup</span><span class="params">(<span class="keyword">struct</span> S *s)</span> &#123;</span><br><span class="line">    s-&gt;scholarship = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;final_score &gt; <span class="number">80</span> &amp;&amp; s-&gt;published_papers &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        s-&gt;scholarship += <span class="number">8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;final_score &gt; <span class="number">85</span> &amp;&amp; s-&gt;class_score &gt; <span class="number">80</span>) &#123;</span><br><span class="line">        s-&gt;scholarship += <span class="number">4000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;final_score &gt; <span class="number">90</span>) &#123;</span><br><span class="line">        s-&gt;scholarship += <span class="number">2000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;final_score &gt; <span class="number">85</span> &amp;&amp; s-&gt;is_west == <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">        s-&gt;scholarship += <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;class_score &gt; <span class="number">80</span> &amp;&amp; s-&gt;is_cadre == <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">        s-&gt;scholarship += <span class="number">850</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> S <span class="title function_">findMax</span><span class="params">(<span class="keyword">struct</span> S *students, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">maxStudent</span> =</span> students[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (students[i].scholarship &gt; maxStudent.scholarship) &#123;</span><br><span class="line">            maxStudent = students[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxStudent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input n: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span> *<span class="title">students</span> =</span> (<span class="keyword">struct</span> S *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nEnter data for student %d:\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        input(&amp;students[i]);</span><br><span class="line">        addup(&amp;students[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qsort(students, n, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S), sort);<span class="comment">//按名字排序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nStudent information:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        print(&amp;students[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">maxStudent</span> =</span> findMax(students, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nStudent with the highest scholarship:\n&quot;</span>);</span><br><span class="line">    print(&amp;maxStudent);</span><br><span class="line">    <span class="built_in">free</span>(students);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>屎山</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2023/10/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一点关于贪心算法的思考"><a href="#一点关于贪心算法的思考" class="headerlink" title="一点关于贪心算法的思考"></a>一点关于贪心算法的思考</h1><h4 id="关于贪心算法，ChatGPT是这么定义的："><a href="#关于贪心算法，ChatGPT是这么定义的：" class="headerlink" title="关于贪心算法，ChatGPT是这么定义的："></a>关于贪心算法，ChatGPT是这么定义的：</h4><p>贪心算法（Greedy Algorithm）是一种求解最优化问题的算法范式，它在每一步选择当前状态下的最优解，最终期望通过一系列的最优选择达到全局最优解。贪心算法通常适用于那些具有最优子结构性质的问题，其中整体问题的最优解可以通过局部子问题的最优解得到。</p>
<p>贪心算法的一般思想是按照某种规则，从问题的初始状态开始，通过一系列局部最优的选择，逐步逼近问题的全局最优解。每一步的选择不依赖于前面的选择，也不会影响以后的选择。因此，贪心算法通常是一个非常高效的算法，因为它不需要考虑所有可能的解决方案，只需关注当前的最优选择。</p>
<span id="more"></span>
<p><strong>显然，此算法是通过局部运算达到计算整体最优解的效果。</strong></p>
<h4 id="举个生活中常见的实例："><a href="#举个生活中常见的实例：" class="headerlink" title="举个生活中常见的实例："></a>举个生活中常见的实例：</h4><p>假设有1元、2元、5元、10元、20元、50元、100元的纸币。现在要用这些钱来支付，至少要用多少张纸币？用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。在日常生活中我们自然而然也是这么做的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m[<span class="number">7</span>]= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>&#125;; <span class="comment">//先有纸币的数额</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">//所找的金额</span></span><br><span class="line">	<span class="type">int</span> num;          <span class="comment">//所需纸币的张数</span></span><br><span class="line">    <span class="keyword">while</span>((	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ret))!=EOF) &#123;</span><br><span class="line">		<span class="keyword">while</span>(ret&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(ret&gt;=<span class="number">100</span>) &#123;</span><br><span class="line">                ret-=<span class="number">100</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret&gt;=<span class="number">50</span>&amp;&amp;ret&lt;<span class="number">100</span>) &#123;</span><br><span class="line">                ret-=<span class="number">50</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret&gt;=<span class="number">20</span>&amp;&amp;ret&lt;<span class="number">50</span>) &#123;</span><br><span class="line">                ret-=<span class="number">20</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret&gt;=<span class="number">5</span>&amp;&amp;ret&lt;<span class="number">20</span>) &#123;</span><br><span class="line">                ret-=<span class="number">5</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret&gt;=<span class="number">2</span>&amp;&amp;ret&lt;<span class="number">5</span>) &#123;</span><br><span class="line">                ret-=<span class="number">2</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret&gt;=<span class="number">1</span>&amp;&amp;ret&lt;<span class="number">2</span>) &#123;</span><br><span class="line">                ret-=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="贪心算法的基本思路"><a href="#贪心算法的基本思路" class="headerlink" title="贪心算法的基本思路"></a>贪心算法的基本思路</h4><ol>
<li>候选集合S<br>为了构造问题的解决方案，有一个候选集合C作为问题的可能解，问题的最终解均取自于候选集合C。</li>
<li>解集合S<br>随着贪心选择的进行，解集合不断扩展，直到构成一个满足问题的完整解。</li>
<li>解决函数solution<br>检查解集合是否构成问题的完整解。</li>
<li>选择函数select<br>即贪心策略，这是贪心算法的关键，它指出哪个候选对象有希望构成成问题的解。</li>
<li>可行函数feasible<br>检查解集合中加入一个候选对象是否可行，即解集合扩展后是否满足约束条件。</li>
</ol>
<p>对应的，</p>
<h4 id="该算法存在的问题"><a href="#该算法存在的问题" class="headerlink" title="该算法存在的问题"></a>该算法存在的问题</h4><ul>
<li><p>不能保证求得的最后解是最佳的</p>
</li>
<li><p>不能用来求最大值或最小值的问题</p>
</li>
<li><p>只能求满足某些约束条件的可行解的范围</p>
</li>
</ul>
<p>要选出最优解不是一件容易的事，要证明局部最优为全局最优，要进行数学证明，否则就不能说明为全局最优。</p>
<p>很多问题表面上看来用贪心算法可以找到最优解，实际上却把最优解给漏掉了。这就像现实生活中的“贪小便宜吃大亏”。所以在解决问题的时候，一定要谨慎使用此算法，一定要注意这个问题适不适合采用贪心算法。</p>
<p>但是在很多大规模问题中，寻找最优解是一件相当费时耗力的事情，有时候付出大量人力物力财力后，回报并不与投入成正比。在这个时候选择相对最优的贪心算法就比较经济可行了。有的问题对最优的要求不是很高，在充分衡量付出和回报后，选择贪心算法未尝不是一种不错的选择。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>蹭饭图</title>
    <url>/2023/12/19/%E8%B9%AD%E9%A5%AD%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="19班蹭饭图"><a href="#19班蹭饭图" class="headerlink" title="19班蹭饭图"></a>19班蹭饭图</h2><p><img src="/2023/12/19/%E8%B9%AD%E9%A5%AD%E5%9B%BE/19%E8%B9%AD%E9%A5%AD%E5%9B%BE.png" alt="19班蹭饭图"></p>
<h2 id="20班蹭饭图"><a href="#20班蹭饭图" class="headerlink" title="20班蹭饭图"></a>20班蹭饭图</h2><p><img src="/2023/12/19/%E8%B9%AD%E9%A5%AD%E5%9B%BE/20%E8%B9%AD%E9%A5%AD%E5%9B%BE.png" alt="20班蹭饭图"></p>
]]></content>
      <categories>
        <category>蹭饭图</category>
      </categories>
      <tags>
        <tag>蹭饭图</tag>
      </tags>
  </entry>
  <entry>
    <title>链表基本操作</title>
    <url>/2023/12/10/%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="链表基本操作"><a href="#链表基本操作" class="headerlink" title="链表基本操作"></a>链表基本操作</h3><p>（临时抱佛脚的笔记）</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头部插入节点</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">insertAtBeginning</span><span class="params">(<span class="keyword">struct</span> Node *head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newNode</span> =</span> createNode(data);</span><br><span class="line">    newNode-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表尾部插入节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertAtEnd</span><span class="params">(<span class="keyword">struct</span> Node *head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newNode</span> =</span> createNode(data);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第一个值为 data 的节点</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> Node *head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">current</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找要删除的节点并记录其前一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;data != data) &#123;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若找到要删除的节点，则删除它</span></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            head = current-&gt;next; <span class="comment">// 删除头节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev-&gt;next = current-&gt;next; <span class="comment">// 删除中间或尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(<span class="keyword">struct</span> Node *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放链表节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeList</span><span class="params">(<span class="keyword">struct</span> Node *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 初始化链表头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表头部插入节点</span></span><br><span class="line">    head = insertAtBeginning(head, <span class="number">10</span>);</span><br><span class="line">    head = insertAtBeginning(head, <span class="number">20</span>);</span><br><span class="line">    head = insertAtBeginning(head, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表尾部插入节点</span></span><br><span class="line">    insertAtEnd(head, <span class="number">40</span>);</span><br><span class="line">    insertAtEnd(head, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内容：\n&quot;</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    head = deleteNode(head, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除后的链表内容：\n&quot;</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表节点内存</span></span><br><span class="line">    freeList(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度算法</title>
    <url>/2024/04/02/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a>高精度算法</h1><p>在处理数据的时候经常需要用到一些无比巨大的数，比如41856410684191645611这种的，或者是十进制的二进制转化，显然cpp里不能直接用int存放这些数据，然而long类型也是有上限的，这时就需要引入一个新的算法，叫做高精度算法</p>
<span id="more"></span>

<h2 id="算法本质思想"><a href="#算法本质思想" class="headerlink" title="算法本质思想"></a>算法本质思想</h2><p>感觉多数思路就是用数组之类的容器存放数据，采用最原始的方式一点点进位计算之类的。（果然高端的食材往往采用最朴素的烹饪方式）。</p>
<h2 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h2><p>高精度计算中有几个细节需要注意：</p>
<ul>
<li><p>数据接受和储存： 当输入的数很长时，可以使用字符串方式输入和储存，再用字符串函数进行操作运算，将每一位去取出，存入数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">void init(<span class="type">int</span> a[]) &#123; <span class="comment">// 传入数组</span></span><br><span class="line">    <span class="type">string</span> s;</span><br><span class="line">    cin &gt;&gt; s; </span><br><span class="line">    <span class="built_in">len</span> = s.length(); <span class="comment">// s.length --&gt; 计算字符串位数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="built_in">len</span>; i++)     </span><br><span class="line">        a[i] = s[<span class="built_in">len</span> -i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//将字符串s转换为数组a, 倒序存储</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进位错位处理：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">// 加法进位: c[i] = a[i] + b[i]</span><br><span class="line"> </span><br><span class="line">code:    if(c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c[i] <span class="comment">%= 10;</span></span><br><span class="line">            ++c[i++];</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">//减法借位: c[i] = a[i] - b[i]</span><br><span class="line"> </span><br><span class="line">code:    if(a[i] &lt; b[i]) &#123;</span><br><span class="line">             --a[i+<span class="number">1</span>];</span><br><span class="line">             a[i] += <span class="number">10</span>;   </span><br><span class="line">         &#125; </span><br><span class="line"> </span><br><span class="line">//乘法进位: c[i + j - <span class="number">1</span>] = a[i] * b[j] + x + c[i + j - <span class="number">1</span>];</span><br><span class="line">          x = c[i + j - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">          c[i + j - <span class="number">1</span>] <span class="comment">% 10;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="高精度加法："><a href="#高精度加法：" class="headerlink" title="高精度加法："></a>高精度加法：</h3><p>输入两个数到变量中，然后用赋值语句求它们的和后输出 . But，我们知道，在 C++ 语言中任何数据类型都有一定表示范围. 当两个加数很大时，以前的算法显然不能求出精确解，因此我们需要寻求另一种方法 .在读小学时，我们做加法都采用竖式方法 . 这样我们方便写出两个整数相加的算法 .</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高精度加法</span></span><br><span class="line"><span class="keyword">string</span> add(<span class="keyword">string</span> num1, <span class="keyword">string</span> num2) &#123;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = num1.<span class="keyword">size</span>(), n2 = num2.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = n1 - <span class="number">1</span>, j = n2 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">string</span> sum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit1 = (i &gt;= <span class="number">0</span>) ? num1[i--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digit2 = (j &gt;= <span class="number">0</span>) ? num2[j--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s = digit1 + digit2 + carry;</span><br><span class="line">        carry = s / <span class="number">10</span>;</span><br><span class="line">        sum = to_string(s % <span class="number">10</span>) + sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高精度减法</span></span><br><span class="line"><span class="keyword">string</span> subtract(<span class="keyword">string</span> num1, <span class="keyword">string</span> num2) &#123;</span><br><span class="line">    <span class="keyword">int</span> borrow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = num1.<span class="keyword">size</span>(), n2 = num2.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = n1 - <span class="number">1</span>, j = n2 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">string</span> diff = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit1 = (i &gt;= <span class="number">0</span>) ? num1[i--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digit2 = (j &gt;= <span class="number">0</span>) ? num2[j--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> d = digit1 - digit2 - borrow;</span><br><span class="line">        <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            d += <span class="number">10</span>;</span><br><span class="line">            borrow = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            borrow = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        diff = to_string(d) + diff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除前导零</span></span><br><span class="line">    diff.erase(<span class="number">0</span>, diff.find_first_not_of(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> (diff == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高精度乘法</span></span><br><span class="line"><span class="keyword">string</span> multiply(<span class="keyword">string</span> num1, <span class="keyword">string</span> num2) &#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = num1.<span class="keyword">size</span>(), n2 = num2.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; result(n1 + n2, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> mul = (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">int</span> sum = mul + result[i + j + <span class="number">1</span>];</span><br><span class="line">            result[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">            result[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换为字符串</span></span><br><span class="line">    <span class="keyword">string</span> product = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> digit : result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(product.empty() &amp;&amp; digit == <span class="number">0</span>)) &#123;  <span class="comment">// 忽略前导零</span></span><br><span class="line">            product += to_string(digit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (product == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><h4 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">// 高精度除法（除以低精度）</span><br><span class="line">pair&lt;<span class="built_in">string</span>, int&gt; <span class="built_in">divide</span>(<span class="built_in">string</span> dividend, int divisor) &#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">quotient</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    int <span class="built_in">remainder</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (char digit : dividend) &#123;</span><br><span class="line">        int <span class="built_in">num</span> = digit - &#x27;<span class="number">0</span>&#x27; + <span class="built_in">remainder</span> * <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">quotient</span> += to_string(<span class="built_in">num</span> / divisor);</span><br><span class="line">        <span class="built_in">remainder</span> = <span class="built_in">num</span> <span class="symbol">%</span> divisor;</span><br><span class="line">    &#125;</span><br><span class="line">    // 删除前导零</span><br><span class="line">    <span class="built_in">quotient</span>.erase(<span class="number">0</span>, <span class="built_in">quotient</span>.find_first_not_of(&#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">    <span class="built_in">return</span> make_pair((<span class="built_in">quotient</span> == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : <span class="built_in">quotient</span>, <span class="built_in">remainder</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="高精度除以高精度"><a href="#高精度除以高精度" class="headerlink" title="高精度除以高精度"></a>高精度除以高精度</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">// 高精度除法（除以高精度）</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; <span class="built_in">divide</span>(<span class="built_in">string</span> dividend, <span class="built_in">string</span> divisor) &#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">quotient</span> = <span class="string">&quot;0&quot;</span>, <span class="built_in">remainder</span> = dividend;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">remainder</span>.size() &gt;= divisor.size() &amp;&amp; <span class="built_in">remainder</span> &gt;= divisor) &#123;</span><br><span class="line">        int n = <span class="built_in">remainder</span>.size() - divisor.size();</span><br><span class="line">        <span class="built_in">string</span> temp = divisor;</span><br><span class="line">        temp.<span class="built_in">append</span>(n, &#x27;<span class="number">0</span>&#x27;); // 补零</span><br><span class="line">        int count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">remainder</span> &gt;= temp) &#123;</span><br><span class="line">            <span class="built_in">remainder</span> = subtract(<span class="built_in">remainder</span>, temp);</span><br><span class="line">            <span class="built_in">quotient</span> = add(<span class="built_in">quotient</span>, <span class="string">&quot;1&quot;</span> + <span class="built_in">string</span>(n, &#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 删除前导零</span><br><span class="line">    <span class="built_in">quotient</span>.erase(<span class="number">0</span>, <span class="built_in">quotient</span>.find_first_not_of(&#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">    <span class="built_in">remainder</span>.erase(<span class="number">0</span>, <span class="built_in">remainder</span>.find_first_not_of(&#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">    <span class="built_in">return</span> make_pair((<span class="built_in">quotient</span> == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : <span class="built_in">quotient</span>, (<span class="built_in">remainder</span> == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : <span class="built_in">remainder</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="压位技巧"><a href="#压位技巧" class="headerlink" title="压位技巧"></a>压位技巧</h3><p>谁说数组每个元素只能是一位数？显然这会造成巨大的浪费。<br>这时我们就可以使用压位的技巧来节省运行时间。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压位技巧高精度加法</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">add</span>(<span class="params"><span class="built_in">string</span> num1, <span class="built_in">string</span> num2</span>)</span> &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="built_in">int</span>&gt; <span class="title">result</span>(<span class="params">max(num1.size(</span>), num2.<span class="title">size</span>()) + 1, 0)</span>; <span class="comment">// 结果数组</span></span><br><span class="line">    <span class="built_in">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="built_in">int</span> i = num1.size() - <span class="number">1</span>, j = num2.size() - <span class="number">1</span>, k = result.size() - <span class="number">1</span>; <span class="comment">// 从个位开始相加</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">        <span class="built_in">int</span> digit1 = (i &gt;= <span class="number">0</span>) ? num1[i--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>; <span class="comment">// 获取num1的当前位数字</span></span><br><span class="line">        <span class="built_in">int</span> digit2 = (j &gt;= <span class="number">0</span>) ? num2[j--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>; <span class="comment">// 获取num2的当前位数字</span></span><br><span class="line">        <span class="built_in">int</span> sum = digit1 + digit2 + carry; <span class="comment">// 当前位的和</span></span><br><span class="line">        result[k--] = sum % <span class="number">10</span>; <span class="comment">// 将当前位的和放入结果数组</span></span><br><span class="line">        carry = sum / <span class="number">10</span>; <span class="comment">// 更新进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换结果数组为字符串</span></span><br><span class="line">    <span class="built_in">string</span> sum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> digit : result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(sum.empty() &amp;&amp; digit == <span class="number">0</span>)) &#123; <span class="comment">// 忽略前导零</span></span><br><span class="line">            sum += to_string(digit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (sum == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : sum; <span class="comment">// 如果结果为空字符串，则返回&quot;0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> num1 = <span class="string">&quot;123456789012345678901234567890&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> num2 = <span class="string">&quot;987654321098765432109876543210&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;高精度加法结果：&quot;</span> &lt;&lt; <span class="keyword">add</span>(num1, num2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总之大多数需要根据现实情况变通。。。。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
</search>
